file C:\Users\Chiuwe\Desktop\4D_Projects\GUI\Torch_GUI.4Dg

file C:\Program Files (x86)\4D Labs\4D Workshop 4 IDE\include\uLCD-70DT.fnc

000001  000001  #platform "uLCD-70DT"
000002  000001  #platform "uLCD-70DT"
000003  000008  */
000004  000009      #constant ULCD_70DT_DIABLO16_GFX
000005  000009      #constant ULCD_70DT_DIABLO16_GFX
000006  000010        
000007  000011      #IFNOT EXISTS DIABLO16_GFX2_FUNCTIONS
file C:\Program Files (x86)\4D Labs\4D Workshop 4 IDE\include\Diablo16_Functions.fnc

000008  000012          #inherit "Diablo16_Functions.fnc"          // inherit the generic functions
000009  000012          #inherit "Diablo16_Functions.fnc"          // inherit the generic functions
000010  000001        
000011  000002  // Common inheritance for Diablo16 platforms
000012  000003        
000013  000004  //#constant ULCD_32PT_DIABLO16_GFX
000014  000005        
000015  000006        
000016  000007  // define the compiler dummy preambles
000017  000008  #constant LOCAL $//
000018  000008  #constant LOCAL $//
000019  000009  #constant EXTERN $ /**/
000020  000009  #constant EXTERN $ /**/
000021  000010        
000022  000011  #CONST
000023  000020  #END
000024  000021        
000025  000022  #CONST
000026  000038  #END
000027  000039        
000028  000040        
000029  000041        
000030  000042        
000031  000047  */
000032  000048        
000033  000049        
000034  000050  //------------------------------------------------------------------//
000035  000051  //     EVE  miscellaneous functions                                 //
000036  000052  //------------------------------------------------------------------//
000037  000053        
000038  000054  func to("device"), 0;                // output device redirection
000039  000055  // Syntax: to(outstream);
000040  000056  // Usage : to(APPEND); putstr("TWO ");
000041  000057  // Notes : outstream: A variable or constant specifying destination for putch, putstr, putnum and print functions.
000042  000058  //     :
000043  000059  //     : to() sends the printed output to destinations other than the screen. Normally, print just
000044  000060  //     : sends its output to the display in TEXT mode which is the default, however, the output from
000045  000061  //     : print can be sent to COM0, and MDA (media) 'streams'. The to(...) function can also stream
000046  000062  //     : to a memory array . Note that once the to(...) function has taken effect, the stream reverts
000047  000063  //     : back to the default stream which is TEXT as soon as putch, putstr, putnum or print has
000048  000064  //     : completed its action. The APPEND argument is used to send the printed output to the same
000049  000065  //     : place as the previous redirection. This is most useful for building string arrays, or adding
000050  000066  //     : sequential data to a media stream.
000051  000067  //     :
000052  000068  //     : Predefined Name Constant    putch(), putstr(), putnum(), print() redirection
000053  000069  //     : APPEND         0x0000      Output is directed to the same stream that was previously assigned. Output is
000054  000070  //     :                            appended to user memory if previous redirection was to an array.
000055  000071  //     : COM0           0xFF04      Output is redirected to the COM (serial) port.
000056  000072  //     : TEXT           0xFF08      Output is directed to the screen (default).
000057  000073  //     : MDA            0xFF10      Output is directed to the SD or FLASH media.
000058  000074  //     : I2C1           0xF820      Output is directed to the I2C1 port.
000059  000075  //     : memory pointer             Output is redirect to the memory pointer argument, eg to(myarray); print("HELLO");
000060  000076        
000061  000077  //------------------------------------------------------------------//
000062  000078  // to(..) redirection constants            //
000063  000079  //------------------------------------------------------------------//
000064  000080  #CONST
000065  000093  #END
000066  000094        
000067  000095        
000068  000096  func putch("char"), 0;                // write single char to current output device
000069  000097  // Syntax    : putch("char");
000070  000098  // Usage     : putch("A");
000071  000099  // Notes     : prints single characters to the current output stream, usually the
000072  000100  //           : display unless redirected with the ‘to’ redirection function.
000073  000101  //         : The arguments can be a variable, array element, expression or constant.
000074  000102        
000075  000103        
000076  000104  func putchXY("xpos", "ypos", "char"), 0;
000077  000105  // Syntax  : putchXY(x, y, '0x41'),
000078  000106  // Usage   : putchXY(100, 100, "HELLO");
000079  000107  // Notes   : Print a single character at position x, y.
000080  000108  //         : Char may be a constant or variable.
000081  000109  // Returns : nothing.
000082  000110        
000083  000111  func putstrXY("xpos", "ypos", "string"), 0;
000084  000112  // Syntax  : putstrXY(x, y, "string"),
000085  000113  // Usage   : putstrXY(100, 100, "HELLO");
000086  000114  // Notes   : Print a string at position x, y
000087  000115  //         : "String" may be a string constant, or pointer to a word aligned string.
000088  000116  // Returns : nothing.
000089  000117        
000090  000118        
000091  000119  func putstrCentred("xc", "yc", "string"), 0;
000092  000120  // Syntax  : putstrCentred(x, y, "string"),
000093  000121  // Usage   : putstrCentred(100, 100, "HELLO");
000094  000122  // Notes   : Print a string centred at position x, y
000095  000123  //         : "String" may be a string constant, or pointer to a word aligned string.
000096  000124  // Returns : nothing.
000097  000125        
000098  000126        
000099  000127  func pause("milliseconds"), 0;            // blocking delay
000100  000128  // Syntax: pause(milliseconds);
000101  000129  // Usage : pause(1000);                //pause for 1 second
000102  000130  // Notes : Pause for a number of milli second.Maximum delay could be 65535 milli seconds
000103  000131        
000104  000132        
000105  000133  func putnum("arg1","arg2"), 1;            // print number to current output device
000106  000134  // Syntax: putnum(format, value);
000107  000135  // Usage : var := putnum(HEX, val);
000108  000136  // Notes : prints a 16bit number in various formats to the current output stream, usually the display.
000109  000137  //     : Format: A constant that specifies the number format
000110  000138  //     : Value : The number to be printed
000111  000139  //     : (      DECIMAL   )    (   UNSIGNED DECIMAL )    (    HEX         )     (    BINARY          )
000112  000140  //     : DEC     DECZ     DECZB     UDEC     UDECZ     UDECZB     HEX     HEXZ     HEXZB     BIN     BINZ     BINZB
000113  000141  //     : DEC1 DEC1Z     DEC1ZB     UDEC1     UDEC1Z     UDEC1ZB HEX1     HEX1Z     HEX1ZB     BIN1     BIN1Z     BIN1ZB
000114  000142  //     : DEC2 DEC2Z     DEC2ZB     UDEC2     UDEC2Z     UDEC2ZB HEX2     HEX2Z     HEX1ZB     BIN2     BIN2Z     BIN2ZB
000115  000143  //     : DEC3 DEC3Z     DEC3ZB     UDEC3     UDEC3Z     UDEC3ZB HEX3     HEX3Z     HEX1ZB     BIN3     BIN3Z     BIN3ZB
000116  000144  //     : DEC4 DEC4Z     DEC4ZB     UDEC4     UDEC4Z     UDEC4ZB HEX4     HEX4Z     HEX1ZB     BIN4     BIN4Z     BIN4ZB
000117  000145  //     : DEC5 DEC5Z     DEC5ZB     UDEC5     UDEC5Z     UDEC5ZB             BIN5     BIN5Z     BIN5ZB
000118  000146  //     :                                     BIN6     BIN6Z     BIN6ZB
000119  000147  //     :                                     BIN7     BIN7Z     BIN7ZB
000120  000148  //     :                                     BIN8     BIN8Z     BIN8ZB
000121  000149  //     :                                     BIN9     BIN9Z     BIN9ZB
000122  000150  //     :                                     BIN10     BIN10Z     BIN10ZB
000123  000151  //     :                                     BIN11     BIN11Z     BIN11ZB
000124  000152  //     :                                     BIN12     BIN12Z     BIN12ZB
000125  000153  //     :                                     BIN13     BIN13Z     BIN13ZB
000126  000154  //     :                                     BIN14     BIN14Z     BIN14ZB
000127  000155  //     :                                     BIN15     BIN15Z     BIN15ZB
000128  000156  //     :                                     BIN16     BIN16Z     BIN16ZB
000129  000157  //     : field: Returns the the default width of the numeric field (digit count), usually ignored.
000130  000158  //     : bit 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
000131  000159  //     : | | | | \___ ___/ \__ __/ \_____ _____/
000132  000160  //     : | | | | V V V
000133  000161  //     : | | | | | | |
000134  000162  //     : | | | | | |
000135  000163  //     : | | | | (nb 0 = 16) | |____BASE (usually 2,10 or 16)
000136  000164  //     : | | | | digit count |
000137  000165  //     : | | | | |___reserved (not used on GOLDELOX)
000138  000166  //     : | | | |
000139  000167  //     : | | | |
000140  000168  //     : | | | |
000141  000169  //     : | | | |
000142  000170  //     : | | | |
000143  000171  //     : | | | |______ 1 = leading zeros included
000144  000172  //     : | | | 0 = leading zeros suppressed
000145  000173  //     : | | |
000146  000174  //     : | | |
000147  000175  //     : | | |_______ 1 = leading zero blanking
000148  000176  //     : | |
000149  000177  //     : | |_____ sign bit (0 = signed, 1 = unsigned)
000150  000178  //     : |
000151  000179  //     : |______ 1 = space before unsigned number
000152  000180        
000153  000181        
000154  000182  func __translate("arg1","arg2","arg3","arg4"), 1; // list translator (*** internal compiler use only, not usable)
000155  000183        
000156  000184        
000157  000185  func putstr("string"), 1;                         // print var (word) aligned string to current output device
000158  000186  // Syntax: putstr(pointer);
000159  000187  // Usage : putstr("HELLO\n");
000160  000188  // Notes : putstr prints a string to the current output stream, usually the display. The argument can be
000161  000189  //       : a string constant, a word aligned pointer to a string, a pointer to an array, or a pointer to
000162  000190  //       : a data statement. Note that string constants and data statement pointers are byte aligned.
000163  000191  //       : The output of putstr can be redirected to the communications port, the media, or memory
000164  000192  //       : using the to(...); function.
000165  000193  //       : A string constant is automatically terminated with a zero.
000166  000194  //       : A string in a data statement is not automatically terminated with a zero.
000167  000195  //       : All variables in 4DGL are 16bit, if an array is used for holding 8 bit characters, each array
000168  000196  //       : element packs 1 or 2 characters.
000169  000197        
000170  000198        
000171  000199  func strlen("varAddress"), 1;                   // return length of a var (word) aligned string in character units
000172  000200  // Syntax: strlen("varAddress);
000173  000201  // Usage : strlen("HELLO\n");
000174  000202  // Notes : gives the length of a string that is packed into regular var array
000175  000203  //       : Use str_Length(ptr)  for string pointer mode
000176  000204        
000177  000205        
000178  000206  func charwidth("char"), 1;
000179  000207  // Syntax  : charwidth(char);
000180  000208  // Usage   : wid := charwidth('W');
000181  000209  // Notes   : calculates width of a character in pixel units.
000182  000210  //         : 'char' may be a constant or variable.
000183  000211  // Returns : Width of character in pixel units.
000184  000212        
000185  000213        
000186  000214  func charheight("char"), 1;
000187  000215  // Syntax  : charheight(char);
000188  000216  // Usage   : ht := charheight('0x41');
000189  000217  // Notes   : Calculates height of a character in pixel units.
000190  000218  //         : 'char' may be a constant or variable.
000191  000219  // Returns : Height of character in pixel units.
000192  000220        
000193  000221        
000194  000222  func strwidth("pointer"), 1;
000195  000223  // Syntax  : strwidth(ptr);
000196  000224  // Usage   : x := strwidth("HELLO");
000197  000225  // Notes   : returns width of a string in pixel units.
000198  000226  //         : 'pointer' may be a constant or pointer to word aligned variable
000199  000227  // Returns : Width of string in pixel units, can be multi line.
000200  000228        
000201  000229        
000202  000230  func strheight(), 1;
000203  000231  // Syntax  : strheight();
000204  000232  // Usage   : h := strheight();
000205  000233  // Notes   : calculates height of a string in pixel units (after a call to strwidth );
000206  000234  //         : pointer may be a constant or pointer to word aligned variable
000207  000235  // Returns : Height of string in pixel units, can be multi line.
000208  000236        
000209  000237        
000210  000238  func unicode_page("charbeg","charend","charoffset"), 1;
000211  000239  // Syntax: unicode_page("charbeg","charend","charoffset");
000212  000240  // Usage : eg:  F_Traditional_0x20_0xFF
000213  000241  // Notes : After selecting a unicode image control with txt_FontID,
000214  000242  //       : this function is called to set the required font within the
000215  000243  //       : unicode set. The file "Unicode.inc" contains wrappers for
000216  000244  //       : this function, and it is not normally called directly.
000217  000245  //       : Returns count of characters in the set.
000218  000246  //       : Refer to "Unicode.inc" for further information.
000219  000247        
000220  000248        
000221  000249  //------------------------------------------------------------------//
000222  000250  //          Text Related Functions                                  //
000223  000251  //------------------------------------------------------------------//
000224  000252        
000225  000253  func txt_MoveCursor("line", "column"), 0;
000226  000254  // Syntax: txt_SetCursor(line, column);
000227  000255  // Usage : txt_SetCursor(arg1, arg2);
000228  000256  // Notes : Moves the text Cursor to a new screen position set by
000229  000257  //       : line,column parameters.
000230  000258        
000231  000259  func txt_Set("function", "value"), 0;
000232  000260  // Syntax: txt_Set(function, value);
000233  000261  // Usage : txt_Set(arg1, arg2);
000234  000262  // Returns : Original value before the change
000235  000263  // Notes : Sets various text related parameters used by other functions
000236  000264  //       : This allows the features to be set programatically with a
000237  000265  //       : single function call.It is strongly recommended to use the
000238  000266  //       : pre-defined constants rather than the mode numbers.
000239  000267  //       : NB:- It is often required to be able to set text
000240  000268  //       : functions with a single function call for graphics engine
000241  000269  //       : related functions, however, there is a complete set of single parameter
000242  000270  //       : shortcut functions that have exactly the same function as
000243  000271  //       : each of the txt_Set modes and saves 1 parameter / uses less memory
000244  000272  //       :
000245  000273  //       : txt_Set(TEXT_COLOUR, colour);        // function 0, TEXT_COLOUR, default colour = LIME
000246  000274  //       : txt_Set(TEXT_HIGHLIGHT, colour);     // function 1, TEXT_HIGHLIGHT)
000247  000275  //       : txt_Set(FONT_ID, fontNumer);         // function 2, FONT_ID)
000248  000276  //       : txt_Set(TEXT_WIDTH, multiplier);     // function 3, TEXT_WIDTH)
000249  000277  //       : txt_Set(TEXT_HEIGHT, multiplier);    // function 4, TEXT_HEIGHT)
000250  000278  //       : txt_Set(TEXT_XGAP, pixels);          // function 5, TEXT_XGAP)
000251  000279  //       : txt_Set(TEXT_YGAP, pixels);          // function 6, TEXT_YGAP)
000252  000280  //       : txt_Set(TEXT_PRINTDELAY, msecs);     // function 7, TEXT_PRINTDELAY)
000253  000281  //       : txt_Set(TEXT_OPACITY, value);        // function 8, TEXT_OPACITY)
000254  000282  //       : txt_Set(TEXT_BOLD, boldness);        // function 9, TEXT_BOLD)
000255  000283  //       : txt_Set(TEXT_ITALIC, slope);         // function 10, TEXT_ITALIC)
000256  000284  //       : txt_Set(TEXT_INVERSE, onoff);        // function 11, TEXT_INVERSE)
000257  000285  //       : txt_Set(TEXT_UNDERLINED, onoff);     // function 12, TEXT_UNDERLINED)
000258  000286  //       : txt_Set(TEXT_ATTRIBUTES, combine);   // function 13, TEXT_ATTRIBUTES)
000259  000287  //       : txt_Set(TEXT_WRAP, column);          // function 14, TEXT_WRAP)
000260  000288  //       : txt_Set(TEXT_ANGLE , degrees);       // function 15, TEXT_ANGLE)
000261  000289  //       :
000262  000290  //       : txt_Set(TEXT_COLOUR, colour);
000263  000291  //       : mode = TEXT_COLOUR (function 0)
000264  000292  //       : txt_Set(TEXT_COLOUR, value);
000265  000293  //       : value = 0 to 0xFFFF, Black to White
000266  000294  //       : Sets the Text colour for the display
000267  000295  //       : Default = LIME.
000268  000296  //       :
000269  000297  //       : mode = TEXT_HIGHLIGHT (function 1)
000270  000298  //       : txt_Set(TEXT_HIGHLIGHT, value);
000271  000299  //       : value = 0 to 0xFFFF, Black to White
000272  000300  //       : Sets the Text background colour for the display. Effective
000273  000301  //       : when text mode is Opaque.
000274  000302  //       : Default = BLACK.
000275  000303  //       :
000276  000304  //       : mode = FONT_ID (function 2)
000277  000305  //       : txt_Set(FONT_ID, value);
000278  000306  //       : value = FONT1 to FONT11 for internal fonts
000279  000307  //       : else this value is the name of a font included
000280  000308  //       : in a users program in a data statement.
000281  000309  //       : Default = FONT SIZE 3.
000282  000310  //       :
000283  000311  //       : mode = TEXT_WIDTH  (function 3)
000284  000312  //       : txt_Set(TEXT_WIDTH, value);
000285  000313  //       : value = 1 to 16
000286  000314  //       : Sets the Text Width multiplier
000287  000315  //       : text will be printed magnified horizontally
000288  000316  //       : by this factor, Default = 1.
000289  000317  //       :
000290  000318  //       : mode = TEXT_HEIGHT  (function 4)
000291  000319  //       : txt_Set(TEXT_HEIGHT, value);
000292  000320  //       : value = 1 to 16
000293  000321  //       : Sets the Text Height multiplier
000294  000322  //       : text will be printed magnified vertically
000295  000323  //       : by this factor, Default = 1.
000296  000324  //       :
000297  000325  //       : mode = TEXT_XGAP  (function 5)
000298  000326  //       : txt_Set(TEXT_XGAP, value);
000299  000327  //       : value = 1 to 32
000300  000328  //       : Sets the horizontal gap between characters
000301  000329  //       : The gap is in pixel units, Default = 0
000302  000330  //       :
000303  000331  //       : mode = TEXT_YGAP  (function 6)
000304  000332  //       : txt_Set(TEXT_YGAP, value);
000305  000333  //       : value = 1 to 32
000306  000334  //       : Sets the vertical gap below characters
000307  000335  //       : The gap is in pixel units, Default = 0
000308  000336  //       :
000309  000337  //       : mode = TEXT_PRINTDELAY  (function 7) DEPRECATED
000310  000338  //       : txt_Set(TEXT_PRINTDELAY, value);
000311  000339  //       : value = 0 to 255
000312  000340  //       : Sets the delay time (in ms) during character
000313  000341  //       : printing to give a 'teletype' like effect.
000314  000342  //       : Often used to attract attention to a string
000315  000343  //       : being printed which can often be missed if
000316  000344  //       : just suddenly appearing or changing.
000317  000345  //       : Default = 0 ms.
000318  000346  //       :
000319  000347  //       : mode = TEXT_OPACITY (function 8)
000320  000348  //       : txt_Set(TEXT_OPACITY, value);
000321  000349  //       : value = TRANSPARENT (0) = Text Trasparent
000322  000350  //       : value = OPAQUE (1) = Text Opaque
000323  000351  //       : Sets the Opacity/Transparency of the text
000324  000352  //       : Default = 0 or TRANSPARENT
000325  000353  //       :
000326  000354  //       : mode = TEXT_BOLD (function 9)
000327  000355  //       : txt_Set(TEXT_BOLD, value);
000328  000356  //       : value = dont care
000329  000357  //       : Sets Bold Text mode for the next string or char
000330  000358  //       : The feature automatically resets after printing
000331  000359  //       : using putstr or print has completed
000332  000360  //       :
000333  000361  //       : mode = TEXT_ITALIC (function10)
000334  000362  //       : txt_Set(TEXT_ITALIC, value);
000335  000363  //       : value = dont care
000336  000364  //       : Sets Italic Text mode for the next string or char
000337  000365  //       : The feature automatically resets after printing
000338  000366  //       : using putstr or print has completed
000339  000367        
000340  000368  //       : mode = TEXT_INVERSE (function 11)
000341  000369  //       : txt_Set(TEXT_INVERSE, value);
000342  000370  //       : value = dont care
000343  000371  //       : Sets Inverse Text mode for the next string or char
000344  000372  //       : The feature automatically resets after printing
000345  000373  //       : using putstr or print has completed
000346  000374  //       :
000347  000375  //       : mode = TEXT_UNDERLINED (function 12)
000348  000376  //       : txt_Set(TEXT_UNDERLINED, value);
000349  000377  //       : value = dont care
000350  000378  //       : Sets Underlined Text mode for the next string or char
000351  000379  //       : The feature automatically resets after printing
000352  000380  //       : using putstr or print has completed
000353  000381  //       :
000354  000382  //       : mode = TEXT_ATTRIBUTES (function 13)
000355  000383  //       : txt_Set(TEXT_ATTRIBUTES, value);
000356  000384  //       : value = bits are defined as:
000357  000385  //       :  BOLD        16          // TEXT_ATTRIBUTES bold text (auto reset)
000358  000386  //       :  ITALIC      32          // TEXT_ATTRIBUTES italic text (auto reset)
000359  000387  //       :  INVERSE     64          // TEXT_ATTRIBUTES inverse text (auto reset)
000360  000388  //       :  UNDERLINED  128         // TEXT_ATTRIBUTES underlined text (auto reset)
000361  000389  //       : Allows a combination of text attributes to be defined together
000362  000390  //       : by 'or'ing the bits together.
000363  000391  //       : Example: txt_Set(TEXT_ATTRIBUTES, BOLD | INVERSE); // bold + inverse
000364  000392  //       : The feature automatically resets after printing
000365  000393  //       : using putstr or print has completed.
000366  000394  //       : Bits 0-3 and 8-15 are reserved for future attributes.
000367  000395  //       :
000368  000396  //       : mode = TEXT_WRAP (function 14)
000369  000397  //       : txt_Set(TEXT_WRAP , value);
000370  000398  //       : Sets the position where text wrap will occur
000371  000399  //       : The feature automatically resets when screen
000372  000400  //       : mode is changed. If the value is set to 0,
000373  000401  //       : text wrap is turned off.
000374  000402  //       : of the current screen. Default value is 0
000375  000403  // Notes : The value is in pixel units.
000376  000404  //       :
000377  000405  //       : mode = TEXT_ANGLE (function 15)
000378  000406  //       : txt_Set(TEXT_ANGLE , value);
000379  000407  //       : Sets the angle of plotted fonts
000380  000408  // Notes : The angle is in degrees.
000381  000409  //       :
000382  000410        
000383  000411  //------------------------------------------------------------------------------
000384  000412  //txt_Set() related constants
000385  000413  //------------------------------------------------------------------------------
000386  000414  #CONST
000387  000433  #END
000388  000434        
000389  000435  //------------------------------------------------------------------------------
000390  000436  //txt_Set() related arguments
000391  000437  //------------------------------------------------------------------------------
000392  000438  #CONST
000393  000464  #END
000394  000465        
000395  000466        
000396  000467  //=====================================================//
000397  000468  // Single parameter short-cuts                         //
000398  000469  // for the txt_Set functions                           //
000399  000470  // These functions return the existing value before    //
000400  000471  // the change is made.                                 //
000401  000472  //=====================================================//
000402  000473  func txt_FGcolour("colour"), 1;             // 0  text foreground colour
000403  000474  func txt_BGcolour("colour"), 1;             // 1  text background colour
000404  000475  func txt_FontID("id"), 1;                   // 2  text font ID (0 = system font)
000405  000476  func txt_Width("multiplier"), 1;            // 3  text width multiplier
000406  000477  func txt_Height("multiplier"), 1;           // 4  text height multiplier
000407  000478  func txt_Xgap("pixelcount"), 1;             // 5  text gap between characters
000408  000479  func txt_Ygap("pixelcount"), 1;             // 6  text gap between lines
000409  000480  func txt_Delay("millisecs"), 1;             // 7  text printing delay factor
000410  000481  func txt_Opacity("mode"), 1;                // 8  text OPAQUE or TRANSPARENT
000411  000482  func txt_Bold("mode"), 1;                   // 9  text bold ON/OFF
000412  000483  func txt_Italic("mode"), 1;                 // 10 text italic ON/OFF
000413  000484  func txt_Inverse("mode"), 1;                // 11 text inverse ON/OFF
000414  000485  func txt_Underline("mode"), 1;              // 12 text underline ON/OFF
000415  000486  func txt_Attributes("value"), 1;            // 13 text combined bold|italic|inverse|underline
000416  000487  func txt_Wrap("value"), 1;                  // 14 text set text wrap position
000417  000488  func txt_Angle("value"), 1;                 // 15 text set angle of plotted font
000418  000489        
000419  000490        
000420  000491        
000421  000492  //------------------------------------------------------------------//
000422  000493  // Memory Access Functions                                          //
000423  000494  //------------------------------------------------------------------//
000424  000495                                                  //
000425  000496  func peekW("address"), 1;                       // read a word from system memory
000426  000497  func pokeW("address", "wordvalue"), 0;          // write a word to system memory
000427  000498  // refer to address map of internal variables   //
000428  000499        
000429  000500        
000430  000501  //------------------------------------------------------------------//
000431  000502  //        CTYPE Function Prototypes
000432  000503  //------------------------------------------------------------------//
000433  000504        
000434  000505  func isdigit("char"), 1;    //Returns a 1 if the character is an ascii digit else returns a 0
000435  000506  // Syntax: isdigit("char");
000436  000507  // Usage : Var := isdigit(ch);
000437  000508  // Notes : char specifies the ascii character for the test
000438  000509  //     : 0 : char is not an ascii digit.
000439  000510  //     : 1 : char is an ascii digit..
000440  000511  //     : Valid range is "0123456789"
000441  000512        
000442  000513  func isxdigit("char"), 1;    //Returns a 1 if the character is an ascii hexadecimal digit else returns a 0
000443  000514  // Syntax: isxdigit("char");
000444  000515  // Usage : Var := isxdigit(ch);
000445  000516  // Notes : char specifies the ascii character for the test
000446  000517  //     : 0 : char is not an ascii hexadecimal digit.
000447  000518  //     : 1 : char is an ascii hexadecimal digit..
000448  000519  //     : Valid range is "0123456789ABCDEF"
000449  000520        
000450  000521  func isupper("char"), 1;    //Returns a 1 if the character is an ascii upper case letter else returns a 0
000451  000522  // Syntax: isupper("char");
000452  000523  // Usage : Var := isupper(ch);
000453  000524  // Notes : char specifies the ascii character for the test
000454  000525  //     : 0 : char is not an ascii upper-case letter.
000455  000526  //     : 1 : char is an ascii upper-case letter.
000456  000527  //     : Valid range is "ABCD....WXYZ"
000457  000528        
000458  000529  func islower("char"), 1;    //Returns a 1 if the character is an ascii lower case letter else returns a 0
000459  000530  // Syntax: islower("char");
000460  000531  // Usage : Var := islower(ch);
000461  000532  // Notes : char specifies the ascii character for the test
000462  000533  //     : 0 : char is not an ascii lower-case letter.
000463  000534  //     : 1 : char is an ascii lower-case letter.
000464  000535  //     : Valid range is "abcd....wxyz"
000465  000536        
000466  000537  func isalpha("char"), 1;    //Returns a 1 if the character is an ascii lower or upper case letter else returns a 0
000467  000538  // Syntax: isalpha("char");
000468  000539  // Usage : Var := isalpha(ch);
000469  000540  // Notes : char specifies the ascii character for the test
000470  000541  //     : 0 : char is not an ascii lower or upper case letter.
000471  000542  //     : 1 : char is an ascii lower or upper case letter.
000472  000543  //     : Valid range is "ABCD...XYZ", "abcd....wxyz"
000473  000544        
000474  000545  func isalnum("char"), 1;    //Returns a 1 if the character is an ascii alpha numeric else returns a 0
000475  000546  // Syntax: isalnum("char");
000476  000547  // Usage : Var := isalnum(ch);
000477  000548  // Notes : char specifies the ascii character for the test
000478  000549  //     : 0 : char is not an ascii alphanumeric character.
000479  000550  //     : 1 : char is an ascii alphanumeric character.
000480  000551  //     : Valid range is "ABCD...XYZ", "abcd....wxyz", "0123456789"
000481  000552        
000482  000553  func isprint("char"), 1;    //Returns a 1 if the character is a printible ascii char else returns a 0
000483  000554  // Syntax: isprint("char");
000484  000555  // Usage : Var := isprint(ch);
000485  000556  // Notes : char specifies the ascii character for the test
000486  000557  //     : 0 : char is not a printable ascii character.
000487  000558  //     : 1 : char is a printable ascii character.
000488  000559  //     : Valid range is "0x20...0x7F"
000489  000560        
000490  000561  func isspace("char"), 1;    //Returns a 1 if the character is any one of the space type chars else returns a 0
000491  000562  // Syntax: isspace("char");
000492  000563  // Usage : Var := isspace(ch);
000493  000564  // Notes : char specifies the ascii character for the test
000494  000565  //     : 0 : char is not a space type character.
000495  000566  //     : 1 : char is a space type character.
000496  000567  //     : Valid range is space, formfeed, newline, carriage return, tab, vertical tab
000497  000568        
000498  000569  //unformatted
000499  000570  func iswhite("char"), 1;    //
000500  000571  // Syntax: iswhite("char");
000501  000572  // Usage : Var := iswhite(ch);
000502  000573  // Notes : char specifies the ascii character for the test
000503  000574  //     : 0 : char is not a space or tab character.
000504  000575  //     : 1 : char is not a space or tab character.
000505  000576  //     : Valid range is space or tab
000506  000577        
000507  000578  func toupper("char"), 1; //if character is lower case it returns the upper case equivalent else returns the passed char
000508  000579  // Syntax: toupper("char");
000509  000580  // Usage : Var := toupper(ch);
000510  000581  // Notes : char specifies the ascii character for the test
000511  000582  //     : "ABCD....XYZ" : if character is a lower case letter.
000512  000583  //     : char : if character is not a lower case letter.
000513  000584  //     : Valid range is "abcd....wxyz"
000514  000585        
000515  000586  func tolower("char"), 1; //if character is upper case it returns the lower case equivalent else returns the passed char
000516  000587  // Syntax: tolower("char");
000517  000588  // Usage : Var := tolower(ch);
000518  000589  // Notes : char specifies the ascii character for the test
000519  000590  //     : "abcd....xyz" : if character is an upper case letter.
000520  000591  //     : char : if character is not an upper case letter.
000521  000592  //     : Valid range is "ABCD....WXYZ"
000522  000593        
000523  000594  func LObyte("var"), 1;        //Returns the lower byte (lower 8 bits) of a 16 bit variable.
000524  000595  // Syntax: LObyte(var);
000525  000596  // Usage : myVar := LObyte(myvar2);
000526  000597  // Notes : var specifies the user variable
000527  000598  //     : Returns the lower byte (lower 8 bits) of a 16 bit variable
000528  000599        
000529  000600  func HIbyte("var"), 1;        //Returns the High byte (upper 8 bits) of a 16 bit variable.
000530  000601  // Syntax: HIbyte(var);
000531  000602  // Usage : myVar := HIbyte(myvar2);
000532  000603  // Notes : var specifies the user variable
000533  000604  //     : Returns the high byte (upper 8 bits) of a 16 bit variable
000534  000605        
000535  000606        
000536  000607  func ByteSwap("var"), 1;    //Returns the swapped upper and lower bytes of a 16 bit variable.
000537  000608  // Syntax: ByteSwap(var);
000538  000609  // Usage : myVar := ByteSwap(myvar2);
000539  000610  // Notes : var specifies the user variable
000540  000611  //     : Returns the endian swapped value of a 16 bit variable
000541  000612        
000542  000613        
000543  000614  func NybleSwap("var"), 1;    //Returns the swapped lower bytes nybles, upper byte retained.
000544  000615  // Syntax: NybleSwap(var);
000545  000616  // Usage : myVar := NybleSwap(myvar2);
000546  000617  // Notes : var specifies the user variable
000547  000618  //     : Returns the 16 bit variable with swapped lower nybles
000548  000619        
000549  000620  func __reserved1(), 0; // do not remove
000550  000621  func __reserved2(), 0; // do not remove
000551  000622        
000552  000623  //------------------------------------------------------------------//
000553  000624  // 16bit signed Math Functions                                      //
000554  000625  //------------------------------------------------------------------//
000555  000626                                                  //
000556  000627  func ABS("value"), 1;                           // return a positive number
000557  000628  // Syntax: ABS(value);
000558  000629  // Usage : var := ABS(arg);
000559  000630  // Notes : Returns the absolute value of an argument
000560  000631        
000561  000632  func MIN("value1", "value2"), 1;                // return the smaller of 2 numbers
000562  000633  // Syntax: MIN(value1, value2);
000563  000634  // Usage : var := MIN(arg1, arg2);
000564  000635  // Notes : Returns the minimum of 2 arguments
000565  000636        
000566  000637  func MAX("value1", "value2"), 1;                // return the larger of 2 numbers
000567  000638  // Syntax: MAX(value1, value2);
000568  000639  // Usage : var := MAX(arg1, arg2);
000569  000640  // Notes : Returns the maximum of 2 arguments
000570  000641        
000571  000642  func SWAP("&var", "&var"), 0;                   // swap 2 variables, arguments must point to variables
000572  000643  // Syntax: SWAP(&var1, &var2);
000573  000644  // Usage : SWAP(&var1, &var2);
000574  000645  // Notes : Swaps the contents of 2 variables or memory locations
000575  000646        
000576  000647  func SIN("angle"), 1;                           // return SIN of angle
000577  000648  // Syntax: SIN(angle);
000578  000649  // Usage : var := SIN(arg);
000579  000650  // Notes : Returns the sine in radians of an argument in degrees
000580  000651  //       : the returned value range is from 127 to -127. The real
000581  000652  //       : cosine values vary from 1.0 to -1.0 so appropriate
000582  000653  //       : scaling must be done in user code.
000583  000654        
000584  000655  func COS("angle"), 1;                           // return COS of angle
000585  000656  // Syntax: COS(angle);
000586  000657  // Usage : var := COS(arg);
000587  000658  // Notes : Returns the cosine in radians of an argument in degrees
000588  000659  //       : the returned value range is from 127 to -127. The real
000589  000660  //       : cosine values vary from 1.0 to -1.0 so appropriate
000590  000661  //       : scaling must be done in user code.
000591  000662        
000592  000663  func RAND(), 1;                                 // return a pseudo random number
000593  000664  // Syntax: RAND();
000594  000665  // Usage : var := RAND();
000595  000666  // Notes : Returns a random number between 0 and 0xFFFF.
000596  000667  //       : The random number generator must first be seeded
000597  000668  //       : by using the SEED(number) function.
000598  000669        
000599  000670  func RANDVAL("low", "high"), 1;                 // return a ranged pseudo random number
000600  000671  // Syntax: RANDVAL("low", "high");
000601  000672  // Usage : var := RANDVAL(low, high);
000602  000673  // Notes : Returns a random number between low and high limits
000603  000674  //       : such that low <= N < high
000604  000675  //       : The random number generator may first be seeded
000605  000676  //       : by using the SEED(number) function.
000606  000677  //       : RANDVAL is the equivalent of aggregate functions:-
000607  000678  //       :     myvar = ABS( (RAND()%(high-low)+low) );
000608  000679  //       : Note that the lower limit is inclusive, but the upper limit is exclusive.
000609  000680        
000610  000681  func SEED("number"), 0;                         // re-seed the pseudo random number generator
000611  000682  // Syntax: SEED(number);
000612  000683  // Usage : SEED(arg);
000613  000684  // Notes : Seeds the random number generator.
000614  000685        
000615  000686  func SQRT("number"), 1;                         // return square root of a number
000616  000687  // Syntax: SQRT(number);
000617  000688  // Usage : SQRT(arg);
000618  000689  // Notes : Returns the integer square root of a number.
000619  000690        
000620  000691  func OVF(), 1;                                  // returns upper 16bits of 32bit results
000621  000692  // Syntax: OVF();
000622  000693  // Usage : loWord := 0x2710 * 0x2710;           // (10000 * 10000 in hex format)
000623  000694  //       : hiWord := OVF();
000624  000695  // Notes : This function returns the high order 16 bits from certain math and shift functions..
000625  000696        
000626  000697  func CY(), 1;
000627  000698  // Syntax: CY();
000628  000699  // Usage : myvar := 0xFFF8 + 9;                 // result = 1
000629  000700  //       : print(myvar," "CY(),"\n");           // carry = 1
000630  000701  // Notes : This function returns the carry status of an
000631  000702  // unsigned overflow from any 16 or 32bit additions or sutractions.
000632  000703        
000633  000704  func EVE_SP(), 1;
000634  000705  // Syntax: EVE_SP();
000635  000706  // Usage : eg:  print(EVE_SP());
000636  000707  // Notes : Used for debugging to assess the current stack level,
000637  000708  //       : mainly for checking stack leaks, see example EVE_SP.4dg
000638  000709        
000639  000710  func EVE_SSIZE(), 1;
000640  000711  // Syntax: EVE_SSIZE();
000641  000712  // Usage : eg:  print(EVE_SSIZE());
000642  000713  // Notes : Used to get the stack size,
000643  000714  //       : mainly for debugging purposes, EVE_SP.4dg
000644  000715        
000645  000716        
000646  000717  //------------------------------------------------------------------//
000647  000718  //
000648  000719  //------------------------------------------------------------------//
000649  000720  func mem_ArrayOp1("memarray", "count", "op", "value"), 0;                     // single array functions
000650  000721        
000651  000722        
000652  000723  // single word array operations
000653  000724  #CONST
000654  000745  #END
000655  000746        
000656  000747        
000657  000748  func mem_ArrayOp2("memarray1", "memarray2", "count", "op", "value"), 0;         // dual array functions
000658  000749        
000659  000750  // dual word array operations
000660  000751  #CONST
000661  000763  #END
000662  000764        
000663  000765        
000664  000766  func __reserved3(), 0; // do not remove
000665  000767  func __reserved4(), 0; // do not remove
000666  000768        
000667  000769        
000668  000770  //------------------------------------------------------------------//
000669  000771  // unsigned long (32 bit) operations                                //
000670  000772  //------------------------------------------------------------------//
000671  000773        
000672  000774  func uadd_3232("res32", "val1", "val2"), 1;
000673  000775  // Syntax   : cmp_3232(res32, varA, varB);
000674  000776  // Input    : DWORD res32 points to optional result (or zero for compare)
000675  000777  //          : DWORD val1 points to 32bit augend
000676  000778  //          : DWORD val2 points to 32bit addend
000677  000779  // Usage    : var res32[2];
000678  000780  //          : res := cmp_3232(res32, val1, val2);
000679  000781  // Notes    : performs an unsigned addition of 2 x 32bit values
000680  000782  //          : placing the 32bit result in a 2 word array.
000681  000783  // Returns  : returns 1 on 32bit unsigned overflow (carry).
000682  000784  //          ; carry flag is also set on 32bit unsigned overflow
000683  000785  //          ; and can be read with the CY() function.
000684  000786        
000685  000787        
000686  000788  func usub_3232("res32", "val1", "val2"), 1;
000687  000789  // Syntax   : cmp_3232(res32, varA, varB);
000688  000790  // Input    : DWORD res32 points to optional result (or zero for compare)
000689  000791  //          : DWORD val1 points to first 32bit minuend
000690  000792  //          : DWORD val2 points to 32bit subtrahend
000691  000793  // Usage    : var res32[2];
000692  000794  //          : res := cmp_3232(res32, val1, val2);
000693  000795  // Notes    : performs an unsigned subtraction of 2 x 32bit values
000694  000796  //          : placing the 32bit result in a 2 word array.
000695  000797  // Returns  : returns 1 on 32bit unsigned overflow (borrow).
000696  000798  //          ; carry flag is also set on 32bit unsigned underflow
000697  000799  //          ; and can be read with the CY() function.
000698  000800        
000699  000801        
000700  000802  func umul_1616("&res32", "val1", "val2"), 1;
000701  000803  // Syntax   : umul_1616(&res32, varA, varB);
000702  000804  // Input    : DWORD result   points to 32bit result register.
000703  000805  //          : VAR   val1  16bit register or constant
000704  000806  //          : VAR   val2  16bit register or constant
000705  000807  // Usage    : var res32[2];
000706  000808  //          : umul_1616(&res32, myvar, 50000);
000707  000809  // Notes    : performs an unsigned multiply of 2 x 16bit values
000708  000810  //          : placing the 32bit result in a 2 word array.
000709  000811  // Returns  : the pointer to the 32bit result.
000710  000812  //          : carry and overflow are not affected.
000711  000813        
000712  000814        
000713  000815  func udiv_3232("res32", "val1", "val2"), 1;
000714  000816  // Syntax   : udiv_1616(res32, varA, varB);
000715  000817  // Input    : DWORD *result   points to 32bit result register.
000716  000818  //          : DWORD   val1  pointer to 32bit value (dividend)
000717  000819  //          : DWORD   val2  pointer to 32bit value (divisor)
000718  000820  // Usage    : var res32[2];
000719  000821  //          : umul_1616(res32, myvar, 50000);
000720  000822  // Notes    : performs an unsigned division of 2 x 32bit values
000721  000823  //          : placing the 32bit result in a 2 word array.
000722  000824  // Returns  : the pointer to the 32bit result.
000723  000825  //          : carry and overflow are not affected.
000724  000826        
000725  000827        
000726  000828  func ucmp_3232("val1", "val2"), 1;
000727  000829  // Syntax   : cmp_3232(varA, varB);
000728  000830  // Input    : DWORD val1 points to 32bit minuend
000729  000831  //          : DWORD val2 points to 32bit sutrahend
000730  000832  // Usage    : res := cmp_3232(val1, val2);
000731  000833  // Notes    : performs an unsigned comparison of 2 x 32bit values.
000732  000834  //          : The result of the subtraction is returned.
000733  000835  // Returns  : 0  if equal
000734  000836  //          : 1  if val1 > val2
000735  000837  //          : -1 if val1 < val2
000736  000838  //          : This function does not affect the carry flag.
000737  000839        
000738  000840  func __reserved5(), 0; // do not remove
000739  000841  func __reserved6(), 0; // do not remove
000740  000842        
000741  000843  //------------------------------------------------------------------//
000742  000844  // Floating point operations                                        //
000743  000845  // Note that source arguments may be a pointer to a float variable, //
000744  000846  // or a numeric text string.                                        //
000745  000847  // A string argument is converted at run-time by calling            //
000746  000848  // flt_Val for a string argument.                                   //
000747  000849  // Note that a float variable is a 2 word array, eg var myfloat[2]; //
000748  000850  //------------------------------------------------------------------//
000749  000851  func flt_VAL("fresult", "numstring"), 1;
000750  000852  // Syntax   : flt_VAL(float1, mystring);
000751  000853  // Input    : FLOAT  fresult  points to float result register
000752  000854  //          : numstring       a string constant or string variable
000753  000855  //          : that is holds valid floating point number.
000754  000856  // Usage    : var float1[2];
000755  000857  //          : flt_VAL(float1, "1.0594631");
000756  000858  // Notes    : The string argument can be a string constant, a pointer
000757  000859  //          : to a string variable, or a pointer to a data statement.
000758  000860  //          : The string may be a float, or a hex or binary integer value (no decimal point allowed).
000759  000861  //          : For hex or binary, the number is preceeded with 0x or 0b
000760  000862  // Returns  : the pointer to the float result.
000761  000863  //          : carry and overflow are not affected.
000762  000864        
000763  000865        
000764  000866  func flt_ITOF("fresult", "var16"), 1;
000765  000867  // Syntax   : flt_ITOF(resf, intval);
000766  000868  // Input    : FLOAT  fresult  points to float result register
000767  000869  //          : var16           a 16bit signed integer variable or string constant
000768  000870  // Usage    : var float1[2];
000769  000871  //          : var myvar := 30000;
000770  000872  //          : flt_VAL(float1, myvar);
000771  000873  // Notes    : Converts a 16bit signed integer value to a signed floating point number.
000772  000874  // Returns  : the pointer to the float result.
000773  000875        
000774  000876        
000775  000877  func flt_UITOF("fresult", "uvar16"), 1;
000776  000878  // Syntax   : flt_ITOF(resf, intval);
000777  000879  // Input    : FLOAT  fresult  points to float result register
000778  000880  //          : var16           a 16bit integer variable or constant (treated as unsigned)
000779  000881  // Usage    : var float1[2];
000780  000882  //          : var myuvar := 30000;
000781  000883  //          : flt_UITOF(float1, myuvar);
000782  000884  // Notes    : Converts a 16bit unsigned integer value to a positive floating point number.
000783  000885  // Returns  : the pointer to the float result.
000784  000886        
000785  000887  func flt_LTOF("fresult", "var32"), 1;
000786  000888  // Syntax   : flt_LTOF(resf, var32);
000787  000889  // Input    : FLOAT  fresult  points to float result register
000788  000890  //          : var32           points to a 32bit (long) signed variable or string constant
000789  000891  // Usage    : var float1[2];
000790  000892  //          : var mylong[2];
000791  000893  //          : flt_VAL(float1, mylong);
000792  000894  // Notes    : Converts a 32bit signed integer value to a signed floating point number.
000793  000895  // Returns  : the pointer to the float result.
000794  000896        
000795  000897        
000796  000898  func flt_ULTOF("fresult", "uvar32"), 1;
000797  000899  // Syntax   : flt_ITOF(resf, uvar32);
000798  000900  // Input    : FLOAT  fresult  points to float result register
000799  000901  //          : var32           points to a 32bit (unsigned long) unsigned variable or string constant
000800  000902  // Usage    : var float1[2];
000801  000903  //          : var myulong[2];
000802  000904  //          : flt_VAL(float1, myulong);
000803  000905  // Notes    : Converts a 32bit unsigned integer value to a positive floating point number.
000804  000906  // Returns  : the pointer to the float result.
000805  000907        
000806  000908        
000807  000909  func flt_PRINT("fvalue", "formatstring"), 1;
000808  000910  // Syntax   : flt_PRINT(resf, formatstr);
000809  000911  // Input    : FLOAT  fresult  points to float result register
000810  000912  //          : formatstring    zero, null string, of valid format string
000811  000913  // Usage    : var float1[2];
000812  000914  //          : flt_PRINT(float1, "");
000813  000915  // Notes    : The string argument can be a string constant, a pointer
000814  000916  //          : to a string variable, or a pointer to a data statement.
000815  000917  //          : If it is zero or an empty string, the number is
000816  000918  //          : automatically formatted for the best presentation.
000817  000919  //          : The format string is similar to the C language, but only
000818  000920  //          : a single '%' may be used to print a single variable.
000819  000921  // Returns  : zero if success.
000820  000922        
000821  000923        
000822  000924  func flt_ABS("result", "floatval"), 1;
000823  000925  // Syntax   : flt_ABS(&result, &fval);
000824  000926  // Input    : FLOAT  result   points to float result register
000825  000927  //          : numstring       a string that is a valid number
000826  000928  // Usage    : var float1[2];
000827  000929  //          : flt_VAL(float1, float1); // convert float1 to its ABS value
000828  000930  // Returns  : the pointer to the float result.
000829  000931  //          : carry and overflow are not affected.
000830  000932        
000831  000933        
000832  000934  func flt_ACOS("result", "floatval"), 1;
000833  000935  // Syntax   : flt_ACOS(result, fval);
000834  000936  // Input    : FLOAT  result (in radians) points to float result register
000835  000937  //          : FLOAT  floatval points to the float value to get arccos of
000836  000938  // Usage    : var float1[2];
000837  000939  //          : flt_ACOS(result, float1); // get the arccos of float1
000838  000940  // Notes    : the result is in radians.
000839  000941  // Returns  : the pointer to the float result.
000840  000942  //          : carry and overflow are not affected.
000841  000943        
000842  000944        
000843  000945  func flt_ASIN("result", "floatval"), 1;
000844  000946  // Syntax   : flt_ASIN(result, fval);
000845  000947  // Input    : FLOAT  result (in radians) points to float result register
000846  000948  //          : FLOAT  floatval points to the float value to get arcsin of
000847  000949  // Usage    : var float1[2];
000848  000950  //          : flt_ASIN(result, float1); // get the Arcsin of float1
000849  000951  // Notes    : the result is in radians.
000850  000952  // Returns  : the pointer to the float result.
000851  000953  //          : carry and overflow are not affected.
000852  000954        
000853  000955        
000854  000956  func flt_ATAN("result", "floatval"), 1;
000855  000957  // Syntax   : flt_ATAN(result, fval);
000856  000958  // Input    : FLOAT  result (in radians) points to float result register
000857  000959  //          : FLOAT  floatval points to the float value to get arctan of
000858  000960  // Usage    : var float1[2];
000859  000961  //          : flt_ATAN(result, float1); // get the Arctan of float1
000860  000962  // Notes    : the result is in radians.
000861  000963  // Returns  : the pointer to the float result.
000862  000964  //          : carry and overflow are not affected.
000863  000965        
000864  000966        
000865  000967  func flt_COS("result", "floatval"), 1;
000866  000968  // Syntax   : flt_COS(result, fval);
000867  000969  // Input    : FLOAT  result   points to float result register
000868  000970  //          : FLOAT  floatval (in radians) points to the float value to get Cos of
000869  000971  // Usage    : var float1[2];
000870  000972  //          : flt_COS(result, float1); // get the Cosine of float1
000871  000973  // Notes    : the result is in radians.
000872  000974  // Returns  : the pointer to the float result.
000873  000975  //          : carry and overflow are not affected.
000874  000976        
000875  000977        
000876  000978  func flt_EXP("result", "floatval"), 1;
000877  000979  // Syntax   : flt_EXP(result, fval);
000878  000980  // Input    : FLOAT  result   points to float result register
000879  000981  //          : FLOAT  floatval points to the float value to get Exponent of
000880  000982  // Usage    : var float1[2];
000881  000983  //          : flt_EXP(result, float1); // get the Exponent of float1
000882  000984  // Returns  : the pointer to the float result.
000883  000985  //          : carry and overflow are not affected.
000884  000986        
000885  000987        
000886  000988  func flt_CEIL("result", "floatval"), 1;
000887  000989  // Syntax   : flt_CEIL(result, floatval);
000888  000990  // Input    : FLOAT  floatval points to the float value to integerize up
000889  000991  // Usage    : var float1[2];
000890  000992  //          : n := flt_INT(float1, float1); // round value up to the integer value
000891  000993  // Notes    : Removes fractional part, rounding up correctly.
000892  000994  // Returns  : the pointer to the float result.
000893  000995  //          : carry and overflow are not affected.
000894  000996        
000895  000997        
000896  000998  func flt_FLOOR("result", "floatval"), 1;
000897  000999  // Syntax   : flt_FLOOR(result, floatval);
000898  001000  // Input    : FLOAT  floatval points to the float value to integerize down
000899  001001  // Usage    : var float1[2];
000900  001002  //          : n := flt_INT(float1, float1); // round value down to the integer value
000901  001003  // Notes    : Removes fractional part, rounding down correctly.
000902  001004  // Returns  : the pointer to the float result.
000903  001005  //          : carry and overflow are not affected.
000904  001006        
000905  001007        
000906  001008  func flt_SIN("result", "floatval"), 1;
000907  001009  // Syntax   : flt_SIN(result, fval);
000908  001010  // Input    : FLOAT  result   points to float result register
000909  001011  //          : FLOAT  floatval (in radians) points to the float value to get Sine of
000910  001012  // Usage    : var float1[2];
000911  001013  //          : flt_SIN(result, float1); // get the Sin of float1
000912  001014  // Notes    : the result is in radians.
000913  001015  // Returns  : the pointer to the float result.
000914  001016  //          : carry and overflow are not affected.
000915  001017        
000916  001018        
000917  001019  func flt_LOG("result", "floatval"), 1;
000918  001020  // Syntax   : flt_LOG(&result, &fval);
000919  001021  // Input    : FLOAT  result   points to float result register
000920  001022  //          : FLOAT  floatval points to the float value to get Log of
000921  001023  // Usage    : var float1[2];
000922  001024  //          : flt_LOG(result, float1); // get the natural Log of float1
000923  001025  // Returns  : the pointer to the float result.
000924  001026  //          : carry and overflow are not affected.
000925  001027        
000926  001028        
000927  001029  func flt_SQR("result", "floatval"), 1;
000928  001030  // Syntax   : flt_SQR(result, fval);
000929  001031  // Input    : FLOAT  result   points to float result register
000930  001032  //          : FLOAT  floatval points to the float value to get Log of
000931  001033  // Usage    : var float1[2];
000932  001034  //          : flt_SQR(result, float1); // get the square root of float1
000933  001035  // Returns  : the pointer to the float result, or zero if number was negative.
000934  001036  //          : carry and overflow are not affected.
000935  001037        
000936  001038        
000937  001039  func flt_TAN("result", "floatval"), 1;
000938  001040  // Syntax   : flt_TAN(result, fval);
000939  001041  // Input    : FLOAT  result   points to float result register
000940  001042  //          : FLOAT  floatval (in radians) points to the float value to get Tangent of
000941  001043  // Usage    : var float1[2];
000942  001044  //          : flt_TAN(result, float1); // get the Tangent of float1
000943  001045  // Returns  : the pointer to the float result.
000944  001046  //          : carry and overflow are not affected.
000945  001047        
000946  001048        
000947  001049  func flt_POW("result", "floatx", "floaty"), 1;
000948  001050  // Syntax   : flt_POW(result, fval1, fval2);
000949  001051  // Input    : FLOAT  result   points to float result register
000950  001052  //          : FLOAT  floatx   points to the float value to raise
000951  001053  //          : FLOAT  floaty   points to the float value for power
000952  001054  // Usage    : flt_POW(result, floatx, floaty); // raise x to power y
000953  001055  // Returns  : the pointer to the float result, or zero if error occurs.
000954  001056  //          : carry and overflow are not affected.
000955  001057        
000956  001058        
000957  001059  func flt_ADD("result", "floatA", "floatB"), 1;
000958  001060  // Syntax   : flt_ADD(result, floatA, floatB);
000959  001061  // Input    : FLOAT  result   points to float result register
000960  001062  //          : FLOAT  floatval points to the float value A
000961  001063  //          : FLOAT  floatval points to the float value B
000962  001064  // Usage    : flt_ADD(result, floatx, floaty); // add B to A
000963  001065  // Returns  : the pointer to the float result, or zero if error occurs.
000964  001066  //          : carry and overflow are not affected.
000965  001067        
000966  001068        
000967  001069  func flt_SUB("&result", "&floatA", "&floatB"), 1;
000968  001070  // Syntax   : flt_SUB(result, floatA, floatB);
000969  001071  // Input    : FLOAT  result   points to float result register
000970  001072  //          : FLOAT  floatval points to the float value A
000971  001073  //          : FLOAT  floatval points to the float value B
000972  001074  // Usage    : flt_SUB(&result, &floatx, &floaty); // subtract B from A
000973  001075  // Returns  : the pointer to the float result, or zero if error occurs.
000974  001076  //          : carry and overflow are not affected.
000975  001077        
000976  001078        
000977  001079  func flt_MUL("result", "floatA", "floatB"), 1;
000978  001080  // Syntax   : flt_MUL(result, floatA, floatB);
000979  001081  // Input    : FLOAT  result   points to float result register
000980  001082  //          : FLOAT  floatval points to the float value A
000981  001083  //          : FLOAT  floatval points to the float value B
000982  001084  // Usage    : flt_MUL(result, floatA, floatB); // multiply A by B
000983  001085  // Returns  : the pointer to the float result, or zero if error occurs.
000984  001086  //          : carry and overflow are not affected.
000985  001087        
000986  001088        
000987  001089  func flt_DIV("result", "floatA", "floatB"), 1;
000988  001090  // Syntax   : flt_DIV(result, floatA, floatB);
000989  001091  // Input    : FLOAT  result   points to float result register
000990  001092  //          : FLOAT  floatval points to the float value A
000991  001093  //          : FLOAT  floatval points to the float value B
000992  001094  // Usage    : flt_DIV(result, floatA, floatB); // divide A by B
000993  001095  // Returns  : the pointer to the float result, or zero if error occurs.
000994  001096  //          : carry and overflow are not affected.
000995  001097        
000996  001098        
000997  001099  //------------------------------------------------------------------//
000998  001100  // The following float functions all return integer values.
000999  001101  //------------------------------------------------------------------//
001000  001102  func flt_EQ("floatA", "floatB"), 1;
001001  001103  // Syntax   : flt_EQ(floatA, floatB);
001002  001104  // Input    : FLOAT  floatval points to the float value A
001003  001105  //          : FLOAT  floatval points to the float value B
001004  001106  // Usage    : if (flt_EQ(floatA, floatB)) // compare A to B, true if A == B
001005  001107  // Returns  : True if numbers are equal, false otherwise.
001006  001108        
001007  001109        
001008  001110  func flt_NE("floatA", "floatB"), 1;
001009  001111  // Syntax   : flt_NE(floatA, floatB);
001010  001112  // Input    : FLOAT  floatval points to the float value A
001011  001113  //          : FLOAT  floatval points to the float value B
001012  001114  // Usage    : if (flt_NE(floatA, floatB)) // compare A to B, true if A != B
001013  001115  // Returns  : True if numbers are not equal, false otherwise.
001014  001116        
001015  001117        
001016  001118        
001017  001119  func flt_GT("floatA", "floatB"), 1;
001018  001120  // Syntax   : flt_GT(floatA, floatB);
001019  001121  // Input    : FLOAT  floatval points to the float value A
001020  001122  //          : FLOAT  floatval points to the float value B
001021  001123  // Usage    : if (flt_GT(floatA, floatB)) // compare A to B, true if A > B
001022  001124  // Returns  : True if A > B, false otherwise.
001023  001125        
001024  001126        
001025  001127  func flt_GE("floatA", "floatB"), 1;
001026  001128  // Syntax   : flt_GE(floatA, floatB);
001027  001129  // Input    : FLOAT  floatval points to the float value A
001028  001130  //          : FLOAT  floatval points to the float value B
001029  001131  // Usage    : if (flt_GE(floatA, floatB)) // compare A to B, true if A >= B
001030  001132  // Returns  : True if A >= B, false otherwise.
001031  001133        
001032  001134        
001033  001135  func flt_LT("floatA", "floatB"), 1;
001034  001136  // Syntax   : flt_LT(floatA, floatB);
001035  001137  // Input    : FLOAT  floatval points to the float value A
001036  001138  //          : FLOAT  floatval points to the float value B
001037  001139  // Usage    : if (flt_LT(floatA, floatB)) // compare A to B, true if A < B
001038  001140  // Returns  : True if A < B, false otherwise.
001039  001141        
001040  001142        
001041  001143  func flt_LE("floatA", "floatB"), 1;
001042  001144  // Syntax   : flt_LE(floatA, floatB);
001043  001145  // Input    : FLOAT  floatval points to the float value A
001044  001146  //          : FLOAT  floatval points to the float value B
001045  001147  // Usage    : if (flt_LE(floatA, floatB )) // compare A to B, true if A <= B
001046  001148  // Returns  : True if A <= B, false otherwise.
001047  001149        
001048  001150        
001049  001151  func flt_SGN("floatval"), 1;
001050  001152  // Syntax   : flt_SGN(fval);
001051  001153  // Input    : FLOAT  floatval   points to the float value examine sign
001052  001154  // Usage    : var float1[2];
001053  001155  //          : n := flt_SGN(float1); // return -1 if float number negative
001054  001156  // Notes    : returns 0 if sign is positive or zero.
001055  001157  // Returns  : returns 16bit integer -1 if float sign is negative, or zero if positive.
001056  001158  //          : carry and overflow are not affected.
001057  001159        
001058  001160        
001059  001161  func flt_FTOI("floatvar"), 1;
001060  001162  // Syntax   : flt_FTOI(myfloat);
001061  001163  // Input    : FLOAT  fresult  points to float result register
001062  001164  // Usage    : var float1[2];
001063  001165  //          : myvar := flt_VAL(&float1, myvar);
001064  001166  // Notes    : Converts a floating point number to a 16bit integer.
001065  001167  //          : The floating point number is rounded up or down accordingly.
001066  001168  // Returns  : the integer value of the float.
001067  001169        
001068  001170  func __reserved8(), 0; // do not remove
001069  001171  func __reserved9(), 0; // do not remove
001070  001172  func __reserved10(), 0; // do not remove
001071  001173        
001072  001174  //------------------------------------------------------------------//
001073  001175  //------------------------------------------------------------------//
001074  001176  //------------------------------------------------------------------//
001075  001177  //------------------------------------------------------------------//
001076  001178  //------------------------------------------------------------------//
001077  001179  func pin_Set("mode", "pin"), 1;            // set pin to required mode
001078  001180  // Syntax: pin_Set(mode, pin);
001079  001181  // Usage : pin_Set(PIN_OUT,);
001080  001182  // Notes : Sets the selected pin to the desired mode. Refer to the manual
001081  001183  //       : for pin function compatitblilites.
001082  001184  //       : returns true if the pin number and mode is legal (usually ignored)
001083  001185  //       :    available pin modes
001084  001186  //       :    PIN_INP                 0        // pin is input, no pullup or pulldown
001085  001187  //       :    PIN_INP_HI              1        // pin is input with pullup to Vcc
001086  001188  //       :    PIN_INP_LO              2        // pin is input with pulldown to Gnd
001087  001189  //       :    PIN_OUT                 3        // pin is output
001088  001190  //       :    PIN_OUT_OD              4        // pin is output with open drain
001089  001191  //       :    PIN_AN                  5        // pin is analogue (PA0 to PA3 only)
001090  001192  //       :    PIN_ANAVG               6        // pin is analogue (PA0 to PA3 only), averaged - 16 samples
001091  001193  //       :
001092  001194        
001093  001195  func pin_HI("pin"), 1;                    // set pin to logic '1'
001094  001196  // Syntax: pin_HI(pin);
001095  001197  // Usage : pin_HI(PA4);        // make PA4 HI level
001096  001198  // Notes : Outputs a logic "High" to the pin latch
001097  001199  //       : The pin is automatically made an output.
001098  001200  //       : pullup, pulldown, and change notification will be disable for the selected pin.
001099  001201  //       : returns true if the pin number is legal (usually ignored)
001100  001202  //       :
001101  001203        
001102  001204  func pin_LO("pin"), 1;                    // set pin to logic '0'
001103  001205  // Syntax: pin_LO(pin);
001104  001206  // Usage : pin_LO(PA3);
001105  001207  // Notes : Outputs a logic "Low" to the pin latch
001106  001208  //       : The pin is automatically made an output.
001107  001209  //       : pullup, pulldown, and change notification will be disable for the selected pins.
001108  001210  //       : returns true if the pin number is legal (usually ignored)
001109  001211  //       :
001110  001212        
001111  001213  func pin_Val("pin", "value"), 0;                    // set pin to to state of variable
001112  001214  // Syntax: pin_Var(pin, value);
001113  001215  // Usage : pin_Var(IO3, myvar);
001114  001216  // Notes : Outputs a logic state on a pin depending on the value of bit 0 of a variable
001115  001217  //       : The pin is automatically made an output.
001116  001218  //       : pullup, pulldown, and change notification will be disable for the selected pins.
001117  001219  //       : returns true if the pin number is legal (usually ignored)
001118  001220        
001119  001221  func pin_Read("pin"), 1;                // read pin, logic or analogue
001120  001222  // Syntax: pin_Read(PA0);
001121  001223  // Usage : arg1 := pin_Read(arg2);
001122  001224  // Notes : Read a pin in various ways. If the pin is
001123  001225  //       : set to an input, read the state of the input pin.
001124  001226  //       : If set to an output, read the state of the output latch.
001125  001227  //       : If set to analogue, read the 12 bit analogue value.
001126  001228        
001127  001229  func bus_Read(), 1;
001128  001230  // Syntax: bus_Read();
001129  001231  // Usage : arg1 := pin_ReadBus();
001130  001232  // Notes : Read the 16 bit port regardless of pin configurations.
001131  001233  //       : If a pin is configured as input or analogue, the pin is read directly as
001132  001234  //       : if it were a digital input. If a pin is configured as an output, the pin
001133  001235  //       : is also read directly, giving the output latch state.
001134  001236  //       : Bit 0 coresponds to PA0 through to bit15 which coresponds to PA15
001135  001237  //       : (Refer to 'port bit position masks')
001136  001238  //Returns: Returns the 16 bit value of the bus.
001137  001239        
001138  001240  func bus_SetPins("value"), 0;
001139  001241  // Syntax: bus_SetPins(value);
001140  001242  // Usage : arg1 := bus_SetPins(15); // set PA0 to PA3 to output bits, making them HI
001141  001243  // Notes : Any '1' bits in "value" set the coresponding port pin to an output
001142  001244  //       : and forces its state to a '1'. The state of its previous open drain
001143  001245  //       : configuration is not altered. Any zero bits in "value" will not affect the pin.
001144  001246  //       : pullup, pulldown, and change notification will be disable for the selected pins.
001145  001247  //       : Bit 0 coresponds to PA0 through to bit13 which coresponds to PA13
001146  001248        
001147  001249  func bus_ClearPins("value"), 0;
001148  001250  // Syntax: bus_ClearPins(value);
001149  001251  // Usage : bus_ClearPins(0x03F0); // set PA0 to PA5 to output bits, making them LO
001150  001252  // Notes : Any '1' bits in "value" set the coresponding port pin to an output
001151  001253  //       : and forces its state to a '0. The state of its previous open drain
001152  001254  //       : configuration is not altered. Any zero bits in "value" will not affect the pin.
001153  001255  //       : pullup, pulldown, and change notification will be disable for the selected pins.
001154  001256  //       : Bit 0 coresponds to PA0 through to bit13 which coresponds to PA13
001155  001257        
001156  001258  func bus_SetChangeInterrupt("function", "portmask"), 1;
001157  001259  // Syntax: bus_SetChangeInterrupt(value);
001158  001260  // Usage : bus_SetChangeInterrupt(scanKeypad, 0x00F0); // set PA4 to PA7 to interrupt on change
001159  001261  // Notes : Any '1' bits in "portmask" marks that pin to generate an interrupt on change.
001160  001262  //       : A level change on that pin will cause "function" to be executed. If "function" is
001161  001263  //       : zero, the display may be put into sleep mode, and any change will cause a wakeup reset.
001162  001264  //       : Wakeup will always re-start code running in FLASHBANK_0
001163  001265  //       : Bit 0 coresponds to PA0 through to bit15 which coresponds to PA15
001164  001266  //       : (Refer to 'port bit position masks')
001165  001267  //       : Once armed, "function" will only be executed once, it is necessary to
001166  001268  //       : re-arm for any further events.
001167  001269  //Returns: Return the current state of the pins that are selected in "portmask"
001168  001270  //       : This can be saved and later used in "function" to see which pin(s) actually changed.
001169  001271        
001170  001272  func bus_Write8("var"), 0;
001171  001273  // Syntax: bus_Write8(var);
001172  001274  // Usage : bus_Write8(arg1);
001173  001275  // Notes : The lower 8 bits of arg1 are placed on the BUS, then, after
001174  001276  //       : a settling delay of approx 50nsec, the BUS_WR(PA2) pin is strobed
001175  001277  //       : LO for approx 50nsec then set back HI.
001176  001278  //       : The upper 8 bits of arg1 are ignored.
001177  001279  //       : NB:- the BUS_WR(PA2) pin must be preset to the desired output state
001178  001280  //       : as must the bus pins to ensure BUS write integrity.
001179  001281  //       :
001180  001282  //       : BUS_0 is PA4
001181  001283  //       : BUS_1 is PA5
001182  001284  //       : BUS_2 is PA6
001183  001285  //       : BUS_3 is PA7
001184  001286  //       : BUS_4 is PA8
001185  001287  //       : BUS_5 is PA9
001186  001288  //       : BUS_6 is PA10
001187  001289  //       : BUS_7 is PA11
001188  001290        
001189  001291  func bus_Read8(), 1;
001190  001292  // Syntax: bus_Read();
001191  001293  // Usage : arg1 := bus_Read8();
001192  001294  // Notes : The BUS_RD(PA3) pin set to LO, then, after a settling delay
001193  001295  //       : of approx 50nsec, the BUS is read into the lower 8 bits of arg
001194  001296  //       : (the upper 8 bits being set to 0)
001195  001297  //       : the BUS_RD(PA3) pin is then set back to a HI level.
001196  001298  //       : NB:- the BUS_RD(PA3) pin must be preset to the desired output state
001197  001299  //       : as must the bus pins to ensure BUS read integrity.
001198  001300  //       :
001199  001301  //       : BUS_0 is PA4
001200  001302  //       : BUS_1 is PA5
001201  001303  //       : BUS_2 is PA6
001202  001304  //       : BUS_3 is PA7
001203  001305  //       : BUS_4 is PA8
001204  001306  //       : BUS_5 is PA9
001205  001307  //       : BUS_6 is PA10
001206  001308  //       : BUS_7 is PA11
001207  001309        
001208  001310  func __reserved13(), 0; // do not remove
001209  001311  func __reserved14(), 0; // do not remove
001210  001312  //------------------------------------------------------------------//
001211  001313  // Pin related constants                                            //
001212  001314  //------------------------------------------------------------------//
001213  001315        
001214  001316  // pin_Set(...) pin modes
001215  001317  #CONST
001216  001325  #END
001217  001326        
001218  001327        
001219  001328  // pin name             constant    connector H1 I/O Pin referencesnumbers
001220  001329  #CONST
001221  001349  #END
001222  001350        
001223  001351  // bit position masks
001224  001352  #CONST
001225  001369  #END
001226  001370        
001227  001371        
001228  001372        
001229  001373  //------------------------------------------------------------------//
001230  001374  //   Graphics Functions
001231  001375  //------------------------------------------------------------------//
001232  001376  func gfx_Set("mode", "value"), 0;            // set various graphics functions
001233  001377  // Syntax: gfx_Set(mode, value);
001234  001378  // Usage : gfx_Set(arg1, arg2);
001235  001379  // Notes : Sets various graphics parameters used by other functions
001236  001380  //       : This allows the features to be set programatically with a
001237  001381  //       : single function call.It is strongly recommended to use the
001238  001382  //       : pre-defined constants rather than the mode numbers.
001239  001383  //       : NB:- Although it is often required to be able to set graphics
001240  001384  //       : functions with a single function call for graphics engine
001241  001385  //       : related functions, there is a complete set of single parameter
001242  001386  //       : shortcut functions that have exactly the same function as
001243  001387  //       : each of the gfx_Set modes and saves 1 parameter / uses less memory
001244  001388  //       :
001245  001389  //       : mode = PEN_SIZE (mode 16)
001246  001390  //       : gfx_Set(PEN_SIZE, value);
001247  001391  //       : value = SOLID (value 0) rectangle and circle objects are solid
001248  001392  //       : value = OUTLINE (value 1) rectangle and circle objects are outlines
001249  001393  //       : Sets the mode of the Pen used by most graphics objects
001250  001394  //       :
001251  001395  //       : mode = BACKGROUND_COLOUR (mode 17)
001252  001396  //       : gfx_Set(BACKGROUND_COLOUR, value);
001253  001397  //       : value = 0 to 0xFFFF, Black to White
001254  001398  //       : Sets the Background colour of the screen
001255  001399  //       :
001256  001400  //       : mode = OBJECT_COLOUR (mode 18)
001257  001401  //       : gfx_Set(OBJECT_COLOUR, value);
001258  001402  //       : value = 0 to 0xFFFF, Black to White
001259  001403  //       : Sets the Object colour used in various functions
001260  001404  //       : LineTo(,,); LineRel(,,); BoxTo(,,); Dot(); etc.
001261  001405  //       :
001262  001406  //       : mode = CLIPPING (mode 19)
001263  001407  //       : gfx_Set(CLIPPING, value);
001264  001408  //       : value = OFF (value 0) Clipping disabled
001265  001409  //       : value = ON (value 1) Clipping enabled
001266  001410  //       : Enables/Disables the Clipping feature
001267  001411  //       :
001268  001412  //       : mode = TRANSPARENT_COLOUR (mode 20) : Image or Animation Transparency Colour.
001269  001413  //       : gfx_Set(TRANSPARENT_COLOUR, value);
001270  001414  //       : value = 0 to 0xFFFF Black to White
001271  001415  //       : Sets Bitmap, Image or Animation Transparency Colour.
001272  001416  //       : NB not implemented
001273  001417  //       :
001274  001418  //       : mode = TRANSPARENCY (mode 21) : Bitmap/Image/Animation Transparency
001275  001419  //       : gfx_Set(5, value);
001276  001420  //       : value = OFF (value 0) Transparency disabled
001277  001421  //       : value = ON (value 1) Transparency enabled
001278  001422  //       : Enables/Disables the Transparency feature
001279  001423  //       : NB not implemented
001280  001424  //       :
001281  001425  //       : mode = FRAME_DELAY (mode 22) : Inter-Frame Delay
001282  001426  //       : gfx_Set(FRAME_DELAY, value);
001283  001427  //       : value = 0 to 65535 ms
001284  001428  //       : Sets the Video/Animation clip inter-frame delay. This setting will
001285  001429  //       : over-ride the embedded frame delay of the clip. After the event,
001286  001430  //       : the setting will auto disable and if further inter-frame delays need
001287  001431  //       : overriding the setting must be re-issued.
001288  001432  //       :
001289  001433  //       : mode = SCREEN_MODE (mode 23) : Set required screen behaviour
001290  001434  //       : gfx_Set(SCREEN_MODE, value);
001291  001435  //       : value = LANDSCAPE   (value 0)
001292  001436  //       : value = LANDSCAPE_R (value 1)
001293  001437  //       : value = PORTRAIT    (value 2)
001294  001438  //       : value = PORTRAIT_R  (value 3)
001295  001439  //       :
001296  001440  //       : mode = OUTLINE_COLOUR (mode 24) : Outline Colour
001297  001441  //       : gfx_Set(OUTLINE_COLOUR, value);
001298  001442  //       : value = 1 to 0xFFFF, if 0, featre is OFF
001299  001443  //       : Sets the filled Rectangle or Circle objects outline colour
001300  001444  //       : If outline colour, is 0, OUTLINE_COLOUR feature is disabled
001301  001445  //       : gfx_Set(OUTLINE_COLOUR, OFF); may be used for this
001302  001446  //       :
001303  001447  //       : Only supports variable contrast for uOLED Modules
001304  001448  //       : mode = CONTRAST (mode 25) : Contrast
001305  001449  //       : gfx_Set(CONTRAST, value);
001306  001450  //       : value = 0 to 9, 0=off, 1=lowest, 8=highest contrast
001307  001451  //       : when contrast=0, display is placed in low power mode.
001308  001452  //       : This function should be called with contrast=0 when
001309  001453  //       : powering down the module.
001310  001454  //       :
001311  001455  //       : mode = LINE_PATTERN (mode 26) : Line Pattern
001312  001456  //       : gfx_Set(LINE_PATTERN, value);
001313  001457  //       : gfx_Set(LINE_PATTERN, 0b1111000011110000); // draw dotted line
001314  001458  //       : gfx_Set(LINE_PATTERN, OFF); // line patterning OFF
001315  001459  //       : a value of 0 turns the feature off
001316  001460  //       :
001317  001461  //       : mode = COLOUR_MODE (mode 27) : 8/16 bit colour mode
001318  001462  //       : gfx_Set(COLOUR_MODE , COLOUR16);   // set 16bit colour mode
001319  001463  //       : gfx_Set(COLOUR_MODE , COLOUR8);   // set 8bit colour mode
001320  001464  //       : NB not implemented, default is COLOUR16
001321  001465  //       :
001322  001466  //       : mode = BEVEL_WIDTH (mode 28) : set button and slider bevel width
001323  001467  //       : gfx_Set(BEVEL_WIDTH , 5);   // set bevel lines to 5 pixels wide
001324  001468  //       : sets the button and slider objects bevel width
001325  001469  //       :
001326  001470  //       : mode = BEVEL_SHADOW (mode 29) : set bevel shadowing depth for buttons and sliders
001327  001471  //       : gfx_Set(BEVEL_SHADOW , 5);
001328  001472  //       : sets the button and slider objects darken and lighten depth for the bevel colour
001329  001473  //       :
001330  001474  //       : mode = X_ORIGIN (mode 29) : set x offset for screen
001331  001475  //       : gfx_Set(X_ORIGIN , 25);  // object are offset 25 pixels from LHS
001332  001476  //       : sets the origin of drawn objects to a position other than 0,0
001333  001477  //       :
001334  001478  //       : mode = Y_ORIGIN (mode 29) : set y offset for screen
001335  001479  //       : gfx_Set(Y_ORIGIN , 30);  // object are offset 30 pixels from TOP
001336  001480  //       : sets the origin of drawn objects to a position other than 0,0
001337  001481        
001338  001482  //------------------------------------------------------------------------------
001339  001483  //gfx_Set() related constants
001340  001484  //------------------------------------------------------------------------------
001341  001485  #CONST
001342  001502  #END
001343  001503        
001344  001504        
001345  001505  func gfx_Cls(), 0;                    // clear the screen
001346  001506  // Syntax: gfx_Cls();
001347  001507  // Usage : gfx_Cls();
001348  001508  // Notes : Clears the screen with current background colour
001349  001509        
001350  001510  func gfx_MoveTo("x", "y"), 0;                // set glb_X1 and glb_Y1 to required co-ordinate
001351  001511  // Syntax: gfx_MoveTo(x, y);
001352  001512  // Usage : gfx_MoveTo(arg1, arg2);
001353  001513  // Notes : Moves the origin to a new x,y position
001354  001514        
001355  001515  func gfx_MoveRel("x", "y"), 0;                // set glb_X1 and glb_Y1 to new relative offset
001356  001516  // Syntax: gfx_MoveRel(x, y);
001357  001517  // Usage : gfx_MoveRel(arg1, arg2);
001358  001518  // Notes : Moves the origin to a new x,y position
001359  001519  //       : relative to the current origing
001360  001520        
001361  001521  func gfx_LineTo("x1", "y1"), 0;                     // draw line from current origin to new point
001362  001522  // Syntax: gfx_LineTo(x1, y1);
001363  001523  // Usage : gfx_LineTo(arg1, arg2);
001364  001524  // Notes : Draws a Line from the origin x,y to x1,y1.
001365  001525  //       : The new origin is then set to x1, y1. Line colour needs
001366  001526  //       : to be preset with "Set Object colour" using gfx_Set(mode=2, colour);
001367  001527        
001368  001528  func gfx_LineRel("x1", "y1"), 0;                    // draw line from current origin to new relative offset
001369  001529  // Syntax: gfx_LineRel(x1, y1);
001370  001530  // Usage : gfx_LineRel(arg1, arg2);
001371  001531  // Notes : Draws a Line from the origin x,y to x1,y1.
001372  001532  //       : Unlike gfx_MoveTo() the origin is not updated with x1, y1. Line colour needs
001373  001533  //       : to be preset with "Set Object colour" using gfx_Set(OBJECT_COLOUR, colour);
001374  001534        
001375  001535  func gfx_Line("x1", "y1", "x2", "y2", "colr"), 0;   // draw line, can be patterned
001376  001536  // Syntax: gfx_Line(x1, x2, y2, colr);
001377  001537  // Usage : gfx_Line(arg1, arg2, arg3, arg4, arg5);
001378  001538  // Notes : Plots a coloured Line from x1,y1 to x2,y2 on the screen
001379  001539        
001380  001540  func gfx_Hline("y", "x1", "x2", "colr"), 1;         // draw Hline, can be patterned
001381  001541  // Syntax: gfx_Line(x1, x2, y, colr);
001382  001542  // Usage : gfx_Line(arg1, arg2, arg3, arg4);
001383  001543  // Notes : Plots a coloured Horizontal line from x1,y to x2,y on the screen
001384  001544        
001385  001545  func gfx_Vline("x", "y1", "y2", "colr"), 1;         // draw Vline, can be patterned
001386  001546  // Syntax: gfx_Line(y1, y2, x, colr);
001387  001547  // Usage : gfx_Line(arg1, arg2, arg3, arg4);
001388  001548  // Notes : Plots a coloured Vertical line from x,y1 to x,y2 on the screen
001389  001549        
001390  001550  func gfx_Rectangle("x1" ,"y1", "x2", "y2", "colr"), 0;    // draw open rectangle,line can be patterned
001391  001551  // Syntax: gfx_Rectangle(x1, y1, x2, y2, colr);
001392  001552  // Usage : gfx_Rectangle(arg1, arg2, arg3, arg4, arg5);
001393  001553  // Notes : Plots a coloured Outline Rectangle from top corner (x1,y1) to
001394  001554  //       : bottom corner (x2,y2) on the screen.
001395  001555        
001396  001556  func gfx_RectangleFilled("x1","y1","x2","y2","colr"), 0;    // draw filled rectangle
001397  001557  // Syntax: gfx_Rectangle(x1, y1, x2, y2, colour);
001398  001558  // Usage : gfx_Rectangle(arg1, arg2, arg3, arg4, arg5);
001399  001559  // Notes : Plots a coloured Solid Rectangle from top corner (x1,y1) to
001400  001560  //       : bottom corner (x2,y2) on the screen.
001401  001561        
001402  001562  func gfx_Circle("x", "y", "rad", "colr"), 0;        // draw open circle
001403  001563  // Syntax: gfx_Circle(x, y, rad, colr);
001404  001564  // Usage : gfx_Circle(arg1, arg2, arg3, arg4);
001405  001565  // Notes : Plots a coloured outline Circle on the screen at centre x,y with radius = rad
001406  001566        
001407  001567  func gfx_CircleFilled("x", "y", "rad", "colr"), 0;    // draw filled circle
001408  001568  // Syntax: gfx_Circle(x, y, rad, colr);
001409  001569  // Usage : gfx_Circle(arg1, arg2, arg3, arg4);
001410  001570  // Notes : Plots a coloured Solid Circle on the screen at centre x,y with radius = rad
001411  001571        
001412  001572  func gfx_PutPixel("x", "y", "colr"), 0;            // set point at x y
001413  001573  // Syntax: gfx_PutPixel(x, y, colr);
001414  001574  // Usage : gfx_PutPixel(arg1, arg2, arg3);
001415  001575  // Notes : Plots a coloured pixel on the screen at x,y location
001416  001576        
001417  001577  func gfx_GetPixel("x", "y"), 1;                // read colour at point x y
001418  001578  // Syntax: gfx_GetPixel(x, y);
001419  001579  // Usage : var := gfx_GetPixel(arg1, arg2);
001420  001580  // Notes : Reads and returns the colour value of a pixel at location x,y
001421  001581        
001422  001582  func gfx_Triangle("x1","y1","x2","y2","x3","y3","colr"), 0; // draw an open triangle
001423  001583  // Syntax: gfx_Triangle(x1, y1, x2, y2, x3, y3, colr);
001424  001584  // Usage : gfx_Triangle(arg1, arg2, arg3, arg4, arg5, arg6, arg7);
001425  001585  // Notes : Plots a coloured outline Triangle from between 3 vertices: x1,y1 x2,y2 x3,y3
001426  001586  //       : Vertices must be specified in an anti-clockwise fashion
001427  001587        
001428  001588  func gfx_OrbitInit("&x_orb", "&y_orb"), 0;        // set result holders for orbit command
001429  001589  // Syntax: gfx_OrbitInit(&x_orb, &y_orb);
001430  001590  // Usage : gfx_OrbitInit(&arg1, &arg2);
001431  001591  // Notes : Sets up the Orbit function parameters.
001432  001592  //       : &x_orb, &y_orb: calcualted Orbit coordiantes. These are pointers to local
001433  001593  //       : variables that get updated after calling gfx_Orbit(,,) function.
001434  001594  //       : The coordiantaes are calculated relative to the origin
001435  001595  //       : obtained by using the gfx_MoveTo(x, y) function.
001436  001596        
001437  001597  func gfx_Orbit("angle", "distance"), 0;            // calculate point at angle, distance
001438  001598  // Syntax: gfx_Orbit(angle, distance);
001439  001599  // Usage : gfx_Orbit(arg1, arg2);
001440  001600  // Notes : The Orbit function calcualtes the x, y coordinates of a distant point whose
001441  001601  //       : only known parameters are the angle and the distance from the current origin.
001442  001602        
001443  001603  func gfx_Polyline("n", "&vx", "&vy", "colr"), 0;    // draw a polyline from a table of vertices
001444  001604  // Syntax: gfx_Polyline(numbVertices, &vertices_x, &vertices_y, colour);
001445  001605  // Usage : gfx_Polyline(arg1, x[array], y[array], arg2);
001446  001606  // Notes : This function is very similar to the Ploygon function
001447  001607  //       : with the exception of the 1st and the last vertices not joined.
001448  001608        
001449  001609  func gfx_Polygon("n", "&vx", "&vy", "colr"), 0;        // draw a polygon from a table of vertices
001450  001610  // Syntax: gfx_Polygon(numbVertices, &vx, &y, colour);
001451  001611  // Usage : gfx_Polygon(arg1, x[array], y[array], arg2);
001452  001612  // Notes : Plots a coloured outline Polygon between specified vertices: x1,y1 x2,y2 .. xn,yn
001453  001613  //       : Vertices must be minimum of 3 and can be specified in any fashion
001454  001614        
001455  001615  func gfx_Dot(), 0;                    // set point at glb_X glb_Y, default colour
001456  001616  // Syntax: gfx_Dot();
001457  001617  // Usage : gfx_Dot();
001458  001618  // Notes : Places a coloured dot at the origin
001459  001619        
001460  001620        
001461  001621  func gfx_Bullet("r"), 0;                // draw circle at glb_X glb_Y, default colour
001462  001622  // Syntax: gfx_Bullet();
001463  001623  // Usage : gfx_Bullet();
001464  001624  // Notes : Places a coloured circle at the origin
001465  001625  //       : filled or unfilled state is controlled by PenSize
001466  001626        
001467  001627  func gfx_IncX(), 1;                    // increment global origin glb_X, returning new value
001468  001628  // Syntax: gfx_IncX();
001469  001629  // Usage : var := gfx_IncX();
001470  001630  // Notes : Increments the x coordinate of the origin
001471  001631        
001472  001632  func gfx_IncY(), 1;                    // increment global origin glb_Y, returning new value
001473  001633  // Syntax: gfx_IncY();
001474  001634  // Usage : var := gfx_IncY();
001475  001635  // Notes : Increments the y coordinate of the origin
001476  001636        
001477  001637  func gfx_BoxTo("x1", "y1"), 0;                // draw rectangle from current origin to x1 y1
001478  001638  // Syntax: gfx_BoxTo(x1, y1);
001479  001639  // Usage : gfx_BoxTo(arg1, arg2);
001480  001640  // Notes : Draws a Rectangle from the origin x,y to x1,y1.
001481  001641  //       : The new origin is then set to x1,y1. Rectangle colour needs
001482  001642  //       : to be preset with "Set Object colour" using gfx_Set(mode=2, colour);
001483  001643  //       : and the PenSize setting determines if Box is solid or outline.
001484  001644        
001485  001645  func gfx_ClipWindow("x1" ,"y1", "x2", "y2"), 0;         // set the cipping area
001486  001646  // Syntax: gfx_ClipWindow(x1, y1, x2, y2);
001487  001647  // Usage : gfx_ClipWindow(arg1, arg2, arg3, arg4);
001488  001648  // Notes : Specifies a clipping window region on the screen such that any objects
001489  001649  //       : and text placed onto the screen will be clipped and displayed only
001490  001650  //       : within that region. For the clipping window to take effect, "Clipping"
001491  001651  //       : must be enabled seperately using the gfx_Set(CLIPPING, ON) command.
001492  001652        
001493  001653        
001494  001654  func gfx_ChangeColour("oldcolr", "newcolr"), 0;         // change pixel colour in clipping area
001495  001655  // Syntax: gfx_ChangeColour(oldcolr, newcolr);
001496  001656  // Usage : gfx_ChangeColour(0xFF00, 0XFFFF);
001497  001657  // *Notes:
001498  001658        
001499  001659  func gfx_SetClipRegion(), 0;                            // set clipping area to the most recent extents
001500  001660  // Syntax: gfx_SetClipRegion();
001501  001661  // Usage : var := gfx_SetClipRegion();
001502  001662  // *Notes:
001503  001663        
001504  001664  func gfx_Ellipse("x", "y", "xrad", "yrad", "colour"), 0;
001505  001665  // Syntax: gfx_Ellipse(x, y, xrad, yrad, colour);
001506  001666  // Usage : gfx_Ellipse(arg1, arg2, arg3, arg4, arg5);
001507  001667  // Notes : Plots a coloured Ellipse on the screen at centre x,y
001508  001668  //       : with xradius = xrad and yradius = yrad.
001509  001669  //       : if PenSize = 0 Ellipse is Solid
001510  001670  //       : if PenSize = 1 Ellipse is Outline
001511  001671        
001512  001672        
001513  001673  func gfx_EllipseFilled("x", "y", "xrad", "yrad", "colour"), 0;
001514  001674  // Syntax: gfx_EllipseFilled(x, y, xrad, yrad, colour);
001515  001675  // Usage : gfx_EllipseFilled(arg1, arg2, arg3, arg4, arg5);
001516  001676  // Notes : Plots a coloured Ellipse on the screen at centre x,y
001517  001677  //       : with xradius = xrad and yradius = yrad.
001518  001678        
001519  001679        
001520  001680  func gfx_Button("state", "x", "y", "buttonColour", "textColour", "font", "textWidth", "textHeight", "text"), 1;
001521  001681  // Syntax: gfx_Button(mode, x, y, buttonColour, textColour, font, textWidth, textHeight, text);
001522  001682  // Usage : gfx_Button(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
001523  001683  // Notes : Draws a 3 dimensional Text Button at screen location defined by
001524  001684  //       : x,y arguments (top left corner). The size of the button depends on
001525  001685  //       : the font, width, height and length of the text.
001526  001686  //       : The button appearance will depend on the state parameter setting:
001527  001687  //       :         state = 0 : Button Pressed
001528  001688  //       :         state = 1 : Button Raised
001529  001689  //       : The button is automatically sized, determined by text.
001530  001690        
001531  001691        
001532  001692  func gfx_Button2("state", "x", "y", "Width", "Height", "buttonColour", "textColour", "text"), 0;
001533  001693  // Syntax: gfx_Button2(mode, x, y, width, height, buttoncolour, textcolour, text);
001534  001694  // Usage : gfx_Button2(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
001535  001695  // Notes : Draws a 3 dimensional Text Button at screen location defined by
001536  001696  //       : x,y arguments (top left corner). The size of the button is defined by the width
001537  001697  //       : and height parameters. The text is centered within those bounds.
001538  001698  //       : The button appearance will depend on the state parameter setting:
001539  001699  //       :         state = 0 : Button Pressed
001540  001700  //       :         state = 1 : Button Raised
001541  001701  //       : The button has square corners.
001542  001702        
001543  001703  func gfx_Button3("state", "x", "y", "Width", "Height", "buttonColour", "textColour", "text"), 0;
001544  001704  // Syntax: gfx_Button3(mode, x, y, width, height, buttoncolour, textcolour, text);
001545  001705  // Usage : gfx_Button3(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
001546  001706  // Notes : Draws a 3 dimensional Text Button at screen location defined by
001547  001707  //       : x,y arguments (top left corner). The size of the button is defined by the width
001548  001708  //       : and height parameters. The text is centered within those bounds.
001549  001709  //       : The button appearance will depend on the state parameter setting:
001550  001710  //       :         state = 0 : Button Pressed
001551  001711  //       :         state = 1 : Button Raised
001552  001712  //       : The button has rounded corners depending upon gfx_BevelRadius.
001553  001713        
001554  001714  func gfx_CheckBox("state", "x", "y", "Width", "Height", "boxColour", "textColour", "text"), 0;
001555  001715  // Syntax: gfx_CheckBox(state, x, y, Width, Height, boxColour, textColour, text);
001556  001716  // Usage : gfx_CheckBox(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
001557  001717  // Notes : Draws a CheckBox at screen location defined by x,y arguments (top left corner).
001558  001718  //       : The size of the button is defined by the width and height parameters.
001559  001719  //       : The text is to the right of the checkbox and truncated if necessary.
001560  001720  //       : The check appearance will depend on the state parameter setting:
001561  001721  //       :         state = 0 = CHECKED    : Checkbox Checked
001562  001722  //       :         state = 1 = UNCHECKED  : CheckBox Unchecked
001563  001723        
001564  001724  func gfx_RadioButton("state", "x", "y", "Width", "Height", "boxColour", "textColour", "text"), 0;
001565  001725  // Syntax: gfx_RadioButton(state, x, y, Width, Height, boxColour, textColour, text);
001566  001726  // Usage : gfx_RadioButton(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
001567  001727  // Notes : Draws a RadioButton at screen location defined by x,y arguments (top left corner).
001568  001728  //       : The size of the button is defined by the width and height parameters.
001569  001729  //       : The text is to the right of the radiobutton and truncated if necessary.
001570  001730  //       : The check appearance will depend on the state parameter setting:
001571  001731  //       :         state = 0 = CHECKED    : Radiobutton Checked
001572  001732  //       :         state = 1 = UNCHECKED  : Radiobutton Unchecked
001573  001733        
001574  001734  func gfx_Slider2("mode", "x1", "y1", "width", "height", "colour", "scale", "value"), 1;
001575  001735  // Syntax: gfx_Slider2(mode, x, y, width, height, colour, scale, value);
001576  001736  // Usage : gfx_Slider(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
001577  001737  // Notes : Draws a 3 dimensional Slider Bar on the screen.
001578  001738  //       : Slider parameters are as follows:
001579  001739  //       :         mode = 0 : Slider recessed
001580  001740  //       :         mode = 1 : Slider raised
001581  001741  //       :         x1, y1 = top left corner
001582  001742  //       :         x2, y2 = bottom right corner
001583  001743  //       :         scale = n : sets the full scale range from 0 to n
001584  001744  //       :         value = m : sets the relative position of the thumb 0 <= m <= n
001585  001745  //returns: scaled value of thumb position
001586  001746        
001587  001747        
001588  001748        
001589  001749        
001590  001750  func gfx_Panel("state", "x", "y", "width", "height", "colour"), 0;
001591  001751  // Syntax: gfx_Panel(style, x, y, width, height, colour);
001592  001752  // Usage : gfx_Panel(PANEL_RAISED, x, y, w, h, GRAY);
001593  001753  // Notes : Draws a panel (groupbox) at screen location defined by
001594  001754  //       : x, y, width and height with colour "colour".
001595  001755  //       :         state = 0 : sunken
001596  001756  //       :         state = 1 : raised
001597  001757  //       :         state = 2 : hide (draw object in background colour)
001598  001758  //returns: nothing
001599  001759        
001600  001760        
001601  001761        
001602  001762  func gfx_Slider("mode", "x1", "y1", "x2", "y2", "colour", "scale", "value"), 1;
001603  001763  // Syntax: gfx_Slider(mode, x1, y1, x2, y2, colour, scale, value);
001604  001764  // Usage : gfx_Slider(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
001605  001765  // Notes : Draws a 3 dimensional Slider Bar on the screen.
001606  001766  //       : Slider parameters are as follows:
001607  001767  //       :         mode = 0 : Slider recessed
001608  001768  //       :         mode = 1 : Slider raised
001609  001769  //       :         x1, y1 = top left corner
001610  001770  //       :         x2, y2 = bottom right corner
001611  001771  //       :         scale = n : sets the full scale range from 0 to n
001612  001772  //       :         value = m : sets the relative position of the thumb 0 <= m <= n
001613  001773  //returns: scaled value of thumb position
001614  001774        
001615  001775        
001616  001776        
001617  001777  func gfx_ScreenCopyPaste("xs", "ys", "xd", "yd", "width", "height"), 0;
001618  001778  // Syntax: gfx_ScreenCopyPaste(xs, ys, xd, yd, width, height);
001619  001779  // Usage : gfx_ScreenCopyPaste(arg1, arg2, arg3, arg4, arg5, arg6);
001620  001780  // Notes : Copies an area of a screen from xs,ys of size given by width and height
001621  001781  //       : and pastes it to another location determined by xd, yd.
001622  001782        
001623  001783  func gfx_RGBto565("RED", "GREEN", "BLUE"), 1;
001624  001784  // Syntax: gfx_RGBto565(red, green, blue);
001625  001785  // Usage : gfx_RGBto565(arg1, arg2, arg3);
001626  001786  // Notes : Returns the 16bit (565 format) colour value of a 24bit (R,G,B format) colour
001627  001787        
001628  001788  func gfx_332to565("COLOUR8BIT"), 1;
001629  001789  // Syntax: gfx_332to565(colour);
001630  001790  // Usage : gfx_332to565(arg);
001631  001791  // Notes : Returns the 16bit (565 format) colour value of an 8 bit (332 format) colour
001632  001792        
001633  001793  func gfx_565to332("COLOUR16BIT"), 1;
001634  001794  // Syntax: gfx_565to332(colour);
001635  001795  // Usage : clor332 := gfx_565to332(arg);
001636  001796  // Notes : Returns the 8bit (332 format) colour value of an 16 bit (565 format) colour
001637  001797        
001638  001798  func gfx_TriangleFilled("x1","y1","x2","y2","x3","y3","colr"), 0; // draw a filled triangle
001639  001799  // Syntax: gfx_TriangleFilled(x1, y1, x2, y2, x3, y3, colr);
001640  001800  // Usage : gfx_TriangleFilled(arg1, arg2, arg3, arg4, arg5, arg6, arg7);
001641  001801  // Notes : Plots a coloured Solid Triangle from between 3 vertices: x1,y1 x2,y2 x3,y3
001642  001802  //       : Vertices must be specified in an anti-clockwise fashion
001643  001803        
001644  001804        
001645  001805  func gfx_PolygonFilled("n", "&vx", "&vy", "colr"), 0;        // draw a filled polygon from a table of vertices
001646  001806  // Syntax: gfx_PolygonFilled(numbVertices, &vx, &y, colour);
001647  001807  // Usage : gfx_PolygonFilled(arg1, x[array], y[array], arg2);
001648  001808  // Notes : Plots a solid Polygon between specified vertices: x1,y1 x2,y2 .. xn,yn
001649  001809  //       : Vertices must be minimum of 3 and can be specified in any fashion
001650  001810        
001651  001811        
001652  001812  func gfx_Origin("x", "y"), 0;            // set relative screen offset for graphics objects
001653  001813  // Syntax: gfx_Offset(x, y);
001654  001814  // Usage : gfx_Offset(arg1, arg2);
001655  001815  // Notes : Set the screen offset
001656  001816        
001657  001817        
001658  001818        
001659  001819  func gfx_FillPattern("patptr", "mode"), 1;
001660  001820  // Syntax  : gfx_FillPattern(patternpointer);
001661  001821  // Usage   : gfx_FillPattern(PTN_BRICKS);
001662  001822  //         : Provides graphics fill pattern, (8 linear bytes, 1=pixel off)
001663  001823  // Notes   : "patptr" points to an 8x8 tile for rendering filled areas.
001664  001824  //         : Rendering is turned off with gfx_FillPattern(0);
001665  001825  //         : or gfx_FillPattern(OFF);
001666  001826  //         : "mode" maybe TRANSPARENT or OPAQUE (0 or 1), for OPAQUE
001667  001827  //         : mode, the current screen colour is used for the 'off'
001668  001828  //         : pixels, for transparent mode, the 'off' pixels are not drawn.
001669  001829  //         : gfx_FillPattern affects all filled object, including polygons.
001670  001830  //         : There are 32 builtin patterns, these are obtained using the
001671  001831  //         : pre-defined constants FILLPATTERN_0 to FILLPATTERN_31, or the
001672  001832  //         : names, eg PTN_BRICKS, PTN_CARGONET, PTN_CIRCUITS, etc.
001673  001833  //         : Note that the constants range from 0xFFE0 to 0xFFFF, any
001674  001834  //         : other value is assumed to be a pointer to a users 8 byte
001675  001835  //         : block pattern.
001676  001836  // Returns : returns the handle of the previous pattern.
001677  001837        
001678  001838        
001679  001839  func gfx_PieSlice("cx", "cy", "spread", "radius", "step", "startangle", "endangle", "mode", "colour"), 0;
001680  001840  // Syntax  : gfx_PieSlice(cx, cy, spread, radius, step, startangle, endangle, mode, colour);
001681  001841  // Usage   : gfx_PieSlice(120, 120, 0, 100, 8, 75, 145, 0, YELLOW);
001682  001842  // Notes   : Draws a 'pie slice' (filled arc) at "cx":"cy" with radius "radius", starting at "startangle"
001683  001843  //         : and ending at "endangle". "spread" is used to offset the centrepoint of the pieslice
001684  001844  //         : to shift a pie chart piece away from the centrepoint.
001685  001845  //         : Rendering can be obtained with gfx_FillPattern(PATTRN);
001686  001846  //         : or gfx_FillPattern(OFF); for no fill pattern.
001687  001847  //         : Step is the stepping angle increment for the fineness of the pie Slice.
001688  001848  //         : "mode" has the following effect
001689  001849  //         :   if mode = 0, no outline
001690  001850  //         :   if mode = 1, outer circumference line (using current object colour)
001691  001851  //         :   if mode = 2, outer circumference and slice lines ( (using current object colour)
001692  001852  // Returns : nothing.
001693  001853        
001694  001854        
001695  001855  func gfx_Arc("xc", "yc", "radius", "step", "startangle", "endangle", "mode"), 0;
001696  001856  // Syntax  : gfx_ARC(cx, cy, radius, step, startangle, endangle, mode);
001697  001857  // Usage   : gfx_ARC(120, 120, 0, 100, 8, 75, 145, 0);
001698  001858  // Notes   : Draws an arc at "cx":"cy" with radius "radius", starting at "startangle"
001699  001859  //         : and ending at "endangle". Colour is determined by curent object colour.
001700  001860  //         : Step is the stepping angle increment for the fineness of the arc.
001701  001861  //         : "mode" has the following effect
001702  001862  //         :   if mode = 0, outer circumference line only
001703  001863  //         :   if mode = 1, outer circumference and lines back to cy:cy
001704  001864  // Returns : nothing.
001705  001865        
001706  001866        
001707  001867  func gfx_RoundRect("x1", "y1", "x2", "y2", "rad", "color"), 0;
001708  001868  // Syntax  : gfx_RoundRect(x1, y1, x2, y2, radius, colour);
001709  001869  // Usage   : gfx_RoundRect(120, 120, 160, 160, 8, GRAY); // draw a tab like object
001710  001870  // Notes   : Draws a filled rectangle at the given co-ordinates with rounded corners
001711  001871  //         : determined by "radius".
001712  001872  //         : Bounding rectangle is x1-rad, y1-rad, x2+rad, y2+rad.
001713  001873  // Returns : nothing.
001714  001874        
001715  001875        
001716  001876  func gfx_Surround("x1", "y1", "x2", "y2", "rad1", "rad2", "color"), 0;
001717  001877  // Syntax  : gfx_Surround(x1, y1, x2, y2, radius1, radius1, colour);
001718  001878  // Usage   : gfx_Surround(120, 120, 160, 160, 8, 0, GRAY); // rounded surround frame
001719  001879  // Notes   : Draws a outline rectangle at the given co-ordinates with rounded corners
001720  001880  //         : determined by "radius1". "radius2" sets the radius of the outer rounded rectangle.
001721  001881  //         : If "radius1" is zero, the inner rectangle will have square corners.
001722  001882  //         : Bounding rectangle is x1-rad1-rad2, y1-rad1-rad2, x2+rad1+rad2, y2+rad1+rad2.
001723  001883  // Returns : nothing.
001724  001884        
001725  001885        
001726  001886  func gfx_RoundPanel("state", "x", "y", "width", "height", "radius", "bevelwidth", "colour"), 0;
001727  001887  // Syntax  : gfx_RoundPanel(style, x, y, width, height, radius, bevelwidth, colour);
001728  001888  // Usage   : gfx_RoundPanel(PANEL_RAISED, 100, 100, 30, 20, GRAY);
001729  001889  // Notes   : Draws a rounded panel at x, y, width and height may be zero allowing the function
001730  001890  //         : to be used for rounded panels, rounded buttons, circular buttons.
001731  001891  //         :         state = 0 : sunken
001732  001892  //         :         state = 1 : raised
001733  001893  //         :         state = 2 : hide (draw object in background colour)
001734  001894  //         : Bounding rectangle is x1-radius-bevelwidth, y1-radius-bevelwidth, x2+radius+bevelwidth, y2+radius+bevelwidth.
001735  001895  // Returns : nothing.
001736  001896        
001737  001897        
001738  001898  func gfx_Gradient("style", "left", "top", "right", "bottom", "color1", "color2"), 0;
001739  001899  // Syntax  : gfx_Gradient(style, x1, y1, x2, y2, colr1, colr2);
001740  001900  // Usage   : gfx_Gradient(GRAD_WAVE_VER, 100, 100, 230, 120, BLACK, WHITE);
001741  001901  // Notes   : Draws a graduated colour rectangle at the specified co-ordinate.
001742  001902  //         : "style" specifies the drawing mode
001743  001903  //         :     GRAD_DOWN         // gradient changes in the vertical direction
001744  001904  //         :     GRAD_RIGHT        // gradient change in the horizontal direction
001745  001905  //         :     GRAD_UP           // gradient changes in the vertical direction
001746  001906  //         :     GRAD_LEFT         // gradient change in the horizontal direction
001747  001907  //         :     GRAD_WAVE_VER     // gradient wave in the vertical direction
001748  001908  //         :     GRAD_WAVE_HOR     // gradient wave in the horizontal direction
001749  001909  // Returns : nothing.
001750  001910        
001751  001911        
001752  001912  func gfx_RoundGradient("style", "left", "top", "right", "bottom", "radius", "color1", "color2"), 0;
001753  001913  // Syntax  : gfx_Gradient(style, x1, y1, x2, y2, radius, colr1, colr2);
001754  001914  // Usage   : gfx_Gradient(GRAD_WAVE_VER, 100, 100, 230, 120, BLACK, WHITE);
001755  001915  // Notes   : Draws a graduated colour rounded rectangle at the specified co-ordinate.
001756  001916  //         : X1 may equal X2, and Y1 = Y2 allowing allowing the function
001757  001917  //         : to be used for rounded panels, rounded buttons, circular buttons.
001758  001918  //         : "style" specifies the drawing mode
001759  001919  //         :     GRAD_DOWN         // gradient changes in the vertical direction
001760  001920  //         :     GRAD_RIGHT        // gradient change in the horizontal direction
001761  001921  //         :     GRAD_UP           // gradient changes in the vertical direction
001762  001922  //         :     GRAD_LEFT         // gradient change in the horizontal direction
001763  001923  //         :     GRAD_WAVE_VER     // gradient wave in the vertical direction
001764  001924  //         :     GRAD_WAVE_HOR     // gradient wave in the horizontal direction
001765  001925  //         : Bounding rectangle is x1-radius, y1-radius, x2+radius, y2+radius.
001766  001926  // Returns : nothing.
001767  001927        
001768  001928        
001769  001929  func gfx_ReadBresLine("x1", "y1", "x2", "y2", "ptr"), 1;
001770  001930  // Syntax  : gfx_readBrezLine(x1, y1, x2, y2, ptr);
001771  001931  // Usage   : anArrayPtr := gfx_readBrezLine(10, 10, 50, 50, 0);  // read arbitrary line to array, let the function make the array for me
001772  001932  // Notes   : reads an arbitrary line from the display to an array.
001773  001933  //         : If "ptr" is 0, the correctly sized array is created, in which case
001774  001934  //         : it is up to the caller to eventually destroy it. Otherwise "ptr"
001775  001935  //         : is expected to point to a correctly sized array.
001776  001936  //         : NB if an array is supplied, its size must be large enough, and may
001777  001937  //         : be calculated:-
001778  001938  //         : bytecount := (MAX(ABS(x2-x1), ABS(y2-y1) + 1) * 2; // calc array size for mem_Alloc (which allocates byte storage)
001779  001939  //         : wordcount := (MAX(ABS(x2-x1), ABS(y2-y1) + 1);     // calc array size for fixed word array
001780  001940  // Returns : A pointer to the created aray, or the users array.
001781  001941  //         : In the case of ptr=0, if there is insufficient
001782  001942  //         : memory to create the array, zero is returned
001783  001943        
001784  001944        
001785  001945  func gfx_WriteBresLine("x1", "y1", "x2", "y2", "ptr"), 0;
001786  001946  // Syntax  : gfx_writeBrezLine(x1, y1, x2, y2, ptr), 0;
001787  001947  // Usage   : gfx_writeBrezLine(20, 20, 50, 50, anArrayPtr);   // write an array back to the arbitrary line
001788  001948  // Notes   : cast pixel values from array to arbitrary line "x1", "y1", "x2", "y2"
001789  001949  //         : "ptr" points to the array to be written.
001790  001950  // Returns : nothing
001791  001951        
001792  001952        
001793  001953  func gfx_ReadGRAMarea("x1", "y1", "x2", "y2", "ptr"), 1;
001794  001954  // Syntax  : gfx_ReadGRAMarea(x1, y1, x2, y2, ptr);
001795  001955  // Usage   : anArrayPtr := gfx_ReadGRAMarea(10, 10, 50, 50, 0);  // read rectangular area to array, let the function make the array for me
001796  001956  // Notes   : reads an arbitrary rectangular area from the display to an array.
001797  001957  //         : If "ptr" is 0, the correctly sized array is created, in which case
001798  001958  //         : it is up to the caller to eventually destroy it. Otherwise "ptr"
001799  001959  //         : is expected to point to a correctly sized array.
001800  001960  //         : NB if an array is supplied, its size must be large enough, and may
001801  001961  //         : be calculated:-
001802  001962  //         : bytecount := ( (ABS(x2-x1)+1) * (ABS(y2-y1) + 1)) * 2;     // calc array size for mem_Alloc (which allocates byte storage)
001803  001963  //         : wordcount := ( (ABS(x2-x1)+1) *  ABS(y2-y1);             // calc array size for fixed word array
001804  001964  // Returns : A pointer to the created aray, or the users array.
001805  001965  //         : In the case of ptr=0, if there is insufficient
001806  001966  //         : memory to create the array, zero is returned
001807  001967        
001808  001968        
001809  001969  func gfx_WriteGRAMarea("x1", "y1", "x2", "y2", "ptr"), 0;
001810  001970  // Syntax  : gfx_WriteGRAMarea(x1, y1, x2, y2, ptr), 0;
001811  001971  // Usage   : gfx_WriteGRAMarea(20, 20, 50, 50, anArrayPtr);   // write an array back to the rectangular area
001812  001972  // Notes   : "ptr" points to the array to be written.
001813  001973  // Returns : nothing
001814  001974        
001815  001975        
001816  001976  func gfx_Get("mode"), 1;
001817  001977  // Syntax: gfx_Get(mode);
001818  001978  // Usage : arg1 := gfx_Get(arg);
001819  001979  // Notes : Returns various parameters to caller
001820  001980  //       :
001821  001981  //       : mode = X_MAX (mode 0) : current orientations maximum X value
001822  001982  //       : var := gfx_Get(X_MAX);
001823  001983  //       : Returns the maximum horizontal value of the display
001824  001984  //       :
001825  001985  //       : mode = Y_MAX (mode 1) : Vcurrent orientations maximum Y value
001826  001986  //       : var := gfx_Get(Y_MAX);
001827  001987  //       : Returns the maximum vertical value of the display
001828  001988  //       :
001829  001989  //       : mode = LEFT_POS (mode 2) : Left location of last Object
001830  001990  //       : var := gfx_Get(LEFT_POS);
001831  001991  //       : Returns the left location of the last drawn object
001832  001992  //       : such as a slider or button or an image/video
001833  001993  //       :
001834  001994  //       : mode = TOP_POS (mode 3) : Top location of Object
001835  001995  //       : var := gfx_Get(TOP_POS);
001836  001996  //       : Returns the top location of the last drawn object
001837  001997  //       : such as a slider or button or an image/video
001838  001998  //       :
001839  001999  //       : mode = RIGHT_POS (mode 4) : Right location of last Object
001840  002000  //       : var := gfx_Get(RIGHT_POS);
001841  002001  //       : Returns the right location of the last drawn object
001842  002002  //       : such as a slider or button or an image/video
001843  002003  //       :
001844  002004  //       : mode = BOTTOM_POS  (mode 5) : Bottom location of Object
001845  002005  //       : var := gfx_Get(BOTTOM_POS );
001846  002006  //       : Returns the bottom location of the last drawn object
001847  002007  //       : such as a slider or button or an image/video
001848  002008  //       :
001849  002009  //       : mode = X_ORG (mode 6) : get current internal X position
001850  002010  //       : var := gfx_Get(X_ORG);
001851  002011  //       : Returns the internal X position that was set with
001852  002012  //       : gfx_MoveTo(x, y); or gfx_Set(X_ORG, pos);
001853  002013  //       :
001854  002014  //       : mode = Y_ORG (mode 7) : get current internal Y position
001855  002015  //       : var := gfx_Get(Y_ORG);
001856  002016  //       : Returns the internal X position that was set with
001857  002017  //       : gfx_MoveTo(x, y); or gfx_Set(Y_ORG, pos);
001858  002018  //       :
001859  002019        
001860  002020        
001861  002021  //------------------------------------------------------------------//
001862  002022  // Single parameter short-cuts                                      //
001863  002023  // for the gfx_Set functions                                        //
001864  002024  // These functions return the existing value before                 //
001865  002025  // the change is made.                                              //
001866  002026  //------------------------------------------------------------------//
001867  002027  func gfx_PenSize("mode"), 1;                        // 0  graphics pen size, SOLD or OUTLINE
001868  002028  func gfx_BGcolour("colour"), 1;                     // 1  graphics background colour
001869  002029  func gfx_ObjectColour("colour"), 1;                 // 2  graphics object colour
001870  002030  func gfx_Clipping("mode"), 1;                       // 3  graphics clipping ON/OFF
001871  002031  func gfx_TransparentColour("colour"), 1;            // 4  graphics image transparent mask colour
001872  002032  func gfx_Transparency("mode"), 1;                   // 5  graphics image transparent mode ON/OFF
001873  002033  func gfx_FrameDelay("milliseconds"), 1;             // 6  graphics animation frame delay
001874  002034  func gfx_ScreenMode("mode"), 1;                     // 7  graphics orientation LANDSCAPE, LANDSCAPE_R, PORTRAIT, PORTRAIT_R
001875  002035  func gfx_OutlineColour("colour"), 1;                // 8  graphics rectangle/circle outline colour
001876  002036  func gfx_Contrast("value"), 1;                      // 9  graphics hardware value 0 to 9, 0=off, 1=lowest, 8=highest (only for AMOLED devices)
001877  002037  func gfx_LinePattern("value"), 1;                   // 10 graphics line draw tesselation pattern (16 linear bits, 1=pixel off)
001878  002038  func gfx_BevelRadius("radius"), 1;                  // 11 graphics button bevel radius
001879  002039  func gfx_BevelWidth("value"), 1;                    // 12 graphics button bevel width
001880  002040  func gfx_BevelShadow("value"), 1;                   // 13 graphics button bevel shadow depth
001881  002041  func gfx_Xorigin("offset"), 1;                      // 14 graphics  X origin
001882  002042  func gfx_Yorigin("offset"), 1;                      // 15 graphics  Y origin
001883  002043        
001884  002044        
001885  002045  func gfx_PointWithinBox("x", "y", "&rectr"), 1;
001886  002046  // Syntax   : gfx_PointWithinBox(x, y, rect);
001887  002047  // Usage    : var r[4]; r[0]:=100; r[1]:=200; r[2]:=20; r[3]:=30;
001888  002048  //          : result := gfx_PointWithinBox(x, y, r); // check area at 100,200,119,229
001889  002049  // Notes    : rect is an array of 4 vars, x1, y1, width, height - using width co-ordinates
001890  002050  // returns  : Returns true if last touch co-ordinates are within the box test area.
001891  002051        
001892  002052        
001893  002053  func gfx_PointWithinRectangle("x", "y", "&recta"), 1;
001894  002054  // Syntax   : gfx_PointWithinRectangle(x, y, recta);
001895  002055  // Usage    : var r[4]; r[0]:=100; r[1]:=200; r[2]:=119; r[3]:=129;
001896  002056  //          : result := gfx_PointWithinRectangle(x, y, r); // check if point within area at 100,200,119,229
001897  002057  // Notes    : rect is an array of 4 vars, x1, y1, x2, y2 using absolute co-ordinates
001898  002058  // returns  : Returns true if x:y co-ordinates are within the rectangle test area.
001899  002059        
001900  002060        
001901  002061  func __reserved17(), 0; // do not remove
001902  002062  func __reserved18(), 0; // do not remove
001903  002063  func __reserved19(), 0; // do not remove
001904  002064  func __reserved20(), 0; // do not remove
001905  002065  func __reserved21(), 0; // do not remove
001906  002066  func __reserved22(), 0; // do not remove
001907  002067        
001908  002068        
001909  002069  // built in fill pattern constants for function gfx_FillPattern
001910  002070  #CONST
001911  002103  #END
001912  002104        
001913  002105  #CONST
001914  002138  #END
001915  002139        
001916  002140  //------------------------------------------------------------------//
001917  002141  //     gradient control constants                                   //
001918  002142  //------------------------------------------------------------------//
001919  002143  #constant GRAD_DOWN         0x20    // gradient changes in the vertical direction
001920  002143  #constant GRAD_DOWN         0x20    // gradient changes in the vertical direction
001921  002144  #constant GRAD_RIGHT        0x30    // gradient change in the horizontal direction
001922  002144  #constant GRAD_RIGHT        0x30    // gradient change in the horizontal direction
001923  002145  #constant GRAD_UP           0x40    // gradient changes in the vertical direction
001924  002145  #constant GRAD_UP           0x40    // gradient changes in the vertical direction
001925  002146  #constant GRAD_LEFT         0x50    // gradient change in the horizontal direction
001926  002146  #constant GRAD_LEFT         0x50    // gradient change in the horizontal direction
001927  002147  #constant GRAD_WAVE_VER     0x60    // gradient wave in the vertical direction
001928  002147  #constant GRAD_WAVE_VER     0x60    // gradient wave in the vertical direction
001929  002148  #constant GRAD_WAVE_HOR     0x70    // gradient wave in the horizontal direction
001930  002148  #constant GRAD_WAVE_HOR     0x70    // gradient wave in the horizontal direction
001931  002149        
001932  002150        
001933  002151        
001934  002152        
001935  002153  //------------------------------------------------------------------//
001936  002154  // uSD/FLASH Function Prototypes                                    //
001937  002155  //------------------------------------------------------------------//
001938  002156  func media_Video("x", "y"), 0;                      // display movie at position x y
001939  002157  // Syntax: media_Video(x, y);
001940  002158  // Usage : media_Video(arg1, arg2);
001941  002159  // Notes : Play a Video/Animation clip from the uSD card at screen location
001942  002160  //       : specified by x,y (top left corner). The location of the clip in the
001943  002161  //       : uSD card must be specified by media_setSector(Video_Sector_Add) function.
001944  002162        
001945  002163  func media_VideoFrame("x", "y","framenumber"), 0;   // display required frame from a movie at x y
001946  002164  // Syntax: media_VideoFrame(Frame_number);
001947  002165  // Usage : arg1 := media_VideoFrame();
001948  002166  // Notes : After a pointer to a valid video has been set with media_SetSector,
001949  002167  //       : calling this function shows each fram sequentially, returning
001950  002168  //       : the number of frames remaining. The position of the image is
001951  002169  //     : at the current origin as set with gfx_MoveTo(...);
001952  002170        
001953  002171  func media_SetAdd("HiWord", "LoWord"), 0;           // set stream byte address
001954  002172  // Syntax: media_SetAdd(AddHiWord, AddLoWord);
001955  002173  // Usage : media_SetAdd(arg1, arg2);
001956  002174  // Notes : Set uSD internal Address pointer for bytewise access
001957  002175        
001958  002176  func media_SetSector("HiWord", "LoWord"), 0;        // set stream sector address
001959  002177  // Syntax: media_SetSector(SectHiWord, SectLoWord);
001960  002178  // Usage : media_SetSector(arg1, arg2);
001961  002179  // Notes : Set uSD internal Sector pointer for sector block access
001962  002180        
001963  002181  func media_RdSector("*destination"), 1;
001964  002182  // Syntax: media_RdSector(*destination);
001965  002183  // Usage : media_RdSector(rdblock);
001966  002184  // Notes : Reads and Returns 512 bytes (256 words) into a destination
001967  002185  //       : block (eg rdblock[256]) pointed to by the internal Sector pointer.
001968  002186  //       : After the read the Sector pointer is automatically incremented by 1.
001969  002187  //       : Returns TRUE if uSD response was TRUE
001970  002188        
001971  002189  func media_WrSector("*source"), 1;
001972  002190  // Syntax: media_WrSector(*source);
001973  002191  // Usage : media_WrSector(wrblock);
001974  002192  // Notes : Writes 512 bytes (256 words) from a source memory block
001975  002193  //       : (eg wrblock[256]) into the uSD card. After the write the Sector
001976  002194  //       : pointer is automatically incremented by 1.
001977  002195  //       : Returns TRUE if uSD response was TRUE
001978  002196        
001979  002197  func media_ReadByte(), 1;                // read a byte at the current stream position
001980  002198  // Syntax: media_RdByte();
001981  002199  // Usage : var := media_RdByte();
001982  002200  // Notes : Reads and Returns a single byte of data from the
001983  002201  //       : uSD card pointed to by the internal Address pointer.
001984  002202  //       : After the read the Address pointer is automatically
001985  002203  //       : incremented by 1.
001986  002204        
001987  002205  func media_ReadWord(), 1;                // read a word at the current stream position
001988  002206  // Syntax: media_ReadWord();
001989  002207  // Usage : var := media_ReadWord();
001990  002208  // *Notes : Reads and Returns a single word of data from the
001991  002209  //       : uSD card pointed to by the internal Address pointer.
001992  002210  //       : After the read the Address pointer is automatically
001993  002211  //       : incremented by 2.
001994  002212        
001995  002213  func media_WriteByte("byte"), 1;              // write a byte to the current stream position
001996  002214  // Syntax: media_WriteByte(arg1);
001997  002215  // Usage : var := media_WriteByte(arg1);
001998  002216  // *Notes : Writes and Returns xxxxx
001999  002217  //       : After the write the Address pointer is automatically
002000  002218  //       : incremented by 1.
002001  002219        
002002  002220  func media_WriteWord("word"), 1;            // write a word to the current stream position
002003  002221  // Syntax: media_WriteWord(arg1);
002004  002222  // Usage : var := media_WriteWord(arg1);
002005  002223  // *Notes : Writes and Returns xxxxx
002006  002224  //       : After the write the Address pointer is automatically
002007  002225  //       : incremented by 2.
002008  002226        
002009  002227  func media_Image("x", "y"), 0;            // display image at position x y
002010  002228  // Syntax: media_Image(x, y);
002011  002229  // Usage : media_Image(arg1, arg2);
002012  002230  // Notes : Display an image from the uSD card at screen location
002013  002231  //       : specified by x,y (top left corner). The location of the
002014  002232  //       : Image in the uSD card must be specified by
002015  002233  //       : media_setSector(Image_Sector_Add) function.
002016  002234        
002017  002235  func media_Flush(), 1;                    // after writing to media, flush the sector and write
002018  002236  // Syntax: media_Flush();
002019  002237  // Usage : var := media_Flush();
002020  002238  // *Notes : After writing any data to a sector, media_Flush() should be called to ensure that the current sector that
002021  002239  //       : is being written is correctly stored back to the media else write operations may be unpredictable.
002022  002240        
002023  002241  func media_Init(), 1;                    // initialize uSD card
002024  002242  // Usage : media_Init();
002025  002243  // Notes : Initialise uSD CARD
002026  002244  //       : Response: 0 = No Card
002027  002245  //       :           1 = Card Initialised
002028  002246        
002029  002247  func __reserved23(), 0; // do not remove
002030  002248  func __reserved24(), 0; // do not remove
002031  002249  func __reserved25(), 0; // do not remove
002032  002250  func __reserved26(), 0; // do not remove
002033  002251        
002034  002252  //==============================================//
002035  002253  // Communications Function Prototypes           //
002036  002254  // NB Primary COM port has fixed pins,          //
002037  002255  // COM1, COM2 and COM3 must have pins assigned. //
002038  002256  //==============================================//
002039  002257  func setbaud("baudnum"), 0;            // set baud rate of COM0
002040  002258  // Syntax: setbaud(baud_number);
002041  002259  // Usage : setbaud(BAUD_128000);        //Set baud rate to 128000bps
002042  002260  // *Notes : argument specifies the baud rate using pre-defined constant.
002043  002261  //       : The pre-defined constant is a value of 0-19 , and internally
002044  002262  //       : this is used as a table pointer to get the baud rate divisor
002045  002263  //       : value for one of the 20 selected baud rates, control is then
002046  002264  //       : passed to com_SetBaud(COM0, baudlookup[baud_number]);
002047  002265  //       : The pre-defined constants equate to a value of 0-19.
002048  002266  //       : If a value other than 0-19 is used, a run time error (eror 25)
002049  002267  //       : will occur.
002050  002268        
002051  002269  // baud divisor rates for legacy setbaud(n);
002052  002270  #CONST
002053  002292  #END
002054  002293        
002055  002294        
002056  002295  func com_SetBaud("comport","baudrate/10"), 1;
002057  002296  // Syntax: com_SetBaud("comport","baudrate/10");
002058  002297  // Usage : com_SetBaud(COM1, 960);   // set COM1 to 9600 baud
002059  002298  // Notes : sets to any viable baud rate from 160 to 655350
002060  002299  // return true if baud rate was acceptable
002061  002300        
002062  002301        
002063  002302  func COM1_RX_pin("pin"), 1;        // select the hardware pin for the COM1 receive line
002064  002303  // Usage : COM1_RX_pin(PA0); // set COM1 RX to PA0 pin
002065  002304  // Notes : Selects the hardware pin for COM1 receive line.
002066  002305  //       : Note that only a single pin can be mapped to COM1 RX.
002067  002306  //       : Pins that can be mapped to COMx TX are PA0 to PA13
002068  002307  //       : Pins that can't be mapped to COMx RX are PA14 and PA15
002069  002308  //       : If the pin argument is 0 the function has no effect
002070  002309  //       : The pin is automatically set to an input.
002071  002310  //       : If the COMx RX pin is set to same pin as COMx TX pin (eg for a loopback check)
002072  002311  //       : it is necessary to configure the input pin first, eg
002073  002312  //       :     COM1_RX_pin(PA7);     // configure COM1 RX to PA7 (this disconnects anything else)
002074  002313  //       :     COM1_TX_pin(PA7));    // configure COM1 TX to PA7
002075  002314  //       : Returns: Returns TRUE if function succeeded (usually ignored)
002076  002315        
002077  002316  func COM2_RX_pin("pin"), 1;        // select the hardware pin for the COM2 receive line
002078  002317  // Usage : COM2_RX_pin(PA0); // set COM2 RX to PA0 pin
002079  002318  // Notes : Selects the hardware pin for COM2 receive line.
002080  002319  //       : Note that only a single pin can be mapped to COM2 RX.
002081  002320  //       : Pins that can be mapped to COMx TX are PA0 to PA13
002082  002321  //       : Pins that can't be mapped to COMx RX are PA14 and PA15
002083  002322  //       : If the pin argument is 0 the function has no effect
002084  002323  //       : The pin is automatically set to an input.
002085  002324  //       : If the COMx RX pin is set to same pin as COMx TX pin (eg for a loopback check)
002086  002325  //       : it is necessary to configure the input pin first, eg
002087  002326  //       :     COM2_RX_pin(PA7);     // configure COM2 RX to PA7 (this disconnects anything else)
002088  002327  //       :     COM2_TX_pin(PA7));    // configure COM2 TX to PA7
002089  002328  //       : Returns: Returns TRUE if function succeeded (usually ignored)
002090  002329        
002091  002330  func COM3_RX_pin("pin"), 1;        // select the hardware pin for the COM3 receive line
002092  002331  // Usage : COM3_RX_pin(PA0); // set COM3 RX to PA0 pin
002093  002332  // Notes : Selects the hardware pin for COM3 receive line.
002094  002333  //       : Note that only a single pin can be mapped to COM3 RX.
002095  002334  //       : Pins that can be mapped to COMx TX are PA0 to PA13
002096  002335  //       : Pins that can't be mapped to COMx RX are PA14 and PA15
002097  002336  //       : If the pin argument is 0 the function has no effect
002098  002337  //       : The pin is automatically set to an input.
002099  002338  //       : If the COMx RX pin is set to same pin as COMx TX pin (eg for a loopback check)
002100  002339  //       : it is necessary to configure the input pin first, eg
002101  002340  //       :     COM3_RX_pin(PA7);     // configure COM3 RX to PA7 (this disconnects anything else)
002102  002341  //       :     COM3_TX_pin(PA7));    // configure COM3 TX to PA7
002103  002342  //       : Returns: Returns TRUE if function succeeded (usually ignored)
002104  002343        
002105  002344        
002106  002345  func COM1_TX_pin("pin"), 1;        // select the hardware pin for COM1 transmit line
002107  002346  // Syntax: COM1_TX_pin(pin);
002108  002347  // Usage : COM1_TX_pin(PA2); // set COM1 TX to PA2 pin
002109  002348  // Notes : Select the hardware pin for COMx transmit line.
002110  002349  //       : Pins that can be mapped to COMx TX are PA1, PA3 to PA9, and PA12 or PA13
002111  002350  //       : Pins that can't be mapped to COMx TX are PA0, PA2, PA10, PA11, PA14 and PA15
002112  002351  //       : If the pin argument is 0, COMx TX is disconnected from all pins.
002113  002352  //       : The pin is automatically set to an output.
002114  002353  //       : Returns: Returns TRUE if function succeeded (usually ignored)
002115  002354        
002116  002355  func COM2_TX_pin("pin"), 1;        // select the hardware pin for COM2 transmit line
002117  002356  // Syntax: COM2_TX_pin(pin);
002118  002357  // Usage : COM2_TX_pin(PA2); // set COM2 TX to PA2 pin
002119  002358  // Notes : Select the hardware pin for COMx transmit line.
002120  002359  //       : Pins that can be mapped to COMx TX are PA1, PA3 to PA9, and PA12 or PA13
002121  002360  //       : Pins that can't be mapped to COMx TX are PA0, PA2, PA10, PA11, PA14 and PA15
002122  002361  //       : If the pin argument is 0, COMx TX is disconnected from all pins.
002123  002362  //       : The pin is automatically set to an output.
002124  002363  //       : Returns: Returns TRUE if function succeeded (usually ignored)
002125  002364        
002126  002365  func COM3_TX_pin("pin"), 1;        // select the hardware pin for COM3 transmit line
002127  002366  // Syntax: COM3_TX_pin(pin);
002128  002367  // Usage : COM3_TX_pin(PA2); // set COM3 TX to PA2 pin
002129  002368  // Notes : Select the hardware pin for COMx transmit line.
002130  002369  //       : Pins that can be mapped to COMx TX are PA1, PA3 to PA9, and PA12 or PA13
002131  002370  //       : Pins that can't be mapped to COMx TX are PA0, PA2, PA10, PA11, PA14 and PA15
002132  002371  //       : If the pin argument is 0, COMx TX is disconnected from all pins.
002133  002372  //       : The pin is automatically set to an output.
002134  002373  //       : Returns: Returns TRUE if function succeeded (usually ignored)
002135  002374        
002136  002375  func com_Init("buf","bufsize","qualifier"), 0;  // set up a interrupt driven ring buffer for comms
002137  002376  // Syntax: com_Init(buffer, bufsize, qualifier);
002138  002377  // Usage1: com_Init(mybuf, 20, 0);
002139  002378  // Usage2: com_Init(mybuf, 20, ':');
002140  002379  // Notes : initialize a serial capture buffer for the comms input
002141  002380  //       : The program must declare a var array as a circular buffer.
002142  002381  //       : Usage1 declares a circular buffer which will continually
002143  002382  //       : buffer characters.
002144  002383  //       : Usage2 must receive ':' before any characters will
002145  002384  //       : accumulate in the buffer.
002146  002385        
002147  002386  func com1_Init("buf","bufsize","qualifier"), 0;
002148  002387  // Syntax: com1_Init(buffer, bufsize, qualifier);
002149  002388  // Usage1: com1_Init(mybuf, 20, 0);
002150  002389  // Usage2: com1_Init(mybuf, 20, ':');
002151  002390  // Notes : initialize a serial capture buffer for the comms input
002152  002391  //       : The program must declare a var array as a circular buffer.
002153  002392  //       : Usage1 declares a circular buffer which will continually
002154  002393  //       : buffer characters.
002155  002394  //       : Usage2 must receive ':' before any characters will
002156  002395  //       : accumulate in the buffer.
002157  002396        
002158  002397  func com2_Init("buf","bufsize","qualifier"), 0;
002159  002398  // Syntax: com2_Init(buffer, bufsize, qualifier);
002160  002399  // Usage1: com2_Init(mybuf, 20, 0);
002161  002400  // Usage2: com2_Init(mybuf, 20, ':');
002162  002401  // Notes : initialize a serial capture buffer for the comms input
002163  002402  //       : The program must declare a var array as a circular buffer.
002164  002403  //       : Usage1 declares a circular buffer which will continually
002165  002404  //       : buffer characters.
002166  002405  //       : Usage2 must receive ':' before any characters will
002167  002406  //       : accumulate in the buffer.
002168  002407        
002169  002408  func com3_Init("buf","bufsize","qualifier"), 0;
002170  002409  // Syntax: com3_Init(buffer, bufsize, qualifier);
002171  002410  // Usage1: com3_Init(mybuf, 20, 0);
002172  002411  // Usage2: com3_Init(mybuf, 20, ':');
002173  002412  // Notes : initialize a serial capture buffer for the comms input
002174  002413  //       : The program must declare a var array as a circular buffer.
002175  002414  //       : Usage1 declares a circular buffer which will continually
002176  002415  //       : buffer characters.
002177  002416  //       : Usage2 must receive ':' before any characters will
002178  002417  //       : accumulate in the buffer.
002179  002418        
002180  002419        
002181  002420  func serin(), 1;                // read a byte from primary com port COM0
002182  002421  // Syntax: serin();
002183  002422  // Usage : char := serin();
002184  002423  // Notes : Receives a character from the Serial Port COM0. The transmission format is:
002185  002424  //     : No Parity, 1 Stop Bit, 8 Data Bits (N,8,1).
002186  002425  //     : The default Baud Rate for COM0 is 115,200 bits per second or 115,200 baud.
002187  002426  //     : The baud rate can be changed under program control by using the setbaud(...)
002188  002427  //     : or the com_SetBaud(...) function.
002189  002428  //     : COM0 pins cannot be mapped, and are fixed as pins 42 and 33 (host adaptor / programming)
002190  002429  //     : serin may be buffered (refer to com_Init function above)
002191  002430  //     : Returns: -1 if no character is available
002192  002431  //     : Returns: -2 if a framing error or over-run has occurred (auto cleared)
002193  002432  //     : Returns: positive value 0 to 255 for a valid character received
002194  002433        
002195  002434  func serin1(), 1;
002196  002435  // Syntax: serinx();
002197  002436  // Usage : char := serinx();
002198  002437  // Notes : Receives a character from Serial Port COMx. The transmission format is:
002199  002438  //     : No Parity, 1 Stop Bit, 8 Data Bits (N,8,1).
002200  002439  //     : The default Baud Rate for COM1, COM2 and COM3 is 9600 baud.
002201  002440  //     : The baud rate can be changed under program control by using the com_SetBaud(...) function.
002202  002441  //     : serinx may be buffered (refer to comx_Init function above)
002203  002442  //     : serin RX pins must be mapped before use, (refer to COMx_RX_pin functions above)
002204  002443  //     : Returns: -1 if no character is available
002205  002444  //     : Returns: -2 if a framing error or over-run has occurred (auto cleared)
002206  002445  //     : Returns: positive value 0 to 255 for a valid character received
002207  002446        
002208  002447  func serin2(), 1;
002209  002448  // Syntax: serinx();
002210  002449  // Usage : char := serinx();
002211  002450  // Notes : Receives a character from Serial Port COMx. The transmission format is:
002212  002451  //     : No Parity, 1 Stop Bit, 8 Data Bits (N,8,1).
002213  002452  //     : The default Baud Rate for COM1, COM2 and COM3 is 9600 baud.
002214  002453  //     : The baud rate can be changed under program control by using the com_SetBaud(...) function.
002215  002454  //     : serinx may be buffered (refer to comx_Init function above)
002216  002455  //     : serin RX pins must be mapped before use, (refer to COMx_RX_pin functions above)
002217  002456  //     : Returns: -1 if no character is available
002218  002457  //     : Returns: -2 if a framing error or over-run has occurred (auto cleared)
002219  002458  //     : Returns: positive value 0 to 255 for a valid character received
002220  002459        
002221  002460  func serin3(), 1;
002222  002461  // Syntax: serinx();
002223  002462  // Usage : char := serinx();
002224  002463  // Notes : Receives a character from Serial Port COMx. The transmission format is:
002225  002464  //     : No Parity, 1 Stop Bit, 8 Data Bits (N,8,1).
002226  002465  //     : The default Baud Rate for COM1, COM2 and COM3 is 9600 baud.
002227  002466  //     : The baud rate can be changed under program control by using the com_SetBaud(...) function.
002228  002467  //     : serinx may be buffered (refer to comx_Init function above)
002229  002468  //     : serin RX pins must be mapped before use, (refer to COMx_RX_pin functions above)
002230  002469  //     : Returns: -1 if no character is available
002231  002470  //     : Returns: -2 if a framing error or over-run has occurred (auto cleared)
002232  002471  //     : Returns: positive value 0 to 255 for a valid character received
002233  002472        
002234  002473  func serout("char"), 0;                // write a byte to COM0
002235  002474  // Syntax: serout1("char");
002236  002475  // Usage : serout1(ch);
002237  002476  // Notes : send character to COM0
002238  002477        
002239  002478  func serout1("char"), 0;
002240  002479  // Syntax: seroutx("char");
002241  002480  // Usage : serout1(ch);
002242  002481  // Notes : send character to COMx
002243  002482        
002244  002483  func serout2("char"), 0;
002245  002484  // Syntax: seroutx("char");
002246  002485  // Usage : serout1(ch);
002247  002486  // Notes : send character to COMx
002248  002487        
002249  002488  func serout3("char"), 0;
002250  002489  // Syntax: seroutx("char");
002251  002490  // Usage : serout1(ch);
002252  002491  // Notes : send character to COMx
002253  002492        
002254  002493  func com_Reset(), 0;                 // reset the comms receiver
002255  002494  // Syntax: com_Reset();
002256  002495  // Usage : com_Reset();
002257  002496  // Notes : reset comms to default polled mode
002258  002497        
002259  002498  func com1_Reset(), 0;
002260  002499  // Syntax: com_Reset();
002261  002500  // Usage : com_Reset();
002262  002501  // Notes : reset comms to default polled mode
002263  002502        
002264  002503  func com2_Reset(), 0;
002265  002504  // Syntax: com_Reset();
002266  002505  // Usage : com_Reset();
002267  002506  // Notes : reset comms to default polled mode
002268  002507        
002269  002508  func com3_Reset(), 0;
002270  002509  // Syntax: com_Reset();
002271  002510  // Usage : com_Reset();
002272  002511  // Notes : reset comms to default polled mode
002273  002512        
002274  002513  func com_Count(), 1;                // return count of characters in receive buffer
002275  002514  // Syntax: com_Count();
002276  002515  // Usage : arg := com_Count();
002277  002516  // Notes : return count of buffered characters in buffer attachment
002278  002517        
002279  002518  func com1_Count(), 1;
002280  002519  // Syntax: com_Count();
002281  002520  // Usage : arg := com_Count();
002282  002521  // Notes : return count of buffered characters in buffer attachment
002283  002522        
002284  002523  func com2_Count(), 1;
002285  002524  // Syntax: com_Count();
002286  002525  // Usage : arg := com_Count();
002287  002526  // Notes : return count of buffered characters in buffer attachment
002288  002527        
002289  002528  func com3_Count(), 1;
002290  002529  // Syntax: com_Count();
002291  002530  // Usage : arg := com_Count();
002292  002531  // Notes : return count of buffered characters in buffer attachment
002293  002532        
002294  002533  func com_Full(), 1;                // return TRUE if receiver buffer filled to capcity
002295  002534  // Syntax: com_Full();
002296  002535  // Usage : if (com_Full() ,,,, go read buffer;
002297  002536  // Notes : return true if buffer full (not necessarily an error if
002298  002537  //       : buffer is sized to a packet size)
002299  002538        
002300  002539  func com1_Full(), 1;
002301  002540  // Syntax: com_Full();
002302  002541  // Usage : if (com_Full() ,,,, go read buffer;
002303  002542  // Notes : return true if buffer full (not necessarily an error if
002304  002543  //       : buffer is sized to a packet size)
002305  002544        
002306  002545  func com2_Full(), 1;
002307  002546  // Syntax: com_Full();
002308  002547  // Usage : if (com_Full() ,,,, go read buffer;
002309  002548  // Notes : return true if buffer full (not necessarily an error if
002310  002549  //       : buffer is sized to a packet size)
002311  002550        
002312  002551  func com3_Full(), 1;
002313  002552  // Syntax: com_Full();
002314  002553  // Usage : if (com_Full() ,,,, go read buffer;
002315  002554  // Notes : return true if buffer full (not necessarily an error if
002316  002555  //       : buffer is sized to a packet size)
002317  002556        
002318  002557  func com_Error(), 1;                // return comms errors comms error occurred
002319  002558  // Syntax: comx_Error();
002320  002559  // Usage : if (com_Error() ) ...... take recovery action;
002321  002560  // Notes : return non zero if any errors low level comms errors occured
002322  002561  // returns :
002323  002562  // bit0 = Receiver Overflow Error
002324  002563  // bit1 = Receiver Framing Error
002325  002564  // bit2 = Transmit Buffer Overflow
002326  002565        
002327  002566  func com1_Error(), 1;
002328  002567  // Syntax: comx_Error();
002329  002568  // Usage : if (com_Error() ) ...... take recovery action;
002330  002569  // Notes : return non zero if any errors low level comms errors occured
002331  002570  // returns :
002332  002571  // bit0 = Receiver Overflow Error
002333  002572  // bit1 = Receiver Framing Error
002334  002573  // bit2 = Transmit Buffer Overflow
002335  002574        
002336  002575  func com2_Error(), 1;
002337  002576  // Syntax: comx_Error();
002338  002577  // Usage : if (com_Error() ) ...... take recovery action;
002339  002578  // Notes : return non zero if any errors low level comms errors occured
002340  002579  // returns :
002341  002580  // bit0 = Receiver Overflow Error
002342  002581  // bit1 = Receiver Framing Error
002343  002582  // bit2 = Transmit Buffer Overflow
002344  002583        
002345  002584  func com3_Error(), 1;
002346  002585  // Syntax: comx_Error();
002347  002586  // Usage : if (com_Error() ) ...... take recovery action;
002348  002587  // Notes : return non zero if any errors low level comms errors occured
002349  002588  // returns :
002350  002589  // bit0 = Receiver Overflow Error
002351  002590  // bit1 = Receiver Framing Error
002352  002591  // bit2 = Transmit Buffer Overflow
002353  002592        
002354  002593  func com_Sync(), 1;                // returns TRUE if qualifier has been received
002355  002594  // Usage : comx_Sync();
002356  002595  // return true if sync character has been received in com_Init("...") mode
002357  002596        
002358  002597  func com1_Sync(), 1;
002359  002598  // Usage : comx_Sync();
002360  002599  // return true if sync character has been received in com_Init("...") mode
002361  002600        
002362  002601  func com2_Sync(), 1;
002363  002602  // Usage : comx_Sync();
002364  002603  // return true if sync character has been received in com_Init("...") mode
002365  002604        
002366  002605  func com3_Sync(), 1;
002367  002606  // Usage : comx_Sync();
002368  002607  // return true if sync character has been received in com_Init("...") mode
002369  002608        
002370  002609        
002371  002610  func com_TXbuffer("buf", "bufsize", "pin"), 0;    // sets the buffer location for buffered transmission
002372  002611  // Usage : com_TXbuffer(mybuf, 1024, PA0);    // set the TX buffer, using PA0 for turnaround
002373  002612  // Usage : com_TXbuffer(0, 0, 0);             // revert to non buffered service
002374  002613  // Notes : initialize a serial buffer for the COM0 output.
002375  002614  //       : The program must declare a var array as a circular buffer.
002376  002615  //       : When a TX buffer is declared for comms, the transmission
002377  002616  //       : of characters becomes non blocking. If the buffer has
002378  002617  //       : insufficient space to accept the next character from a
002379  002618  //       : serout_x() function, the excess characters will be ignored,
002380  002619  //       : and the com_Full_x() error will be asserted.   If the
002381  002620  //       : TX buffer is no longer required, just set the buffer pointer
002382  002621  //       : to zero, the size in this case doesnt matter and is ignored.
002383  002622  //       : The function can resize or reallocated to another buffer at
002384  002623  //       : any time. The buffer is flushed before any changes are made.
002385  002624  //       : "pin" designates an IO pin to control a bi-directional
002386  002625  //       : control device for half duplex mode. "pin" will go HI at the
002387  002626  //       : start of a transmission, and will return low after the final
002388  002627  //       : byte is transmitted. If not required, just set "pin" to zero.
002389  002628        
002390  002629  func com1_TXbuffer("buf", "bufsize", "pin"), 0;
002391  002630  // Usage : com1_TXbuffer(mybuf, 1024, PA0);    // set the TX buffer, using PA0 for turnaround
002392  002631  // Usage : com1_TXbuffer(0, 0, 0);              // revert to non buffered service
002393  002632  // Notes : initialize a serial buffer for the COM0 output.
002394  002633  //       : The program must declare a var array as a circular buffer.
002395  002634  //       : When a TX buffer is declared for comms, the transmission
002396  002635  //       : of characters becomes non blocking. If the buffer has
002397  002636  //       : insufficient space to accept the next character from a
002398  002637  //       : serout_x() function, the excess characters will be ignored,
002399  002638  //       : and the com_Full_x() error will be asserted.   If the
002400  002639  //       : TX buffer is no longer required, just set the buffer pointer
002401  002640  //       : to zero, the size in this case doesnt matter and is ignored.
002402  002641  //       : The function can resize or reallocated to another buffer at
002403  002642  //       : any time. The buffer is flushed before any changes are made.
002404  002643  //       : "pin" designates an IO pin to control a bi-directional
002405  002644  //       : control device for half duplex mode. "pin" will go HI at the
002406  002645  //       : start of a transmission, and will return low after the final
002407  002646  //       : byte is transmitted. If not required, just set "pin" to zero.
002408  002647        
002409  002648  func com2_TXbuffer("buf", "bufsize", "pin"), 0;
002410  002649  // Usage : com2_TXbuffer(mybuf, 1024, PA0);    // set the TX buffer, using PA0 for turnaround
002411  002650  // Usage : com2_TXbuffer(0, 0, 0);              // revert to non buffered service
002412  002651  // Notes : initialize a serial buffer for the COM0 output.
002413  002652  //       : The program must declare a var array as a circular buffer.
002414  002653  //       : When a TX buffer is declared for comms, the transmission
002415  002654  //       : of characters becomes non blocking. If the buffer has
002416  002655  //       : insufficient space to accept the next character from a
002417  002656  //       : serout_x() function, the excess characters will be ignored,
002418  002657  //       : and the com_Full_x() error will be asserted.   If the
002419  002658  //       : TX buffer is no longer required, just set the buffer pointer
002420  002659  //       : to zero, the size in this case doesnt matter and is ignored.
002421  002660  //       : The function can resize or reallocated to another buffer at
002422  002661  //       : any time. The buffer is flushed before any changes are made.
002423  002662  //       : "pin" designates an IO pin to control a bi-directional
002424  002663  //       : control device for half duplex mode. "pin" will go HI at the
002425  002664  //       : start of a transmission, and will return low after the final
002426  002665  //       : byte is transmitted. If not required, just set "pin" to zero.
002427  002666        
002428  002667  func com3_TXbuffer("buf", "bufsize", "pin"), 0;
002429  002668  // Usage : com3_TXbuffer(mybuf, 1024, PA0);    // set the TX buffer, using PA0 for turnaround
002430  002669  // Usage : com3_TXbuffer(0, 0, 0);              // revert to non buffered service
002431  002670  // Notes : initialize a serial buffer for the COM0 output.
002432  002671  //       : The program must declare a var array as a circular buffer.
002433  002672  //       : When a TX buffer is declared for comms, the transmission
002434  002673  //       : of characters becomes non blocking. If the buffer has
002435  002674  //       : insufficient space to accept the next character from a
002436  002675  //       : serout_x() function, the excess characters will be ignored,
002437  002676  //       : and the com_Full_x() error will be asserted.   If the
002438  002677  //       : TX buffer is no longer required, just set the buffer pointer
002439  002678  //       : to zero, the size in this case doesnt matter and is ignored.
002440  002679  //       : The function can resize or reallocated to another buffer at
002441  002680  //       : any time. The buffer is flushed before any changes are made.
002442  002681  //       : "pin" designates an IO pin to control a bi-directional
002443  002682  //       : control device for half duplex mode. "pin" will go HI at the
002444  002683  //       : start of a transmission, and will return low after the final
002445  002684  //       : byte is transmitted. If not required, just set "pin" to zero.
002446  002685        
002447  002686        
002448  002687  func com_TXcount(), 1;                // return count of characters in COM0 TX buffer
002449  002688  // Syntax: com_TXcount();
002450  002689  // Usage : arg := com_Count();
002451  002690  // Notes : return count of characters remaining in COM0 transmit buffer
002452  002691  //       : that was previously allocated with com_TXbuffer(...);
002453  002692        
002454  002693  func com1_TXcount(), 1;
002455  002694  // Syntax: com_TXcount();
002456  002695  // Usage : arg := com_Count();
002457  002696  // Notes : return count of characters remaining in COM0 transmit buffer
002458  002697  //       : that was previously allocated with com_TXbuffer(...);
002459  002698        
002460  002699  func com2_TXcount(), 1;
002461  002700  // Syntax: com_TXcount();
002462  002701  // Usage : arg := com_Count();
002463  002702  // Notes : return count of characters remaining in COM0 transmit buffer
002464  002703  //       : that was previously allocated with com_TXbuffer(...);
002465  002704        
002466  002705  func com3_TXcount(), 1;
002467  002706  // Syntax: com_TXcount();
002468  002707  // Usage : arg := com_Count();
002469  002708  // Notes : return count of characters remaining in COM0 transmit buffer
002470  002709  //       : that was previously allocated with com_TXbuffer(...);
002471  002710        
002472  002711  func com_TXemptyEvent("function"), 1;  // sets a function to be called when COM0 TX buffer empty
002473  002712  // Usage : arg := com_TXemptyEvent();
002474  002713  // Notes : If a comms TX buffer that was previously allocated with
002475  002714  //       : com_TXbuffer(...);, this function can be used to set up
002476  002715  //       : a function to be called when the COM0 TX buffer is empty.
002477  002716  //       : This is useful for either reloading the TX buffer, setting
002478  002717  //       : or clearing a pin to change the direction of eg a RS485
002479  002718  //       : line driver, or any other form of traffic control.
002480  002719  //       : The event function must not have any parameters.
002481  002720  //       : To disable the event, simply call com_TXemptyEvent(0).
002482  002721  //       : com_TXbuffer(...); also resets any active event.
002483  002722  //       : com_TXemptyEvent returns any previous event function
002484  002723  //       : address, or zero if there was no previous function.
002485  002724        
002486  002725  func com1_TXemptyEvent("function"), 1;
002487  002726  // Usage : arg := com1_TXemptyEvent();
002488  002727  // Notes : If a comms TX buffer that was previously allocated with
002489  002728  //       : com_TXbuffer(...);, this function can be used to set up
002490  002729  //       : a function to be called when the COM0 TX buffer is empty.
002491  002730  //       : This is useful for either reloading the TX buffer, setting
002492  002731  //       : or clearing a pin to change the direction of eg a RS485
002493  002732  //       : line driver, or any other form of traffic control.
002494  002733  //       : The event function must not have any parameters.
002495  002734  //       : To disable the event, simply call com_TXemptyEvent(0).
002496  002735  //       : com_TXbuffer(...); also resets any active event.
002497  002736  //       : com_TXemptyEvent returns any previous event function
002498  002737  //       : address, or zero if there was no previous function.
002499  002738        
002500  002739  func com2_TXemptyEvent("function"), 1;
002501  002740  // Usage : arg := com2_TXemptyEvent();
002502  002741  // Notes : If a comms TX buffer that was previously allocated with
002503  002742  //       : com_TXbuffer(...);, this function can be used to set up
002504  002743  //       : a function to be called when the COM0 TX buffer is empty.
002505  002744  //       : This is useful for either reloading the TX buffer, setting
002506  002745  //       : or clearing a pin to change the direction of eg a RS485
002507  002746  //       : line driver, or any other form of traffic control.
002508  002747  //       : The event function must not have any parameters.
002509  002748  //       : To disable the event, simply call com_TXemptyEvent(0).
002510  002749  //       : com_TXbuffer(...); also resets any active event.
002511  002750  //       : com_TXemptyEvent returns any previous event function
002512  002751  //       : address, or zero if there was no previous function.
002513  002752        
002514  002753  func com3_TXemptyEvent("function"), 1;
002515  002754  // Usage : arg := com3_TXemptyEvent();
002516  002755  // Notes : If a comms TX buffer that was previously allocated with
002517  002756  //       : com_TXbuffer(...);, this function can be used to set up
002518  002757  //       : a function to be called when the COM0 TX buffer is empty.
002519  002758  //       : This is useful for either reloading the TX buffer, setting
002520  002759  //       : or clearing a pin to change the direction of eg a RS485
002521  002760  //       : line driver, or any other form of traffic control.
002522  002761  //       : The event function must not have any parameters.
002523  002762  //       : To disable the event, simply call com_TXemptyEvent(0).
002524  002763  //       : com_TXbuffer(...); also resets any active event.
002525  002764  //       : com_TXemptyEvent returns any previous event function
002526  002765  //       : address, or zero if there was no previous function.
002527  002766        
002528  002767  func com_TXbufferHold("state"), 1; // hold or release a com_TXbuffer
002529  002768  // Usage : arg := com_TXbufferHold(OFF);  // start sending the buffer
002530  002769  // Notes : Expecting that a comms TX buffer that was previously allocated with
002531  002770  //       : com_TXbuffer(...);, com_TXbufferHold(ON) can be used to stop
002532  002771  //       : the buffer being sent wile it is being loaded. Mormally, when
002533  002772  //       : using buffered comms, the transmit process will begin
002534  002773  //       : immediately. This is often undesirable for 2 reasons,
002535  002774  //       : 1] you may wish to build a packet then send it later
002536  002775  //       : 2] when using com_TXemptyEvent erroneous empty events will occur
002537  002776  //       : as the FIFO buffer is constantly trying to empty while
002538  002777  //       : you are busy tring to fill it.
002539  002778  // return -1 if function is called illegally when TX comms is not buffered.
002540  002779  // return buffer count when called with argument of 1, eg com_TXbufferHold(ON)
002541  002780  // return 0 when argument is zero, eg com_TXbufferHold(OFF)
002542  002781        
002543  002782  func com1_TXbufferHold("state"), 1;
002544  002783  // Usage : arg := com1_TXbufferHold(OFF);  // start sending the buffer
002545  002784  // Notes : Expecting that a comms TX buffer that was previously allocated with
002546  002785  //       : com_TXbuffer(...);, com_TXbufferHold(ON) can be used to stop
002547  002786  //       : the buffer being sent wile it is being loaded. Mormally, when
002548  002787  //       : using buffered comms, the transmit process will begin
002549  002788  //       : immediately. This is often undesirable for 2 reasons,
002550  002789  //       : 1] you may wish to build a packet then send it later
002551  002790  //       : 2] when using com_TXemptyEvent erroneous empty events will occur
002552  002791  //       : as the FIFO buffer is constantly trying to empty while
002553  002792  //       : you are busy tring to fill it.
002554  002793  // return -1 if function is called illegally when TX comms is not buffered.
002555  002794  // return buffer count when called with argument of 1, eg com_TXbufferHold(ON)
002556  002795  // return 0 when argument is zero, eg com_TXbufferHold(OFF)
002557  002796        
002558  002797  func com2_TXbufferHold("state"), 1;
002559  002798  // Usage : arg := com2_TXbufferHold(OFF);  // start sending the buffer
002560  002799  // Notes : Expecting that a comms TX buffer that was previously allocated with
002561  002800  //       : com_TXbuffer(...);, com_TXbufferHold(ON) can be used to stop
002562  002801  //       : the buffer being sent wile it is being loaded. Mormally, when
002563  002802  //       : using buffered comms, the transmit process will begin
002564  002803  //       : immediately. This is often undesirable for 2 reasons,
002565  002804  //       : 1] you may wish to build a packet then send it later
002566  002805  //       : 2] when using com_TXemptyEvent erroneous empty events will occur
002567  002806  //       : as the FIFO buffer is constantly trying to empty while
002568  002807  //       : you are busy tring to fill it.
002569  002808  // return -1 if function is called illegally when TX comms is not buffered.
002570  002809  // return buffer count when called with argument of 1, eg com_TXbufferHold(ON)
002571  002810  // return 0 when argument is zero, eg com_TXbufferHold(OFF)
002572  002811        
002573  002812  func com3_TXbufferHold("state"), 1;
002574  002813  // Usage : arg := com3_TXbufferHold(OFF);  // start sending the buffer
002575  002814  // Notes : Expecting that a comms TX buffer that was previously allocated with
002576  002815  //       : com_TXbuffer(...);, com_TXbufferHold(ON) can be used to stop
002577  002816  //       : the buffer being sent wile it is being loaded. Mormally, when
002578  002817  //       : using buffered comms, the transmit process will begin
002579  002818  //       : immediately. This is often undesirable for 2 reasons,
002580  002819  //       : 1] you may wish to build a packet then send it later
002581  002820  //       : 2] when using com_TXemptyEvent erroneous empty events will occur
002582  002821  //       : as the FIFO buffer is constantly trying to empty while
002583  002822  //       : you are busy tring to fill it.
002584  002823  // return -1 if function is called illegally when TX comms is not buffered.
002585  002824  // return buffer count when called with argument of 1, eg com_TXbufferHold(ON)
002586  002825  // return 0 when argument is zero, eg com_TXbufferHold(OFF)
002587  002826        
002588  002827  func com_Mode("8" ,"N", "1", "comport"), 1 ;
002589  002828  // Syntax   : comx_Mode("databits", "parity", "Stopbits", "comport");
002590  002829  // Usage    : comx_Mode(8, 'N', 1, COM0);                        // set COM0 to 8N1
002591  002830  // *Notes   : Data Bits must be 8
002592  002831  //          : Parity may be 'N', 'O' or 'E'.
002593  002832  //          : Stop Bits may be 1 or 2.
002594  002833  // returns true if mode was acceptable
002595  002834        
002596  002835  func com_TXblock("buf", "bufsize"), 0;                       // commence a block transmission
002597  002836  // Syntax   : com_TXblock("buf", "bufsize");
002598  002837  // Usage    : com_TXblock(mybuf, 30);                         // point to the TX buffer and send 30 character
002599  002838  // *Notes   : Bufsize bytes are transmitted to the serial port from the string pointer "buf".
002600  002839  //          : if a transmit buffer is active and space is available this function will return almost
002601  002840  //          : immediately otherwise it will block until until the space is available, or the data is transmitted.
002602  002841        
002603  002842  func com_RXblock("buf", "bufsize"), 0;                       // commence a block reception
002604  002843  // Syntax   : com_RXblock("buf", "bufsize");
002605  002844  // Usage    : com_RXblock(mybuf, 30);                        // point to the RX buffer and receive 30 character
002606  002845  // *Notes   : Bufsize bytes are received from the serial port to the string pointer "buf".
002607  002846  //          : if a receive buffer is active and bufsize characters are available this function will return almost
002608  002847  //          : immediately otherwise it will block until until the required bytes are received.
002609  002848        
002610  002849  func __reserved30(), 0; // do not remove
002611  002850        
002612  002851  //------------------------------------------------------------------//
002613  002852  //        Function Prototypes for I2C
002614  002853  //------------------------------------------------------------------//
002615  002854  func I2C1_Open("speed", "SCLpin", "SDApin"), 1;
002616  002855  // Syntax : I2C1_Openx(speed, SCLpin, SDApin),
002617  002856  // Usage  : I2C1_Open(I2C_MED, PA2, PA3);
002618  002857  // Notes  : configures the required I2C module
002619  002858  //        : see 'I2C timing related constants' and 'pin constants'
002620  002859  //        : Pins that can be mapped to SCLpin and SDApin are PA0 to PA13
002621  002860  //        : Pins that can't be mapped to SCLpin or SDApin are PA14 and PA15
002622  002861  //        : For I2C speeds of I2C_MED and I2C_FAST SCLpin may be PA14 and SDApin may be PA15
002623  002862  //        : This is a 'special case' to support Slew rate control for I2C_MED and also properly support I2C_FAST
002624  002863  //        : For other pin combinations I2C_MED does not support Slew rate control and I2C_FAST does not fully run at 1Mhz
002625  002864  // Returns: True if successful
002626  002865        
002627  002866        
002628  002867  func I2C2_Open("speed", "SCLpin", "SDApin"), 1;
002629  002868  // Syntax : I2C2_Openx(speed, SCLpin, SDApin),
002630  002869  // Usage  : I2C2_Open(I2C_MED, PA2, PA3);
002631  002870  // Notes  : configures the required I2C module
002632  002871  //        : see 'I2C timing related constants' and 'pin constants'
002633  002872  //        : Pins that can be mapped to SCLpin and SDApin are PA0 to PA13
002634  002873  //        : Pins that can't be mapped to SCLpin or SDApin are PA14 and PA15
002635  002874  //        : For I2C speeds of I2C_MED and I2C_FAST SCLpin may be PA14 and SDApin may be PA15
002636  002875  //        : This is a 'special case' to support Slew rate control for I2C_MED and also properly support I2C_FAST
002637  002876  //        : For other pin combinations I2C_MED does not support Slew rate control and I2C_FAST does not fully run at 1Mhz
002638  002877  // Returns: True if successful
002639  002878        
002640  002879        
002641  002880  func I2C3_Open("speed", "SCLpin", "SDApin"), 1;
002642  002881  // Syntax : I2C3_Openx(speed, SCLpin, SDApin),
002643  002882  // Usage  : I2C3_Open(I2C_MED, PA2, PA3);
002644  002883  // Notes  : configures the required I2C module
002645  002884  //        : see 'I2C timing related constants' and 'pin constants'
002646  002885  //        : Pins that can be mapped to SCLpin and SDApin are PA0 to PA13
002647  002886  //        : Pins that can't be mapped to SCLpin or SDApin are PA14 and PA15
002648  002887  //        : For I2C speeds of I2C_MED and I2C_FAST SCLpin may be PA14 and SDApin may be PA15
002649  002888  //        : This is a 'special case' to support Slew rate control for I2C_MED and also properly support I2C_FAST
002650  002889  //        : For other pin combinations I2C_MED does not support Slew rate control and I2C_FAST does not fully run at 1Mhz
002651  002890  // Returns: True if successful
002652  002891        
002653  002892        
002654  002893  func I2C1_Close(), 0;
002655  002894  // Usage : I2C1_Close();
002656  002895  // Notes : disables the I2C1 module.
002657  002896        
002658  002897  func I2C2_Close(), 0;
002659  002898  // Usage : I2C2_Close();
002660  002899  // Notes : disables the I2C2 module.
002661  002900        
002662  002901  func I2C3_Close(), 0;
002663  002902  // Usage : I2C3_Close();
002664  002903  // Notes : disables the I2C3 module.
002665  002904        
002666  002905  func I2C1_Start(), 1;
002667  002906  // Syntax: I2C1_Start();
002668  002907  // Usage : I2C1_Start();
002669  002908  // Notes : generates a Start condition.
002670  002909  //       : returns true if successful (usually ignored)
002671  002910        
002672  002911  func I2C2_Start(), 1;
002673  002912  // Syntax: I2C2_Start();
002674  002913  // Usage : I2C2_Start();
002675  002914  // Notes : generates a Start condition.
002676  002915  //       : returns true if successful (usually ignored)
002677  002916        
002678  002917  func I2C3_Start(), 1;
002679  002918  // Syntax: I2C3_Start();
002680  002919  // Usage : I2C3_Start();
002681  002920  // Notes : generates a Start condition.
002682  002921  //       : returns true if successful (usually ignored)
002683  002922        
002684  002923  func I2C1_Stop(), 1;
002685  002924  // Syntax: I2C1_Stop();
002686  002925  // Usage : I2C1_Stop();
002687  002926  // Notes : generates a Stop condition.
002688  002927  //       : returns true if successful (usually ignored)
002689  002928        
002690  002929  func I2C2_Stop(), 1;
002691  002930  // Syntax: I2C2_Stop();
002692  002931  // Usage : I2C2_Stop();
002693  002932  // Notes : generates a Stop condition.
002694  002933  //       : returns true if successful (usually ignored)
002695  002934        
002696  002935  func I2C3_Stop(), 1;
002697  002936  // Syntax: I2C3_Stop();
002698  002937  // Usage : I2C3_Stop();
002699  002938  // Notes : generates a Stop condition.
002700  002939  //       : returns true if successful (usually ignored)
002701  002940        
002702  002941  func I2C1_Restart(), 1;
002703  002942  // Syntax: I2C1_Restart();
002704  002943  // Usage : I2C1_Restart();
002705  002944  // Notes : generates a Restart condition.
002706  002945  //       : returns true if successful (usually ignored)
002707  002946        
002708  002947  func I2C2_Restart(), 1;
002709  002948  // Syntax: I2C2_Restart();
002710  002949  // Usage : I2C2_Restart();
002711  002950  // Notes : generates a Restart condition.
002712  002951  //       : returns true if successful (usually ignored)
002713  002952        
002714  002953  func I2C3_Restart(), 1;
002715  002954  // Syntax: I2C3_Restart();
002716  002955  // Usage : I2C3_Restart();
002717  002956  // Notes : generates a Restart condition.
002718  002957  //       : returns true if successful (usually ignored)
002719  002958        
002720  002959  func I2C1_Read(), 1;
002721  002960  // Syntax: I2C1_Read();
002722  002961  // Usage : ch := I2C1_Read();
002723  002962  // Notes : reads a single byte from the I2C Bus.
002724  002963        
002725  002964  func I2C2_Read(), 1;
002726  002965  // Syntax: I2C2_Read();
002727  002966  // Usage : ch := I2C2_Read();
002728  002967  // Notes : reads a single byte from the I2C Bus.
002729  002968        
002730  002969  func I2C3_Read(), 1;
002731  002970  // Syntax: I2C3_Read();
002732  002971  // Usage : ch := I2C3_Read();
002733  002972  // Notes : reads a single byte from the I2C Bus.
002734  002973        
002735  002974  func I2C1_Write("byte"), 1;
002736  002975  // Syntax: I2C1_Write(byte);
002737  002976  // Usage : r := I2C1_Write(ch);
002738  002977  // Notes : is used to write a byte to the I2C bus.
002739  002978  //       : Returns 0 if failed, 1 if no ack, 2 if ack
002740  002979        
002741  002980  func I2C2_Write("byte"), 1;
002742  002981  // Syntax: I2C2_Write(byte);
002743  002982  // Usage : r := I2C2_Write(ch);
002744  002983  // Notes : is used to write a byte to the I2C bus.
002745  002984  //       : Returns 0 if failed, 1 if no ack, 2 if ack
002746  002985        
002747  002986  func I2C3_Write("byte"), 1;
002748  002987  // Syntax: I2C3_Write(byte);
002749  002988  // Usage : r := I2C3_Write(ch);
002750  002989  // Notes : is used to write a byte to the I2C bus.
002751  002990  //       : Returns 0 if failed, 1 if no ack, 2 if ack
002752  002991        
002753  002992  func I2C1_Ack(), 0;
002754  002993  // Syntax: I2C1_Ack();
002755  002994  // Usage : I2C1_Ack();
002756  002995  // Notes : generates the acknowledge condition.
002757  002996        
002758  002997  func I2C2_Ack(), 0;
002759  002998  // Syntax: I2C2_Ack();
002760  002999  // Usage : I2C2_Ack();
002761  003000  // Notes : generates the acknowledge condition.
002762  003001        
002763  003002  func I2C3_Ack(), 0;
002764  003003  // Syntax: I2C3_Ack();
002765  003004  // Usage : I2C3_Ack();
002766  003005  // Notes : generates the acknowledge condition.
002767  003006        
002768  003007  func I2C1_Nack(), 0;
002769  003008  // Syntax: I2C1_Nack();
002770  003009  // Usage : I2C1_Nack();
002771  003010  // Notes : generates the negative acknowledge condition.
002772  003011        
002773  003012  func I2C2_Nack(), 0;
002774  003013  // Syntax: I2C2_Nack();
002775  003014  // Usage : I2C2_Nack();
002776  003015  // Notes : generates the negative acknowledge condition.
002777  003016        
002778  003017  func I2C3_Nack(), 0;
002779  003018  // Syntax: I2C3_Nack();
002780  003019  // Usage : I2C3_Nack();
002781  003020  // Notes : generates the negative acknowledge condition.
002782  003021        
002783  003022  func I2C1_AckStatus(), 1;
002784  003023  // Syntax: I2C1_AckStatus();
002785  003024  // Usage : r := I2C1_AckStatus();
002786  003025  // Notes : returns the ACK status from the device.
002787  003026        
002788  003027  func I2C2_AckStatus(), 1;
002789  003028  // Syntax: I2C2_AckStatus();
002790  003029  // Usage : r := I2C2_AckStatus();
002791  003030  // Notes : returns the ACK status from the device.
002792  003031        
002793  003032  func I2C3_AckStatus(), 1;
002794  003033  // Syntax: I2C3_AckStatus();
002795  003034  // Usage : r := I2C3_AckStatus();
002796  003035  // Notes : returns the ACK status from the device.
002797  003036        
002798  003037  func I2C1_AckPoll("control"), 1;
002799  003038  // Syntax: I2C1_AckPoll();
002800  003039  // Usage : r := I2C1_AckPoll(0xA0);
002801  003040  // Notes : waits for a device to return from ACK polling.
002802  003041        
002803  003042  func I2C2_AckPoll("control"), 1;
002804  003043  // Syntax: I2C2_AckPoll();
002805  003044  // Usage : r := I2C2_AckPoll(0xA0);
002806  003045  // Notes : waits for a device to return from ACK polling.
002807  003046        
002808  003047  func I2C3_AckPoll("control"), 1;
002809  003048  // Syntax: I2C3_AckPoll();
002810  003049  // Usage : r := I2C3_AckPoll(0xA0);
002811  003050  // Notes : waits for a device to return from ACK polling.
002812  003051        
002813  003052  func I2C1_Idle(), 1;
002814  003053  // Syntax : I2C1_Idle();
002815  003054  // Usage  : r := I2C1_Idle();
002816  003055  // Notes  : waits until the I2C Bus is Inactive.
002817  003056  //        : Times out if bus not idle within 1 second
002818  003057  // Returns: TRUE if successful, else failed (timed out)
002819  003058        
002820  003059  func I2C2_Idle(), 1;
002821  003060  // Syntax : I2C2_Idle();
002822  003061  // Usage  : r := I2C2_Idle();
002823  003062  // Notes  : waits until the I2C Bus is Inactive.
002824  003063  //        : Times out if bus not idle within 1 second
002825  003064  // Returns: TRUE if successful, else failed (timed out)
002826  003065        
002827  003066  func I2C3_Idle(), 1;
002828  003067  // Syntax : I2C3_Idle();
002829  003068  // Usage  : r := I2C3_Idle();
002830  003069  // Notes  : waits until the I2C Bus is Inactive.
002831  003070  //        : Times out if bus not idle within 1 second
002832  003071  // Returns: TRUE if successful, else failed (timed out)
002833  003072        
002834  003073        
002835  003074  func I2C1_Gets("buffer", "size"), 1;
002836  003075  // Syntax: I2C1_Gets("buffer", "size");
002837  003076  // Usage : r := I2C1_Gets(mybuf, 16);
002838  003077  // Notes : only reads up to "size" characters into "buffer"
002839  003078  //       : Reads up to asciiz terminator including terminator
002840  003079        
002841  003080  func I2C2_Gets("buffer", "size"), 1;
002842  003081  // Syntax: I2C2_Gets("buffer", "size");
002843  003082  // Usage : r := I2C2_Gets(mybuf, 16);
002844  003083  // Notes : only reads up to "size" characters into "buffer"
002845  003084  //       : Reads up to asciiz terminator including terminator
002846  003085        
002847  003086  func I2C3_Gets("buffer", "size"), 1;
002848  003087  // Syntax: I2C3_Gets("buffer", "size");
002849  003088  // Usage : r := I2C3_Gets(mybuf, 16);
002850  003089  // Notes : only reads up to "size" characters into "buffer"
002851  003090  //       : Reads up to asciiz terminator including terminator
002852  003091        
002853  003092  func I2C1_Getn("buffer", "size"), 1;
002854  003093  // Syntax: I2C1_Gets("buffer", "size");
002855  003094  // Usage : r := I2C1_Gets(mybuf, 16);
002856  003095  // Notes : reads "size" bytes into "buffer"
002857  003096  //       :
002858  003097        
002859  003098  func I2C2_Getn("buffer", "size"), 1;
002860  003099  // Syntax: I2C2_Gets("buffer", "size");
002861  003100  // Usage : r := I2C2_Gets(mybuf, 16);
002862  003101  // Notes : reads "size" bytes into "buffer"
002863  003102  //       :
002864  003103        
002865  003104  func I2C3_Getn("buffer", "size"), 1;
002866  003105  // Syntax: I2C3_Gets("buffer", "size");
002867  003106  // Usage : r := I2C3_Gets(mybuf, 16);
002868  003107  // Notes : reads "size" bytes into "buffer"
002869  003108  //       :
002870  003109        
002871  003110  func I2C1_Puts("buffer"), 1;
002872  003111  // Syntax: I2C1_Puts("buffer");
002873  003112  // Usage : r := I2C1_Puts(mybuf);
002874  003113  // Notes : writes an asciiz string to the I2C device
002875  003114  //       : returns count of characters written
002876  003115        
002877  003116  func I2C2_Puts("buffer"), 1;
002878  003117  // Syntax: I2C2_Puts("buffer");
002879  003118  // Usage : r := I2C2_Puts(mybuf);
002880  003119  // Notes : writes an asciiz string to the I2C device
002881  003120  //       : returns count of characters written
002882  003121        
002883  003122  func I2C3_Puts("buffer"), 1;
002884  003123  // Syntax: I2C3_Puts("buffer");
002885  003124  // Usage : r := I2C3_Puts(mybuf);
002886  003125  // Notes : writes an asciiz string to the I2C device
002887  003126  //       : returns count of characters written
002888  003127        
002889  003128  func I2C1_Putn("buffer", "count"), 1;
002890  003129  // Syntax: I2C1_Putn("buffer","count");
002891  003130  // Usage : r := I2C1_Puts(mybuf,10);
002892  003131  // Notes : writes up to "size" bytes to the I2C device
002893  003132  //       : returns number of bytes written
002894  003133        
002895  003134  func I2C2_Putn("buffer", "count"), 1;
002896  003135  // Syntax: I2C2_Putn("buffer","count");
002897  003136  // Usage : r := I2C2_Puts(mybuf,10);
002898  003137  // Notes : writes up to "size" bytes to the I2C device
002899  003138  //       : returns number of bytes written
002900  003139        
002901  003140  func I2C3_Putn("buffer", "count"), 1;
002902  003141  // Syntax: I2C3_Putn("buffer","count");
002903  003142  // Usage : r := I2C3_Puts(mybuf,10);
002904  003143  // Notes : writes up to "size" bytes to the I2C device
002905  003144  //       : returns number of bytes written
002906  003145        
002907  003146        
002908  003147  func spi_ReadBlock("buf", "bufsize"), 0;                       // commence a block reception
002909  003148  // Syntax   : spi_ReadBlock("buf", "bufsize");
002910  003149  // Usage    : spi_ReadBlock(mybuf, 30);                        // point to the buffer and read 30 characters
002911  003150  // *Notes   : Bufsize bytes are read from the SPI port to the string pointer "buf".
002912  003151        
002913  003152  func spi1_ReadBlock("buf", "bufsize"), 0;                       // commence a block reception
002914  003153  // Syntax   : spi1_ReadBlock("buf", "bufsize");
002915  003154  // Usage    : spi1_ReadBlock(mybuf, 30);                        // point to the buffer and read 30 characters
002916  003155  // *Notes   : Bufsize bytes are read from the SPI port to the string pointer "buf".
002917  003156        
002918  003157  func spi2_ReadBlock("buf", "bufsize"), 0;                       // commence a block reception
002919  003158  // Syntax   : spi2_ReadBlock("buf", "bufsize");
002920  003159  // Usage    : spi2_ReadBlock(mybuf, 30);                        // point to the buffer and read 30 characters
002921  003160  // *Notes   : Bufsize bytes are read from the SPI port to the string pointer "buf".
002922  003161        
002923  003162  func spi3_ReadBlock("buf", "bufsize"), 0;                       // commence a block reception
002924  003163  // Syntax   : spi3_ReadBlock("buf", "bufsize");
002925  003164  // Usage    : spi3_ReadBlock(mybuf, 30);                        // point to the buffer and read 30 characters
002926  003165  // *Notes   : Bufsize bytes are read from the SPI port to the string pointer "buf".
002927  003166        
002928  003167  // I2C timing related constants
002929  003168  #CONST
002930  003176  #END
002931  003177        
002932  003178        
002933  003179        
002934  003180  //------------------------------------------------------------------//
002935  003181  // Direct uSD (SPI0) card SPI functions                             //
002936  003182  //------------------------------------------------------------------//
002937  003183  func spi_Init("speed","ip_mode","op_mode"), 0;  // set the SPI port, not used if uSD active
002938  003184  func spi_Read(), 1;                             // read a raw byte from SPI (lowers CS)
002939  003185  func spi_Write("byte"), 0;                      // write a raw byte to SPI (lowers CS)
002940  003186  func spi_Disable(), 0;                          // disable SPI reading or writing (raise CS)
002941  003187                                                  //
002942  003188        
002943  003189  //------------------------------------------------------------------//
002944  003190  // Function prototypes for SPI1, SPI2 and SPI3                      //
002945  003191  //------------------------------------------------------------------//
002946  003192  func SPI1_SDO_pin("pin"), 1;                // select the hardware pin for SPI1 transmit line
002947  003193  // Syntax: SPI_SDO_pin(pin);
002948  003194  // Usage : SPI_SDO_pin(PA1); // set SPI SDO to PA1 pin
002949  003195  // Notes : Select the hardware pin for SPIx transmit line.
002950  003196  //       : Note that multiple pins can be connected simmultaneously.
002951  003197  //       : Pins that can be mapped to SPIx TX are PA1, PA3 to PA9, PA12 or PA13
002952  003198  //       : Pins that can't be mapped to SPIx SDO are PA0, PA2, PA10, PA11, PA14 and PA15
002953  003199  //       : If the pin argument is 0, SPIx SDO is disconnected from all pins.
002954  003200  //       : The pin is automatically set to an output.
002955  003201  //       : Returns: Returns TRUE if function succeeded (usually ignored)
002956  003202        
002957  003203  func SPI2_SDO_pin("pin"), 1;                // select the hardware pin for SPI2 transmit line
002958  003204  // Syntax: SPI2_SDO_pin(pin);
002959  003205  // Usage : SPI2_SDO_pin(PA1); // set SPI2 SDO to PA1 pin
002960  003206  // Notes : Select the hardware pin for SPIx transmit line.
002961  003207  //       : Note that multiple pins can be connected simmultaneously.
002962  003208  //       : Pins that can be mapped to SPIx TX are PA1, PA3 to PA9, PA12 or PA13
002963  003209  //       : Pins that can't be mapped to SPIx SDO are PA0, PA2, PA10, PA11, PA14 and PA15
002964  003210  //       : If the pin argument is 0, SPIx SDO is disconnected from all pins.
002965  003211  //       : The pin is automatically set to an output.
002966  003212  //       : Returns: Returns TRUE if function succeeded (usually ignored)
002967  003213        
002968  003214  func SPI3_SDO_pin("pin"), 1;                // select the hardware pin for SPI3 transmit line
002969  003215  // Syntax: SPI3_SDO_pin(pin);
002970  003216  // Usage : SPI3_SDO_pin(PA1); // set SPI3 SDO to PA1 pin
002971  003217  // Notes : Select the hardware pin for SPIx transmit line.
002972  003218  //       : Note that multiple pins can be connected simmultaneously.
002973  003219  //       : Pins that can be mapped to SPIx TX are PA1, PA3 to PA9, PA12 or PA13
002974  003220  //       : Pins that can't be mapped to SPIx SDO are PA0, PA2, PA10, PA11, PA14 and PA15
002975  003221  //       : If the pin argument is 0, SPIx SDO is disconnected from all pins.
002976  003222  //       : The pin is automatically set to an output.
002977  003223  //       : Returns: Returns TRUE if function succeeded (usually ignored)
002978  003224        
002979  003225  func SPI1_SDI_pin("pin"), 1;                // select the hardware pin for SPI1 receive line
002980  003226  // Syntax: SPI1_SDI_pin(pin);
002981  003227  // Usage : SPI1_SDI_pin(PA3); // set SPI1 SDI to PA3 pin
002982  003228  // Notes : Selects the hardware pin for SPIx receive line.
002983  003229  //       : Note that only a single pin can be mapped to SPI SDI.
002984  003230  //       : Pins that can be mapped to SPIx SDI are PA0 to PA13
002985  003231  //       : Pins that can't be mapped to SPIx SDI are PA14 and PA15
002986  003232  //       : If the pin argument is 0 the function has no effect
002987  003233  //       : The pin is automatically set to an input.
002988  003234  //       : If the SPIx SDI pin is set to same pin as SPIx SDO pin (eg for a loopback check)
002989  003235  //       : it is necessary to configure the SDI pin first, eg
002990  003236  //       :     SPI1_SDI_pin(PA3);     // configure SPI1 SDI to PA3 (this disconnects anything else)
002991  003237  //       :     SPI1_SDO_pin(PA3));    // configure SPI1 SDO to PA3
002992  003238  //       : Returns: Returns TRUE if function succeeded (usually ignored)
002993  003239        
002994  003240  func SPI2_SDI_pin("pin"), 1;                // select the hardware pin for SPI2 receive line
002995  003241  // Syntax: SPI2_SDI_pin(pin);
002996  003242  // Usage : SPI2_SDI_pin(PA3); // set SPI2 SDI to PA3 pin
002997  003243  // Notes : Selects the hardware pin for SPIx receive line.
002998  003244  //       : Note that only a single pin can be mapped to SPI SDI.
002999  003245  //       : Pins that can be mapped to SPIx SDI are PA0 to PA13
003000  003246  //       : Pins that can't be mapped to SPIx SDI are PA14 and PA15
003001  003247  //       : If the pin argument is 0 the function has no effect
003002  003248  //       : The pin is automatically set to an input.
003003  003249  //       : If the SPIx SDI pin is set to same pin as SPIx SDO pin (eg for a loopback check)
003004  003250  //       : it is necessary to configure the SDI pin first, eg
003005  003251  //       :     SPI2_SDI_pin(PA3);     // configure SPI2 SDI to PA3 (this disconnects anything else)
003006  003252  //       :     SPI2_SDO_pin(PA3));    // configure SPI2 SDO to PA3
003007  003253  //       : Returns: Returns TRUE if function succeeded (usually ignored)
003008  003254        
003009  003255  func SPI3_SDI_pin("pin"), 1;                // select the hardware pin for SPI2 receive line
003010  003256  // Syntax: SPI3_SDI_pin(pin);
003011  003257  // Usage : SPI3_SDI_pin(PA3); // set SPI3 SDI to PA3 pin
003012  003258  // Notes : Selects the hardware pin for SPIx receive line.
003013  003259  //       : Note that only a single pin can be mapped to SPI SDI.
003014  003260  //       : Pins that can be mapped to SPIx SDI are PA0 to PA13
003015  003261  //       : Pins that can't be mapped to SPIx SDI are PA14 and PA15
003016  003262  //       : If the pin argument is 0 the function has no effect
003017  003263  //       : The pin is automatically set to an input.
003018  003264  //       : If the SPIx SDI pin is set to same pin as SPIx SDO pin (eg for a loopback check)
003019  003265  //       : it is necessary to configure the SDI pin first, eg
003020  003266  //       :     SPI3_SDI_pin(PA3);     // configure SPI3 SDI to PA3 (this disconnects anything else)
003021  003267  //       :     SPI3_SDO_pin(PA3));    // configure SPI3 SDO to PA3
003022  003268  //       : Returns: Returns TRUE if function succeeded (usually ignored)
003023  003269        
003024  003270  func SPI1_SCK_pin("pin"), 1;                // select the hardware pin for SPI1 clock line
003025  003271  // Syntax: SPI1_SCK_pin(pin);
003026  003272  // Usage : SPI1_SCK_pin(PA0); // set SPI1 SCK to PA0 pin
003027  003273  // Notes : Selects the hardware pin for SPI clock line.
003028  003274  //       : Note that only a single pin should be mapped to spi SCK.
003029  003275  //       : Pins that can be mapped to SPIx SCK are PA1, PA3 to PA9, PA12 or PA13
003030  003276  //       : Pins that can't be mapped to SPIx SCK are PA0, PA2, PA10, PA11, PA14 and PA15
003031  003277  //       : If the pin argument is 0 the SPIx SCK pin is disconnected
003032  003278  //       : The pin is automatically set to an output.
003033  003279  //       : Returns: Returns TRUE if finction succeeded (usually ignored)
003034  003280        
003035  003281  func SPI2_SCK_pin("pin"), 1;                // select the hardware pin for SPI2 clock line
003036  003282  // Syntax: SPI2_SCK_pin(pin);
003037  003283  // Usage : SPI2_SCK_pin(PA0); // set SPI1 SCK to PA0 pin
003038  003284  // Notes : Selects the hardware pin for SPI clock line.
003039  003285  //       : Note that only a single pin should be mapped to spi SCK.
003040  003286  //       : Pins that can be mapped to SPIx SCK are PA1, PA3 to PA9, PA12 or PA13
003041  003287  //       : Pins that can't be mapped to SPIx SCK are PA0, PA2, PA10, PA11, PA14 and PA15
003042  003288  //       : If the pin argument is 0 the SPIx SCK pin is disconnected
003043  003289  //       : The pin is automatically set to an output.
003044  003290  //       : Returns: Returns TRUE if finction succeeded (usually ignored)
003045  003291        
003046  003292  func SPI3_SCK_pin("pin"), 1;                // select the hardware pin for SPI3 clock line
003047  003293  // Syntax: SPI3_SCK_pin(pin);
003048  003294  // Usage : SPI3_SCK_pin(PA0); // set SPI1 SCK to PA0 pin
003049  003295  // Notes : Selects the hardware pin for SPI clock line.
003050  003296  //       : Note that only a single pin should be mapped to spi SCK.
003051  003297  //       : Pins that can be mapped to SPIx SCK are PA1, PA3 to PA9, PA12 or PA13
003052  003298  //       : Pins that can't be mapped to SPIx SCK are PA0, PA2, PA10, PA11, PA14 and PA15
003053  003299  //       : If the pin argument is 0 the SPIx SCK pin is disconnected
003054  003300  //       : The pin is automatically set to an output.
003055  003301  //       : Returns: Returns TRUE if finction succeeded (usually ignored)
003056  003302        
003057  003303        
003058  003304  func SPI1_Init("speed","mode"), 1;              // set the SPI1 port
003059  003305  func SPI2_Init("speed","mode"), 1;              // set the SPI2 port
003060  003306  func SPI3_Init("speed","mode"), 1;              // set the SPI3 port
003061  003307        
003062  003308        
003063  003309  //------------------------------------------------------------------------------
003064  003310  // Constants for SPI1, SPI2 an SPI3 "mode"
003065  003311  //------------------------------------------------------------------------------
003066  003312  #CONST
003067  003329  #END
003068  003330        
003069  003331  //------------------------------------------------------------------------------
003070  003332  // Constants for SPI1, SPI2 an SPI3 "speed"
003071  003333  //------------------------------------------------------------------------------
003072  003334  #CONST
003073  003351  #END
003074  003352        
003075  003353        
003076  003354  func SPI1_Read(), 1;                                 // read a raw byte from SPI1
003077  003355  func SPI2_Read(), 1;                                 // read a raw byte from SPI2
003078  003356  func SPI3_Read(), 1;                                 // read a raw byte from SPI3
003079  003357        
003080  003358  func SPI1_Write("byte"), 1;                          // write a raw byte to SPI1
003081  003359  func SPI2_Write("byte"), 1;                          // write a raw byte to SPI2
003082  003360  func SPI3_Write("byte"), 1;                          // write a raw byte to SPI3
003083  003361        
003084  003362  func spi_WriteBlock("buf", "bufsize"), 0;                       // commence a block write
003085  003363  // Syntax   : spi_WriteBlock("buf", "bufsize");
003086  003364  // Usage    : spi_WriteBlock(mybuf, 30);                         // point to the Write buffer and send 30 characters
003087  003365  // *Notes   : Bufsize bytes are transmitted to the SPI port from the string pointer "buf".
003088  003366        
003089  003367  func spi1_WriteBlock("buf", "bufsize"), 0;                       // commence a block write
003090  003368  // Syntax   : spi1_WriteBlock("buf", "bufsize");
003091  003369  // Usage    : spi1_WriteBlock(mybuf, 30);                         // point to the Write buffer and send 30 characters
003092  003370  // *Notes   : Bufsize bytes are transmitted to the SPI port from the string pointer "buf".
003093  003371        
003094  003372  func spi2_WriteBlock("buf", "bufsize"), 0;                       // commence a block write
003095  003373  // Syntax   : spi2_WriteBlock("buf", "bufsize");
003096  003374  // Usage    : spi2_WriteBlock(mybuf, 30);                         // point to the Write buffer and send 30 characters
003097  003375  // *Notes   : Bufsize bytes are transmitted to the SPI port from the string pointer "buf".
003098  003376        
003099  003377  func spi3_WriteBlock("buf", "bufsize"), 0;                       // commence a block write
003100  003378  // Syntax   : spi3_WriteBlock("buf", "bufsize");
003101  003379  // Usage    : spi3_WriteBlock(mybuf, 30);                         // point to the Write buffer and send 30 characters
003102  003380  // *Notes   : Bufsize bytes are transmitted to the SPI port from the string pointer "buf".
003103  003381        
003104  003382  //------------------------------------------------------------------//
003105  003383  // Display Access                                                   //
003106  003384  //------------------------------------------------------------------//
003107  003385  func disp_SetReg("register", "data"), 0;
003108  003386  // Syntax: display_SetReg(register, data);
003109  003387  // Usage : display_SetReg(arg1, arg2);
003110  003388  // Notes : Sets uLCD specific display driver registers. Refer
003111  003389  //       : to appropriate display driver data sheet.
003112  003390        
003113  003391  func disp_setGRAM("x1","y1","x2","y2"), 0;    // set GRAM window
003114  003392  // Syntax: disp_setGRAM(x1, y1, x2, y2);
003115  003393  // Usage : disp_setGRAM(arg1, arg2, arg3, arg4);
003116  003394  // Notes : Prepares the GRAM area for user access.
003117  003395  //       : Data can now be written with disp_GRAM.
003118  003396  //       : GRAM will be set accordingly for the correct screen mode.
003119  003397  //       : the LO word of the 32 bit pixel count is returned. This is
003120  003398  //       : usually all that is needed unlse GRAM area exceeds 256^2
003121  003399  //       : A copy of the 32bit value can be found in
003122  003400  //       : GRAM_PIXEL_COUNT_LO and GRAM_PIXEL_COUNT_HI
003123  003401        
003124  003402  func disp_WrGRAM("colour"), 0;
003125  003403  // Syntax: display_WrGRAM(colour);
003126  003404  // Usage : display_WrGRAM(arg);
003127  003405  // Notes : Data can be written to the GRAM consecutively using
003128  003406  //       : this function once the GRAM access window has been setup.
003129  003407        
003130  003408  func disp_WriteControl("value"), 0;             // write a control byte to the display
003131  003409        
003132  003410  func disp_WriteWord("value"), 0;                // write a word to the display
003133  003411        
003134  003412        
003135  003413  func disp_ReadWord(), 1;                        // read a word from the display
003136  003414  // Syntax: disp_ReadWord();
003137  003415  // Usage : x:=disp_ReadWord();
003138  003416  // Notes : Read a word from the controller
003139  003417  // Eg:   : disp_WriteControl(0);         // select Ilitek ID register
003140  003418  //       : print(disp_ReadWord());        // print ID
003141  003419  //       : (Many displays are write only)
003142  003420        
003143  003421        
003144  003422  // NB only available on certain displays, check individual data sheets
003145  003423  func sys_StoreTouchCalibration(), 1;
003146  003424  // Syntax: sys_StoreTouchCalibration();
003147  003425  // Usage : r := sys_StoreTouchCalibration();
003148  003426  // Notes : Store the touch calibration values in non-volatile memory.
003149  003427  //       : Returns true if the values have been accepted and stored,
003150  003428  //       : else returns false if write could not be performed, or
003151  003429  //       : touch calibration values are improbable.
003152  003430  //       : The values that are stored are obtained from:-
003153  003431  //       : TOUCH_XMINCAL             78  // touch calibration value
003154  003432  //       : TOUCH_YMINCAL             79  // touch calibration value
003155  003433  //       : TOUCH_XMAXCAL             80  // touch calibration value
003156  003434  //       : TOUCH_YMAXCAL             81  // touch calibration value
003157  003435  //       : refer to the 4DGL example touchCalibrate.4DG for further information.
003158  003436  //       : This function is not supported on uVGA, Capacitive touch
003159  003437  //       : and 4.3" resistive touch modules.
003160  003438        
003161  003439  // NB only available on certain displays, check individual data sheets
003162  003440  func disp_Sync("line"), 0;                      //  (uVGA only)  wait till scanline reaches "line"
003163  003441  // Syntax: disp_Sync(line);
003164  003442  // Usage : disp_Sync(480);
003165  003443  // Notes : Waits till the hardware gets to a certain line.
003166  003444  //       : Allows the program to synchronise writing to the hardware for flicker free operation.
003167  003445  //       : Some experimentation may be needed to find an optimum line for disp_Sync
003168  003446  //       : depending on the graphics operation. The higher the value, the slower
003169  003447  //       : the throughput. A cetain point will be reached (number of scanlines + blanking lines
003170  003448  //       : within the vertical retrace period) where it will just 'hang up' stopping the
003171  003449  //       : entire process. Eg, in 640x480 mode, if the 'lines' value is 507, operation will
003172  003450  //       : be slowest (as its actually right at the end of the blanking period) and 508
003173  003451  //       : will cause a hangup situation as it is above the highes scanline value.
003174  003452  //       : Currently, this function is only supported on displays with SSD1963 driver.
003175  003453        
003176  003454  func disp_Init(), 0;                           // initialize display with required tables. New in v0.7
003177  003455  // Syntax: disp_Init();                        New in v0.7
003178  003456  // Usage : disp_Init();
003179  003457  // Notes : Initialises or reinitialises the display.
003180  003458  //       : Normally used after restoration of peripheral power
003181  003459  //       : and after DeepSleep.
003182  003460        
003183  003461  func disp_Disconnect(), 0;                     // Disconnect display to ensure reduced power after disabling peripheral power. New in v0.7
003184  003462  // Syntax: disp_Disconnect();                  New in v0.7
003185  003463  // Usage : disp_Disconnect();
003186  003464  // Notes : Disconnects the display driver pins and/or reconfigures it to achieve
003187  003465  //       : its lowest possible power consumption. Use after disabling peripheral power
003188  003466  //       : to ensure the minimal power usage by the display.
003189  003467  //       : disp_Init() should be used to reinitialise the display.
003190  003468        
003191  003469  func disp_BlitPixelsFromCOM0(), 0;                     // Writes current GRAM window pixels to the display from the COM port
003192  003470  // Syntax: disp_BlitPixelsFromCOM0();                  New in v1.1
003193  003471  // Usage : disp_BlitPixelsFromCOM0();
003194  003472  // Notes : Writes the number of pixels defined by the last disp_setGRAM() call to the 
003195  003473  //       : display from the specified com port.
003196  003474        
003197  003475  func __reserved42(), 0; // do not remove
003198  003476        
003199  003477        
003200  003478  //------------------------------------------------------------------//
003201  003479  //        Image Control Function Prototypes                         //
003202  003480  //------------------------------------------------------------------//
003203  003481  func img_SetPosition("handle", "index", "xpos", "ypos"), 1;
003204  003482  // Syntax: img_SetPosition(handle, index, xpos, ypos);
003205  003483  // Usage : r := img_SetPosition(hImageList, imagenum, x, y);
003206  003484  // Notes : set the position where the image will be displayed
003207  003485  //       : returns true if index was ok and function was successful.
003208  003486  //       : you may turn off an image so when img_Refresh is called,
003209  003487  //       : the image will not be shown
003210  003488        
003211  003489  func img_Enable("handle", "index"), 1;
003212  003490  // Syntax: img_Enable(handle, index);
003213  003491  // Usage : r := img_Enable(hImageList, imagenum);
003214  003492  // Notes : enable image in a image list
003215  003493  //       : returns true if index was ok and function was successful.
003216  003494  //       : this is the default state so when img_Refresh is called,
003217  003495  //       : all the images in the list will be shown
003218  003496  //       : if index is set to -1, all of the images are enabled
003219  003497        
003220  003498  func img_Disable("handle", "index"), 1;
003221  003499  // Syntax: img_Disable(handle, index);
003222  003500  // Usage : r := img_Disable(hImageList, imagenum);
003223  003501  // Notes : disable image in a image list
003224  003502  //       : returns true if index was ok and function was successful.
003225  003503  //       : you must turn off an image so when img_Refresh is called,
003226  003504  //       : the image will not be shown.
003227  003505  //       : if index is set to -1, all of the images are disabled
003228  003506        
003229  003507        
003230  003508  func img_Darken("handle", "index"), 1;
003231  003509  // Syntax: img_Darken(handle, index);
003232  003510  // Usage : r := img_Darken(hImageList, imagenum);
003233  003511  // Notes : darken image in a image list
003234  003512  //       : returns true if index was ok and function was successful.
003235  003513  //       : if index is set to -1, all of the images are darkened
003236  003514  //       : NB:- this feature will only work for the next refresh, then
003237  003515  //       : the image reverts back to normal when displayed again.
003238  003516        
003239  003517        
003240  003518  func img_Lighten("handle", "index"), 1;
003241  003519  // Syntax: img_Lighten(handle, index);
003242  003520  // Usage : r := img_Lighten(hImageList, imagenum);
003243  003521  // Notes : lighten image in a image list
003244  003522  //       : returns true if index was ok and function was successful.
003245  003523  //       : if index is set to -1, all of the images are lightened
003246  003524  //       : NB:- this feature will only work for the next refresh, then
003247  003525  //       : the image reverts back to normal when displayed again.
003248  003526        
003249  003527  func img_SetWord("handle", "index", "offset", "word"), 1;
003250  003528  // Syntax: img_SetWord(handle, index, offset, word);
003251  003529  // Usage : img_SetWord(hndl, 5, IMAGE_XPOS, 10);
003252  003530  // Notes : set specified word (0-7) in a image entry
003253  003531  //       : returns TRUE if successful, return value usually ignored.
003254  003532        
003255  003533  func img_GetWord("handle", "index", "offset"), 1;
003256  003534  // Syntax: myvar := img_GetWord("handle", "index", "offset");
003257  003535  // Usage : myvar := img_GetWord(hndl, 5, IMAGE_YPOS);
003258  003536  // Notes : returns specified word (0-14) from an image entry
003259  003537  //       : refer to image control entry offsets.
003260  003538        
003261  003539  func img_Show("handle", "index"), 1;
003262  003540  // Syntax: img_Show(handle, index);
003263  003541  // Usage : display image entry (regardless of enable/disable)
003264  003542  //       : returns TRUE if successful, return value usually ignored.
003265  003543        
003266  003544  func img_SetAttributes("handle", "index","value"), 1;
003267  003545  // Syntax: img_SetAttributes("handle", "index","offset");
003268  003546  // Usage : img_SetAttributes(hndl, 5, I_TOPMOST);
003269  003547  // Notes : This function SETS one or more bits in the IMAGE_FLAGS field
003270  003548  //       : of an image control entry. "value" refers to various bits in
003271  003549  //       : the image control entry (see image attribute flags).
003272  003550  //       : A '1' bit in the "value" field SETS the respective bit
003273  003551  //       : in the IMAGE_FLAGS field of the image control entry.
003274  003552  //       : returns TRUE if successful, return value usually ignored.
003275  003553        
003276  003554  func img_ClearAttributes("handle", "index","value"), 1;
003277  003555  // Syntax: img_ClearAttributes("handle", "index","offset");
003278  003556  // Usage : img_ClearAttributes(hndl, 5, I_TOPMOST);
003279  003557  // Notes : This function CLEARS one or more bits in the IMAGE_FLAGS field
003280  003558  //       : of an image control entry. "value" refers to various bits in
003281  003559  //       : the image control entry (see image attribute flags)
003282  003560  //       : a '1' bit in the "value" field CLEARS the respective bit
003283  003561  //       : in the IMAGE_FLAGS field of the image control entry.
003284  003562  //       : returns TRUE if successful, return value usually ignored.
003285  003563        
003286  003564  func img_Touched("handle", "index"), 1;
003287  003565  // Syntax: r := img_Touched(handle, index);
003288  003566  // Usage : img_Touched(hndl, 17);
003289  003567  //       : returns -1 if image not touched, or returns index
003290  003568  // Notes : if index is passed as -1, function tests all images,
003291  003569  //       : and returns -1 if image not touched, or returns index.
003292  003570        
003293  003571        
003294  003572  func img_SelectReadPosition("handle", "index", "frame", "x", "y"), 1;
003295  003573  // Syntax: img_SelectReadPosition(handle, index, frame, xpos, ypos);
003296  003574  // Usage : r := img_SelectReadPosition(hImageList, imagenum, frame, x, y);
003297  003575  // Notes : set a position in an image control for sequential reading
003298  003576  //       : of pixels from the uSD card (fat16 or raw modes supported)
003299  003577  //       : No image window area is set, the image will not be shown
003300  003578  //       : This function provides a means of preparing to load an image,
003301  003579  //       : or part of an image, to an array. (see img_SequentialRead)
003302  003580  //Returns: returns true if index was ok and function was successful.
003303  003581        
003304  003582        
003305  003583  func img_SequentialRead("count", "ptr"), 1;  // read pixels from selected read position of an image
003306  003584  // Syntax: img_SequentialRead(count, ptr);
003307  003585  // Usage1: r := img_SequentialRead(imgwidth, myArray);    // read 1 line from image control to array
003308  003586  // Usage2: r := img_SequentialRead(123, 0);            // skip 123 words from sequential stream
003309  003587  // Usage3: r := img_SequentialRead(20, 1);            // write 20 pixels to current GRAM position from stream
003310  003588  // Notes : once a position has ben set with the img_SelectReadPosition function,
003311  003589  //       : this function can then used for sequential reading of pixels from
003312  003590  //       : image storage.
003313  003591  //       : if "ptr" is 0, "count" pixels from the stream are simply skipped.
003314  003592  //       : if "ptr" is 1, "count" pixels are written to the GRAM area,
003315  003593  //       : else "ptr" must point to a valid array that is at least
003316  003594  //       : the size of "count".
003317  003595  //       : or part of an image, to an array. (see img_SequentialRead)
003318  003596  //       : returns TRUE if function succeded.
003319  003597        
003320  003598  func __reserved43(), 0; // do not remove
003321  003599  func __reserved44(), 0; // do not remove
003322  003600  func __reserved45(), 0; // do not remove
003323  003601  func __reserved46(), 0; // do not remove
003324  003602        
003325  003603  // image control header offsets
003326  003604  #CONST
003327  003611  #END
003328  003612        
003329  003613  // image control entry offsets
003330  003614  #CONST
003331  003629  #END
003332  003630        
003333  003631  // image attribute flags (in IMAGE_FLAGS)
003334  003632  // for img_SetAttributes(...) and img_ClearAttributes(...)
003335  003633  #CONST
003336  003647  #END
003337  003648        
003338  003649        
003339  003650  //------------------------------------------------------------------//
003340  003651  //        Timer Function Prototypes
003341  003652  //------------------------------------------------------------------//
003342  003653  func sys_T(), 1;
003343  003654  // Syntax: sys_T();
003344  003655  // Usage : t := sys_T();
003345  003656  // Notes : return the current value of the rolling system timer (1msec) LO word
003346  003657        
003347  003658  func sys_T_HI(), 1;
003348  003659  // Syntax: sys_T_HI();
003349  003660  // Usage : t := sys_T_HI();
003350  003661  // Notes : return the current value of the rolling system timer (1msec) HI word
003351  003662        
003352  003663  func sys_SetTimer("timernum","value"), 0;
003353  003664  // Syntax: sys_SetTimer("timernum", "value");
003354  003665  // Usage : sys_SetTimer(TIMER5, 10000);
003355  003666  // Notes : set a countdown on the selected timer, or 'top up' if required.
003356  003667  //       : There ar 8 timers TIMER0 to TIMER7 which stop at the count of 0
003357  003668  //       : Maximum timeout period is 65.535 seconds
003358  003669  //       : A timer can be read with the sys_GetTimer("timernum") function
003359  003670        
003360  003671  func sys_GetTimer("timernum"), 1;
003361  003672  // Syntax: t := sys_GetTimer("timernum");
003362  003673  // Usage : t := sys_GetTimer(TIMER3);
003363  003674  // Notes : returns 0 if timer has expired, or the current countdown value.
003364  003675  //       : There ar 8 timers TIMER0 to TIMER7 which stop at the count of 0
003365  003676  //       : Maximum timeout period is 65.535 seconds
003366  003677  //       : A timer must be set with the sys_SetTimer("timernum","value") function
003367  003678        
003368  003679  func sys_SetTimerEvent("timernum","function"), 1;
003369  003680  // Syntax: sys_SetTimerFunction("timernum", "function");
003370  003681  // Usage : sys_SetTimer(TIMER5, myfunc);
003371  003682  // Notes : set a function to be called for selected timer.
003372  003683  //       : When the timer reaches zero, the function is called.
003373  003684  //       : The called function must not have any parameters
003374  003685  //       : sys_SetTimerEvent returns any previous event function
003375  003686  //       : address, or zero if there was no previous function.
003376  003687        
003377  003688  func sys_EventQueue(), 1;
003378  003689  // Syntax: sys_EventQueue();
003379  003690  // Usage : tasks := sys_EventQueue();
003380  003691  // Notes : returns the max number of events that were pending
003381  003692  //       : in the timer queue since the last call to this function.
003382  003693  //       : This can be used to assess timer event overhead burden,
003383  003694  //       : especially after or during a sys_EventsPostpone action.
003384  003695        
003385  003696  func sys_EventsPostpone(), 0;
003386  003697  // Syntax: sys_EventPostpone();
003387  003698  // Usage : sys_EventPostpone();   // postpone the event queue
003388  003699  // Notes : postpone any events until the sys_EventResume function is executed
003389  003700  //       : The timer event queue will continue to queue events, but no action
003390  003701  //       : will take place untill a sys_EventResume function is encountered.
003391  003702  //       : The queue will continue to receive up to 32 events before discarding
003392  003703  //       : any further events. This function is required to allow a sequence of
003393  003704  //       : instructions or functions to occur that would otherwise be corrupted
003394  003705  //       : by an event occuring during the sequence of instructions or functions.
003395  003706  //       : A good example of this is when you set a position to print, if there
003396  003707  //       : was no way of locking the current sequence, an event may occur which
003397  003708  //       : does a similar thing, and a contention would occur - printing to
003398  003709  //       : the wrong position. This function should be used wisely, if any action
003399  003710  //       : that is required would take considerable time, it is better to disable
003400  003711  //       : any conflicting event functions with a bypass flag, then restart the
003401  003712  //       : conflicting event by re-issuing a timer value.
003402  003713        
003403  003714  func sys_EventsResume(), 0;
003404  003715  // Syntax: sys_EventsResume();
003405  003716  // Usage : sys_EventsResume();   // resume the event queue
003406  003717  // Notes : resume any postponed events. The queue will try to execute any timer
003407  003718  //       : events that were incurred during the postponed period.
003408  003719        
003409  003720        
003410  003721  func sys_GetTime(), 0;
003411  003722  // Syntax: sys_GetTime();
003412  003723  // Usage : to(mystring); sys_GetTime();   // save current time string to buffer
003413  003724  // Notes : print the system time in the format eg "6:10:45"
003414  003725  //       : Can be captured to a buffer using the to( function
003415  003726  //       : Returns nothing.
003416  003727        
003417  003728  func sys_SetTime("hours", "mins", "secs"), 1;
003418  003729  // Syntax: sys_SetTime(h, m, s);
003419  003730  // Usage : sys_SetTime(10, 0, 0);   // set the system time
003420  003731  // Notes : Used to set clock to correct time after power up or suspension
003421  003732  //Returns: Returns true if valid time.
003422  003733        
003423  003734  func sys_GetDate(), 0;
003424  003735  // Syntax: sys_GetDate();
003425  003736  // Usage : to(mystring); sys_GetDate();   // save current time string to buffer
003426  003737  // Notes : print the system date in the format eg "2012-09-05"
003427  003738  //       : Can be captured to a buffer using the to( function
003428  003739  //       : Returns nothing.
003429  003740        
003430  003741  func sys_SetDate("year", "month", "day"), 1;
003431  003742  // Syntax: sys_SetDate(y, m, d);
003432  003743  // Usage : sys_SetDate(10, 0, 0);   // set the system time
003433  003744  // Notes : Used to set clock to correct date after power up or suspension
003434  003745  //Returns: Returns true if valid date.
003435  003746        
003436  003747  func sys_Sleep("units"), 1;
003437  003748  // Syntax: t := sys_Sleep("units");
003438  003749  // Usage : t := sys_Sleep(10);
003439  003750  // Notes : sets the display into low power mode for a period of time.
003440  003751  //       : Touching the touch screen will also wake from sleep.
003441  003752  //       : as will bus Change Interrupts.
003442  003753  //       : Returns remaining sleep units.
003443  003754        
003444  003755  func iterator("offset"), 0;
003445  003756  // Syntax: t :=  iterator("offset");
003446  003757  // Usage : t :=  iterator(10);
003447  003758  // Notes : set the iterator size for ++/--
003448  003759  //       : The next postinc,postdec,preinc of predec will alter
003449  003760  //       : by the specified value.
003450  003761  //       : The offset will return to 1 after the next operation.
003451  003762        
003452  003763  func sys_DeepSleep("units"), 1;               // put the module into its lowest power consumption mode. New in v0.7
003453  003764  // Syntax: t := sys_DeepSleep("units");    New in v0.7
003454  003765  // Usage : t := sys_DeepSleep(10);
003455  003766  // Notes : sets the display and processor into lowest power mode for a period of time.
003456  003767  //       : When returning from DeepSleep the display should be reinitialised
003457  003768  //       : with disp_Init().
003458  003769  //       : Touching the touch screen will also wake from sleep.
003459  003770  //       : Returns remaining sleep units.
003460  003771        
003461  003772  //------------------------------------------------------------------//
003462  003773  //         Touch Screen Function Prototypes
003463  003774  //------------------------------------------------------------------//
003464  003775        
003465  003776  func touch_DetectRegion("x1" ,"y1", "x2", "y2"), 0;
003466  003777  // Syntax: touch_DetectRegion(x1, y1, x2, y2);
003467  003778  // Usage : touch_DetectRegion(arg1, arg2, arg3, arg4);
003468  003779  // Notes : Specifies a new touch detect region on the screen
003469  003780  //       : such that only touch activity in that region will
003470  003781  //       : be reported by the status poll touch_Get(TOUCH_STATUS);
003471  003782        
003472  003783  func touch_Set("mode"), 0;
003473  003784  // Syntax: touch_Set(mode);
003474  003785  // Usage : touch_Set(arg);
003475  003786  // Notes : Sets various Touch Screen related parameters
003476  003787  //       :
003477  003788  //       : mode = TOUCH_ENABLE (mode 0)  Enable Touch Screen
003478  003789  //       : touch_Set(TOUCH_ENABLE);
003479  003790  //       : Enables and initialises Touch Screen hardware
003480  003791  //       :
003481  003792  //       : mode = TOUCH_DISABLE (mode 1)  Disable Touch Screen
003482  003793  //       : touch_Set(TOUCH_DISABLE );
003483  003794  //       : Disables the Touch Screen
003484  003795  //       : Note: Touch Screen runs in the background and disabling
003485  003796  //       : it when not in use will free up extra resources
003486  003797  //       : such as 4DVM CPU cycles.
003487  003798  //       :
003488  003799  //       : mode = TOUCH_REGIONDEFAULT (mode 2)  Default Touch Region
003489  003800  //       : touch_Set(TOUCH_REGIONDEFAULT);
003490  003801  //       : This will reset the current active region to default
003491  003802  //       : to the full screen without the application having to
003492  003803  //       : set a new active region for the full screen.
003493  003804  //       : (NB for 'no touch' devices - like uVGAII or OLED's/LCD's
003494  003805  //       : that requre to be interfaced with an external pointing
003495  003806  //       : device, values that are poked into TOUCH_DRIVE will be
003496  003807  //       : read with the touch_Get() function)
003497  003808        
003498  003809        
003499  003810  func touch_Get("mode"), 1;
003500  003811  // Syntax: touch_Get(mode);
003501  003812  // Usage : arg1 := touch_Get(arg);
003502  003813  // Notes : Returns various Touch Screen parameters to caller
003503  003814  //       :
003504  003815  //       : mode = TOUCH_STATUS  (mode 0)
003505  003816  //       : var := touch_Get(TOUCH_STATUS);
003506  003817  //       : Returns the various states of the touch screen
003507  003818  //       : 0 = NOTOUCH
003508  003819  //       : 1 = TOUCH_PRESSED
003509  003820  //       : 2 = TOUCH_RELEASED
003510  003821  //       : 3 = TOUCH_MOVING
003511  003822  //       :
003512  003823  //       : mode = TOUCH_GETX   (mode 1)
003513  003824  //       : var := touch_Get(TOUCH_GETX);
003514  003825  //       : Returns the X coordinates of the touch
003515  003826  //       :
003516  003827  //       : mode = TOUCH_GETY   (mode 2)
003517  003828  //       : var := touch_Get(TOUCH_GETY);
003518  003829  //       : Returns the Y coordinates of the touch
003519  003830        
003520  003831        
003521  003832  //touch_Set() related constants
003522  003833  #CONST
003523  003837  #END
003524  003838        
003525  003839  //touch_Get() related constants
003526  003840  #CONST
003527  003848  #END
003528  003849        
003529  003850  func touch_TestBox("&rect"), 1;
003530  003851  // Syntax   : touch_Test(rect);
003531  003852  // Usage    : var r[4]; r[0]:=100; r[1]:=200; r[2]:=20; r[3]:=30;
003532  003853  //          : result := touch_Test(r); // check area at 100,200,119,229
003533  003854  // Notes    : rect is an array of 4 vars, x1, y1, width, height (using boxed co-ordinates)
003534  003855  // returns  : Returns true if last touch co-ordinates are within the boxed test area.
003535  003856        
003536  003857  func touch_TestArea("&rect"), 1;
003537  003858  // Syntax   : touch_Test(rect);
003538  003859  // Usage    : var r[4]; r[0]:=100; r[1]:=200; r[2]:=119; r[3]:=129;
003539  003860  //          : result := touch_Test(r); // check area at 100,200,119,229
003540  003861  // Notes    : rect is an array of 4 vars, x1, y1, x2, y2 (using absolute co-ordinates)
003541  003862  // returns  : Returns true if last touch co-ordinates are within the absolute co-ordinate test area.
003542  003863        
003543  003864        
003544  003865  func __reserved51(), 0; // do not remove
003545  003866  func __reserved52(), 0; // do not remove
003546  003867        
003547  003868  //------------------------------------------------------------------//
003548  003869  //        Memory Allocation Function Prototypes
003549  003870  //------------------------------------------------------------------//
003550  003871        
003551  003872  func mem_Alloc("size"), 1;
003552  003873  // Syntax: mem_Alloc(bytesize);
003553  003874  // Usage : myvar := mem_Alloc(100);
003554  003875  // Notes : Allocate a block of memory to pointer myvar
003555  003876  //       : The allocated memory contains garbage but is a fast allocation.
003556  003877  //       : The block must later be released with mem_Free();
003557  003878  //       : returns 0 if function fails
003558  003879        
003559  003880  func mem_AllocV("size"), 1;
003560  003881  // Syntax: mem_AllocV(bytesize);
003561  003882  // Usage : myvar := mem_AllocV(100);
003562  003883  // Notes : Allocate a block of memory to pointer myvar
003563  003884  //       : The block of memory is filled with signature values
003564  003885  //       : the block starts with A5,5A then fills with incrementing
003565  003886  //       : number eg:- A5,5A,00,01,02,03...FF,00,11....
003566  003887  //       : This can be helpful when debugging
003567  003888  //       : The block must later be released with mem_Free();
003568  003889  //       : returns 0 if function fails
003569  003890        
003570  003891  func mem_AllocZ("size"), 1;
003571  003892  // Syntax: mem_AllocZ(bytesize);
003572  003893  // Usage : myvar := mem_AllocC(100);
003573  003894  // Notes : Allocate a zeroed block of memory to pointer myvar
003574  003895  //       : The block of memory is filled with zeroes
003575  003896  //       : The block must later be released with mem_Free();
003576  003897  //       : returns 0 if function fails
003577  003898        
003578  003899  func mem_Realloc("ptr", "size"), 1;
003579  003900  // Syntax: myvar := mem_Realloc("ptr", "size");
003580  003901  // Usage : myvar := mem_Realloc(ptr, size);
003581  003902  // Notes : The function may move the memory block to a new location,
003582  003903  //       : in which case the new location is returned.
003583  003904  //       : The content of the memory block is preserved up to the lesser
003584  003905  //       : of the new and old sizes, even if the block is moved.
003585  003906  //       : If the new size is larger, the value of the newly allocated
003586  003907  //       : portion is indeterminate. In case that ptr is NULL,
003587  003908  //       : the function behaves exactly as mem_Alloc, assigning a new block
003588  003909  //       : of size bytes and returning a pointer to the beginning of it.
003589  003910  //       : In case that the size is 0, the memory previously allocated in
003590  003911  //       : ptr is deallocated as if a call to mem_Free()was made, and a NULL
003591  003912  //       : pointer is returned.
003592  003913        
003593  003914  func mem_Free("allocation"), 1;
003594  003915  // Syntax: myvar := mem_Free(allocation);
003595  003916  // Usage : myvar := mem_Free(myvar);
003596  003917  // Notes : De-allocate a block of memory previously created with
003597  003918  //       : mem_Alloc(...), mem_AllocV(...); or mem_AllocZ(...);
003598  003919  //       : returns 0 if function fails
003599  003920        
003600  003921  func mem_Heap(), 1;
003601  003922  // Syntax: myvar := mem_Heap();
003602  003923  // Usage : myvar := mem_Heap();
003603  003924  // Notes : returns bytecount available in heap
003604  003925  //       :
003605  003926        
003606  003927  func mem_Set("ptr","char","size"), 1;
003607  003928  // Syntax: mem_Set(ptr,char,bytesize);
003608  003929  // Usage : mem_Set(p, 'A', 100);
003609  003930  // Notes : fill a block of memory with a byte value
003610  003931  //       : Note that count is a byte count, this facilitates
003611  003932  //       : clearing word aligned byte arrays when using word
003612  003933  //       : aligned packed strings.
003613  003934  //       : returns ptr
003614  003935        
003615  003936  func mem_Copy("src", "dest", "bytecount"), 1;
003616  003937  // Syntax: myvar := mem_Copy(src, dest, bytesize);
003617  003938  // Usage : myvar := mem_Copy(p1, p2, 100);
003618  003939  // Notes : copy a word aligned block of memory from src to dest
003619  003940  //       : Note that count is a byte count, this facilitates
003620  003941  //       : copying word aligned byte arrays when using word
003621  003942  //       : aligned packed strings.
003622  003943  //       : returns src
003623  003944        
003624  003945  func mem_Compare("ptr1","ptr2","count"), 1;
003625  003946  // Syntax: myvar := mem_Compare(ptr1,ptr2,bytesize);
003626  003947  // Usage : myvar := mem_Compare(p1, p2, 100);
003627  003948  // Notes : compare word aligned blocks of memory at src, dest
003628  003949  //       : Note that count is a byte count, this facilitates
003629  003950  //       : comparing word aligned byte arrays when using word
003630  003951  //       : aligned packed strings.
003631  003952  //       : returns 0 if we have a match
003632  003953        
003633  003954  func __reserved53(), 0; // do not remove
003634  003955  func __reserved54(), 0; // do not remove
003635  003956        
003636  003957  //------------------------------------------------------------------//
003637  003958  //        FAT16 Function Prototypes
003638  003959  //------------------------------------------------------------------//
003639  003960        
003640  003961  func file_Error(), 1;
003641  003962  // Syntax: myvar := file_Error();
003642  003963  // Usage : e := file_Error();
003643  003964  // Notes : return the most recent file error.
003644  003965  //       :
003645  003966        
003646  003967  func file_Count("filename"), 1;
003647  003968  // Syntax: count := file_Count("filename");
003648  003969  // Usage : count := file_Count("*.4dg");
003649  003970  // Notes : returns number of files found that match the criteria
003650  003971        
003651  003972  func file_Dir("filename"), 1;
003652  003973  // Syntax: count := file_Dir("filename");
003653  003974  // Usage : count := file_Dir("*.4dg");
003654  003975  // Notes : streams a string of filenames that agree with the search key
003655  003976  //       : returns number of files found that match the criteria
003656  003977        
003657  003978  func file_FindFirst("fname"), 1;
003658  003979  // Syntax: res := file_FindFirst("fname");
003659  003980  // Usage : if (file_FindFirst("*.4xe") ....
003660  003981  // Notes : returns true if at least 1 file exists
003661  003982  //       : that satisfies the file argument.
003662  003983  //       : Wildcards are usually used so if
003663  003984  //       : file_FindFirst returns true, further
003664  003985  //       : tests can be made using file_FindNext();
003665  003986  //       : to find all the files that match the
003666  003987  //       : wildcard class. Note that the stream behaviour
003667  003988  //       : is the same as file_Dir.
003668  003989  //       :
003669  003990        
003670  003991  func file_FindNext(), 1;
003671  003992  // Syntax: res := file_FindNext();
003672  003993  // Usage : while ((file_FindNext()) ....
003673  003994  // Notes : returns true if more file exists
003674  003995  //       : that satisfies the file argument
003675  003996  //       : that was given for  file_FindFirst.
003676  003997  //       : Wildcards must be used for
003677  003998  //       : file_FindFirst, else this function will
003678  003999  //       : always return zero as the only occurence
003679  004000  //       : will have already been found.
003680  004001  //       : Note that the stream behaviour
003681  004002  //       : is the same as file_Dir.
003682  004003  //       :
003683  004004        
003684  004005  func file_Exists("fname"), 1;
003685  004006  // Syntax: res := file_Exists("fname"),
003686  004007  // Usage : if(file_Exists("myfile") ....
003687  004008  // Notes : returns true if file exists
003688  004009  //       :
003689  004010        
003690  004011  func file_Open("fname", "mode"), 1;
003691  004012  // Syntax: handle := file_Open("fname","mode"),
003692  004013  // Usage : handle := file_Open("myfile.txt", 'r');
003693  004014  // Notes : returns handle if file exists
003694  004015  //       :
003695  004016        
003696  004017  func file_Close("handle"), 1;
003697  004018  // Syntax: res := file_Close("handle");
003698  004019  // Usage : res := file_Close(hnd1);
003699  004020  // Notes : returns true if file closed ok
003700  004021  //       :
003701  004022        
003702  004023  func file_Read("*dest", "size", "handle"), 1;
003703  004024  // Syntax: res := file_Read("*dest", "size", "handle"),
003704  004025  // Usage : res := file_Read(memblock,20,hnd1);
003705  004026  // Notes : returns number of characters read
003706  004027  //       : if "dest" is zero, data is read direct to GRAM window
003707  004028  //       :
003708  004029        
003709  004030        
003710  004031  func file_Seek("handle", "HiWord", "LoWord"), 1;
003711  004032  // Syntax: res := file_Seek("handle", "HiWord", "LoWord")
003712  004033  // Usage : res := file_Seek(hSource, 0, 0x1234);
003713  004034  // Notes : set file position to 0x00001234 (byte position 4660)
003714  004035  //       : for the file handle so subsequent data may be read
003715  004036  //       : from that position onwards with file_GetC(...),
003716  004037  //       : file_GetW(...) or file_GetS(...), or an image
003717  004038  //       : can be displayed with file_Image(...)
003718  004039  // Notes : returns true if ok, usually ignored
003719  004040        
003720  004041  func file_Index("handle", "HiSize", "LoSize","recordnum"), 1;
003721  004042  // Syntax: file_Index("handle", "HiSize", "LoSize","recordnum"), 1;
003722  004043  // Usage : res := file_Index(hsource, 0, 1000, 123), 1;
003723  004044  // Notes : set file seek position to 123000
003724  004045  //       : for the file handle so subsequent data may be read
003725  004046  //       : from that record position onwards with file_GetC(...),
003726  004047  //       : file_GetW(...) or file_GetS(...), or an image
003727  004048  //       : can be displayed with file_Image(...)
003728  004049  // Notes : returns true if ok, usually ignored
003729  004050        
003730  004051  func file_Tell("handle", "&HiWord", "&LoWord"), 1;
003731  004052  // Syntax: file_Tell("handle", &HiWord, &LoWord);
003732  004053  // Usage : file_Tell(fhndl, &SizeHi, &SizeLo);
003733  004054  // Notes : Reads the 32 bit file pointer and stores it into 2 variables.
003734  004055  //       : returns true if function succeeded
003735  004056        
003736  004057  func file_Write("*source", "size", "handle"), 1;
003737  004058  // Syntax: res := fwrite("*source", "size", "handle"),
003738  004059  // Usage : res := fwrite(memblock, 20, hnd1);
003739  004060  // Notes : returns number of bytes written
003740  004061  //       :
003741  004062        
003742  004063  func file_Size("handle", "&HiWord", "&LoWord"), 1;
003743  004064  // Syntax: file_Size("handle", &HiWord, &LoWord);
003744  004065  // Usage : file_Size(fhndl, &SizeHi, &SizeLo);
003745  004066  // Notes : Reads the 32 bit file size and stores it into 2 variables.
003746  004067  //       : returns true if function succeeded
003747  004068        
003748  004069  func file_Image("x", "y", "handle"), 1;
003749  004070  // Syntax: file_Image(x, y, handle);
003750  004071  // Usage : file_Image(10, 10, hnd1);
003751  004072  // Notes : Display an image from a file at the current file position.
003752  004073  //       : The image is displayed at x,y (with respect to top left corner).
003753  004074  //       : If there is more than 1 image in the file, it can be
003754  004075  //       : accessed with file_Seek(...)
003755  004076        
003756  004077  func file_ScreenCapture("x", "y", "width", "height", "handle"), 1;
003757  004078  // Syntax: file_ScreenCapture(x, y, w, h, handle);
003758  004079  // Usage : file_ScreenCapture(10, 10, 50,50, hnd1);
003759  004080  // Notes : Save a image from screen to file at the current file position.
003760  004081  //       : The image can later be displayed with file_Image(...);
003761  004082  //       : The file may be opened in append mode to accumulate multiple
003762  004083  //       : images. Later, the images can be accessed with file_Seek(...);
003763  004084  //       : Note that the image will be sector aligned.
003764  004085  //       : All image headers must start on a sector boundary.
003765  004086  //       : The image is saved from x, y (with respect to top left corner)
003766  004087  //       : and the capture area is determined by "width" and "height".
003767  004088  //       : returns 0 if function succeeded
003768  004089        
003769  004090  func file_PutC("char","handle"), 1;
003770  004091  // Syntax: file_PutC("char", "handle");
003771  004092  // Usage : file_PutC('x', hndl);
003772  004093  // Notes : returns true if function succeeded
003773  004094        
003774  004095  func file_GetC("handle"), 1;
003775  004096  // Syntax: file_GetC("handle");
003776  004097  // Usage : mychar := fgetC("handle");
003777  004098  // Notes : returns next char from file
003778  004099        
003779  004100  func file_PutW("word","handle"), 1;
003780  004101  // Syntax: file_PutW("word","handle");
003781  004102  // Usage : file_PutW(0x1234, hndl);
003782  004103  // Notes : returns true if function succeeded
003783  004104        
003784  004105  func file_GetW("handle"), 1;
003785  004106  // Syntax: file_GetW("handle");
003786  004107  // Usage : myword := fgetW("handle");
003787  004108  // Notes : returns next word in file
003788  004109        
003789  004110  func file_PutS("*source", "handle"), 1;
003790  004111  // Syntax: res := file_Puts("*source", "handle"),
003791  004112  // Usage : res := file_Puts(mystring, hnd1);
003792  004113  // Notes : returns number of characters written
003793  004114  //       :
003794  004115        
003795  004116  func file_GetS("*string", "size", "handle"), 1;
003796  004117  // Syntax: res := file_Gets("*string", "size", "handle");
003797  004118  // Usage : res := file_Gets(mystr , 81, hnd1); // read up to 80 chars
003798  004119  // Notes : get a string from a file
003799  004120  //       : returns pointer to string or null if failed.
003800  004121  //       : file_GetS(...) automatically appends a null-terminator to the data read.
003801  004122  //       : NB:- only reads up to "size-1" characters into "string"
003802  004123  //       : file_GetS(...) will stop reading when any of the following conditions are true:
003803  004124  //       : A] It has read n-1 bytes (one character is reserved for the null-terminator)
003804  004125  //       : B] It encounters a newline character (a line-feed in the compilers tested here), or
003805  004126  //       : C] It reaches the end of file
003806  004127  //       : D] A read error occurs.
003807  004128        
003808  004129        
003809  004130  func file_Erase("fname"), 1;
003810  004131  // Syntax: res := file_Erase("fname");
003811  004132  // Usage : res := file_Erase("myfile.txt");
003812  004133  // Notes : returns true if successful
003813  004134  //       :
003814  004135        
003815  004136  func file_Rewind("handle"), 1;
003816  004137  // Syntax: res := file_Rewind("handle");
003817  004138  // Usage : res := file_Rewind(hnd1);
003818  004139  // Notes : returns true if file rewound ok (usually ignored)
003819  004140  //       : resets the file pointer the the beginning of the open file.
003820  004141        
003821  004142  func file_LoadFunction("fname.4xe"), 1;
003822  004143  // Syntax: res := file_LoadFunction("fname.4fn");
003823  004144  // Usage : myfunc := file_LoadFunction(myfuncname);
003824  004145  // Notes : Load a function or program from disk and
003825  004146  //       : return a function pointer to the allocation.
003826  004147  //       : The function can then be invoked just like any other
003827  004148  //       : function would be called via a function pointer.
003828  004149  //       : Parameters may be passed to it in a conventional way.
003829  004150  //       : The function may be discarded at any time when no
003830  004151  //       : longer required, thus freeing its memory resources.
003831  004152  //       : The loaded function can be discarded with mem_Free(..)
003832  004153  //       : eg:
003833  004154  //       : popupWindow := file_LoadFunction("popupWindow1.4fn");
003834  004155  //       : if(!popupWindow) goto LoadFunctionFailed; // could not load the function !!!
003835  004156  //       : then elsewhere in your program:-
003836  004157  //       : res := popupWindow(MYMODE,"My Title","My Popup Text");
003837  004158  //       : if(res == QUIT_APPLICATION) goto exitApp;
003838  004159  //       : Later in your program, when popupWindow is no longer
003839  004160  //       : required for the application:-
003840  004161  //       : res := mem_Free(popupWindow);
003841  004162  //       : if(!res) goto FreeFunctionFailed; // should never happen if memory not corrupted
003842  004163  //       : The callers stack is shared by the loaded function,
003843  004164  //       : however any global variables in the loaded function
003844  004165  //       : are private to that function.
003845  004166  //
003846  004167        
003847  004168  func file_Run("fname.4xe", "arglistptr"), 1;
003848  004169  // Syntax: res := file_Run("fname.4xe","arglistptr");
003849  004170  // Usage : res := file_Run(fname, argptr);
003850  004171  // Notes : current program releases any allocated memory but
003851  004172  //       : retains the stack and global memory.
003852  004173  //       : If arglistptr is 0, no arguments are passed, else
003853  004174  //       : arglist points to an array, the first element being
003854  004175  //       : the number of elements in the array.
003855  004176  //       : func 'main' in the called program accepts
003856  004177  //       : the arguments, if any. The arguments can only
003857  004178  //       : be passed by value, no pointers or references can be
003858  004179  //       : used as all memory is cleared before the file
003859  004180  //       : is loaded. Refer to file_Exec and file_LoadFunction
003860  004181  //       : for functions that can pass by reference.
003861  004182        
003862  004183  func file_Exec("fname.4xe", "arglistptr"), 1;
003863  004184  // Syntax: res := file_Exec("fname.4xe","arglistptr");
003864  004185  // Usage : res := file_Exec("fname.4xe","arglistptr");
003865  004186  // Notes : returns like a function, current program
003866  004187  //       : calling program is kept active and control returns to it.
003867  004188  //       : If arglistptr is 0, no arguments are passed, else
003868  004189  //       : arglist points to an array, the first element being
003869  004190  //       : the number of elements in the array.
003870  004191  //       : func 'main' in the called program accepts the arguments.
003871  004192  //       : This function is similar to file_LoadFunction(...), however,
003872  004193  //       : the function argument list is passed by pointer, and
003873  004194  //       : the memory consumed by the function is released as
003874  004195  //       : soon as the function completes.
003875  004196        
003876  004197  func file_LoadImageControl("fname1", "fname2", "mode"), 1;
003877  004198  // Syntax: hImagelist := file_LoadImageControl ("controlfile", "imagefile", "mode"),
003878  004199  // Usage : hImagelist := file_LoadImageControl ("resource.dat", "resource.gci", 0);
003879  004200  // Notes : Reads a control file to create an image list.
003880  004201  //       : Returns NULL if function fails.
003881  004202  //       : Returns a handle (pointer to the memory allocation) to the
003882  004203  //       : image control list that has been created.
003883  004204  //       : "fname1" is the control list filename "*.dat"
003884  004205  //       : "fname2" is the image filename "*.gci"
003885  004206        
003886  004207  // Notes : This function Calculates the size of a chunk of memory required for
003887  004208  //       : a image list and populates it from the image control file ("*.dat")
003888  004209  //       : therefore, when imagelist is no longer required, you must de-allocate
003889  004210  //       : the image list memory by using eg:- mem_Free(hImagelist);
003890  004211  //       : to restore the heap.
003891  004212  //       :
003892  004213  //       : mode 0:- it is assumed that there is a graphics file with the
003893  004214  //       : file extension "fname2.gci". In this case, the images have been stored
003894  004215  //       : in a FAT16 file concurrently, and the offsets that ar derived from the
003895  004216  //       : "fname1.dat" file are saved in the image control so that the image control
003896  004217  //       : can open the file (*.gci) and us file_Seek to get to the position of the
003897  004218  //       : image which can then automatically be displayed using file_Image(xpos, ypos, hSource);
003898  004219  //       : mode 0 builds the image control quickly as it only scans the *.dat file
003899  004220  //       : for the file offsets and save them in the relevant entries in the image control.
003900  004221  //       : The penalty is that images take longer to find when displayed due to file_Seek
003901  004222  //       : overheads.
003902  004223  //
003903  004224  //       : mode 1:- it is assumed that there is a graphics file with the
003904  004225  //       : file extension "fname2.gci". In this case, the images have been stored
003905  004226  //       : in a FAT16 file concurrently, and the offset of the images are saved
003906  004227  //       : in the image control so that image file (*.gci) can be mapped to directly.
003907  004228  //       : The absolute cluster/sector is mapped so file seek does not need to be called
003908  004229  //       : internally. This means that there is no seek time penalty, however, the
003909  004230  //       : image list takes a lot longer to build, as all the seeking is done at control
003910  004231  //       : build time.
003911  004232        
003912  004233  //       : mode 2:- the graphics file with the is placed in a partitioned area
003913  004234  //       : In this case, the images have been stored in a in a known raw area of the FAT16
003914  004235  //       : disk, and the absolute address of the images are saved in the DAT file
003915  004236  //       : This is the fastest operation of the image control as there is no seeking
003916  004237  //       : or other disk activity taking place.
003917  004238        
003918  004239  func file_Mount(), 1;
003919  004240  // Syntax: r := file_Mount();
003920  004241  // Usage : r := file_Mount();
003921  004242  // Notes : Create a control block for FAT16 and mount the File System
003922  004243        
003923  004244  func file_Unmount(), 0;
003924  004245  // Syntax: file_Unmount();
003925  004246  // Usage : file_Unmount();
003926  004247  // Notes : release any control block and buffers for FAT16
003927  004248  //       : and unmount the File System
003928  004249        
003929  004250  func file_PlayWAV("fname1"), 1;
003930  004251  // Syntax: file_PlayWAV("fname1");
003931  004252  // Usage : file_PlayWAV("ding.wav");
003932  004253  // Notes : Play a wave file with filename "fname1"
003933  004254  //       : This function automatically grabs a chunk
003934  004255  //       : of memory for a file buffer, and a wave
003935  004256  //       : buffer. The minimum memory requirement is
003936  004257  //       : about 580 bytes for the disk io service and
003937  004258  //       : a minimum wave buffer size of 1024. The siz
003938  004259  //       : of the wave buffer allocation
003939  004260  //       : can be increased by the snd_BufSize function.
003940  004261  //       : The default size 1024 bytes.
003941  004262  //       : NB the memory is only required during the
003942  004263  //       : duration of play, and is automatically
003943  004264  //       : released while not in use.
003944  004265  //       : See the Sound Class services for other associated controls.
003945  004266  //       : If there are no errors, returns number of blocks to play (1 to 32767)
003946  004267  //       : If errors occured, the folling is returned
003947  004268  //       : -7  : Insufficient memory available for WAV buffer and file
003948  004269  //       : -6  : cant play this rate
003949  004270  //       : -5  : no data chunk found in first rsector
003950  004271  //       : -4  : no format data
003951  004272  //       : -3  : no wave chunk signature
003952  004273  //       : -2  : bad wave file format
003953  004274  //       : -1  : file not found
003954  004275        
003955  004276  func __reserved55(), 0; // do not remove
003956  004277  func __reserved56(), 0; // do not remove
003957  004278  func __reserved57(), 0; // do not remove
003958  004279  func __reserved58(), 0; // do not remove
003959  004280        
003960  004281        
003961  004282  //------------------------------------------------------------------------------
003962  004283  // FILEIO Error Code Constants
003963  004284  //------------------------------------------------------------------------------
003964  004285  #CONST
003965  004311  #END
003966  004312        
003967  004313  //------------------------------------------------------------------------------
003968  004314  // DISK struct offsets
003969  004315  //------------------------------------------------------------------------------
003970  004316  #CONST
003971  004333  #END
003972  004334        
003973  004335  //------------------------------------------------------------------------------
003974  004336  // FILE struct offsets
003975  004337  //------------------------------------------------------------------------------
003976  004338  #CONST
003977  004357  #END
003978  004358        
003979  004359        
003980  004360  //------------------------------------------------------------------//
003981  004361  //        Sound Class Services
003982  004362  //------------------------------------------------------------------//
003983  004363        
003984  004364  func snd_Volume("var"), 0;
003985  004365  // Syntax: snd_Volume("var");
003986  004366  // Usage : snd_Volume(30);
003987  004367  // Notes : set sound playback volume.  Var must
003988  004368  //       : be in the range from 8 (min volume)
003989  004369  //       : to 127 (max volume). If var is less
003990  004370  //       : than 8 volume is set to 8, and if
003991  004371  //       : var > 127 it is set to 127.
003992  004372        
003993  004373  func snd_Pitch("pitch"), 1;
003994  004374  // func snd_Pitch("freq"), 1;
003995  004375  // func snd_Pitch(7000), 1; // play the wave file with a sample frequency of 7khz
003996  004376  // Notes : sets the samples playback rate to a different frequency
003997  004377  //       : The minimum value is 4khz
003998  004378  //       : Setting the pitch to zero restores the original sample rate
003999  004379  //       : Return value is the samples original sample rate.
004000  004380        
004001  004381  func snd_BufSize("var"), 0;
004002  004382  // Syntax: snd_BufSize("var");
004003  004383  // Usage : snd_BufSize(2);
004004  004384  // Notes : specify the a memory chunk size for the wavefile buffer.
004005  004385  //       : default size 1024 bytes.
004006  004386  //       : 0 = 1024 bytes (default)
004007  004387  //       : 1 = 2048 bytes
004008  004388  //       : 2 = 4096 bytes
004009  004389  //       : 3 = 8192 bytes
004010  004390        
004011  004391  func snd_Stop(), 0;
004012  004392  // Syntax: snd_Stop();
004013  004393  // Usage : snd_Stop();
004014  004394  // Notes : stop any sound that is playing, releasing
004015  004395  //       : buffers and closes any open wav file.
004016  004396        
004017  004397  func snd_Pause(), 0;
004018  004398  // Syntax: snd_Pause();
004019  004399  // Usage : snd_Pause();
004020  004400  // Notes : pauses any sound that is playing, does nothing
004021  004401  //       : until sound is resumed with snd_Continue().
004022  004402  //       : The sample cam be terminated with snd_Stop.
004023  004403  //       : buffers and closes any open wav file.
004024  004404        
004025  004405  func snd_Continue(), 0;
004026  004406  // Syntax: snd_Continue();
004027  004407  // Usage : snd_Continue();
004028  004408  // Notes : resume any sound that is paused by snd_Pause.
004029  004409        
004030  004410  func snd_Playing(), 1;
004031  004411  // Syntax: snd_Playing();
004032  004412  // Usage : r := snd_Playing();
004033  004413  // Notes : returns 0 if sound has finished playing,
004034  004414  //       : else return number of 512 byte blocks to go.
004035  004415        
004036  004416        
004037  004417  func __reserved59(), 0; // do not remove
004038  004418  func __reserved60(), 0; // do not remove
004039  004419  func __reserved61(), 0; // do not remove
004040  004420  func __reserved62(), 0; // do not remove
004041  004421        
004042  004422  //=========================================================================================================
004043  004423  // String functions
004044  004424  //=========================================================================================================
004045  004425        
004046  004426  func str_Ptr("&var"), 1;
004047  004427  // Syntax: str_Ptr(&var);
004048  004428  // Usage : p := str_Ptr(&var);
004049  004429  // Notes : return a byte pointer to a word region
004050  004430        
004051  004431  func str_GetD("&ptr", "&var"), 1;
004052  004432  // Syntax: str_GetD(&ptr, &var);
004053  004433  // Usage : ok := str_GetD(&ptr, &var);
004054  004434  // Notes : convert number in a string to DWORD ( myvar[2] )
004055  004435  //       : returns true if function succeeds, advancing ptr
004056  004436        
004057  004437  func str_GetW("&ptr", "&var"), 1;
004058  004438  // Syntax: str_GetW(&ptr, &var);
004059  004439  // Usage : ok := str_GetW(&ptr, &var);
004060  004440  // Notes : convert number in a string to WORD ( myvar )
004061  004441  //       : returns true if function succeeds, advancing ptr
004062  004442        
004063  004443  func str_GetHexW("&ptr", "&var"), 1;
004064  004444  // Syntax: str_GetHexW(&ptr, &var);
004065  004445  // Usage : ok := str_GetHexW(&ptr, &var);
004066  004446  // Notes : convert HEX number in a string to WORD ( myvar )
004067  004447  //       : returns true if function succeeds, advancing ptr
004068  004448        
004069  004449  func str_GetC("&ptr", "&var"), 1;
004070  004450  // Syntax: str_GetC(&ptr, &var);
004071  004451  // Usage : ok := str_GetC(&ptr, &var);
004072  004452  // Notes : get a valid ascii char in a string to WORD ( myvar )
004073  004453  //       : returns true if function succeeds, advancing ptr
004074  004454        
004075  004455  func str_GetByte("ptr"), 1;
004076  004456  // Syntax: str_GetByte(ptr);
004077  004457  // Usage : myvar := str_GetByte(ptr);
004078  004458  // Notes : get a byte to myvar
004079  004459  //       : returns value
004080  004460        
004081  004461  func str_GetWord("ptr"), 1;
004082  004462  // Syntax: GetWord(ptr);
004083  004463  // Usage : GetWord(ptr);
004084  004464  // Notes : get a word to myvar
004085  004465  //       : returns value
004086  004466        
004087  004467  func str_PutByte("ptr","val"), 0;
004088  004468  // Syntax: str_PutByte(ptr);
004089  004469  // Usage : myvar := str_PutByte(ptr);
004090  004470  // Notes : put a byte at ptr
004091  004471  //       : returns value
004092  004472        
004093  004473  func str_PutWord("ptr","val"), 0;
004094  004474  // Syntax: str_PutWord("ptr","val");
004095  004475  // Usage : str_PutWord(p,100);
004096  004476  // Notes : put word 100 at current pointer location
004097  004477  //       : returns value
004098  004478        
004099  004479  func str_Match("&ptr", "*str"), 1;
004100  004480  // Syntax: str_Match(&ptr, *str);
004101  004481  // Usage : r := str_Match(&p, "hello");
004102  004482  // Notes : Case sensitive match
004103  004483  //       : returns true if function succeded, andvancing pointer to position past
004104  004484  //       : the matched item. Note that any whitespace characters are skipped
004105  004485  //       : in the source string prior to the test.
004106  004486        
004107  004487  func str_MatchI("&ptr", "*str"), 1;
004108  004488  // Syntax: str_MatchI(&ptr, *str);
004109  004489  // Usage : r := str_MatchI(&p, "hello");
004110  004490  // Notes : Case insensitive match
004111  004491  //       : returns true if function succeded, andvancing pointer to position past
004112  004492  //       : the matched item. Note that any whitespace characters are skipped
004113  004493  //       : in the source string prior to the test.
004114  004494        
004115  004495  func str_Find("&ptr", "*str"), 1;
004116  004496  // Syntax: str_Find(&ptr, *str);
004117  004497  // Usage : n := str_Find(&p, "hello");
004118  004498  // Notes : given the address of a pointer to a source string as the
004119  004499  //       : first argument, and a pointer to a test string as the second
004120  004500  //       : argument, attempt to find the position of the matching string
004121  004501  //       : in the source string. The test is performed with case sensitivity.
004122  004502  //       : return 0 if not found, else returns the address of the first
004123  004503  //       : character of the match. NB:- The source pointer is not altered.
004124  004504        
004125  004505  func str_FindI("&ptr", "*str"), 1;
004126  004506  // Syntax: str_Find(&ptr, *str);
004127  004507  // Usage : n := str_Find(&p, "hello");
004128  004508  // Notes : given the address of a pointer to a source string as the
004129  004509  //       : first argument, and a pointer to a test string as the second
004130  004510  //       : argument, attempt to find the position of the matching string
004131  004511  //       : in the source string. The test is performed with no case
004132  004512  //       : sensitivity, eg upper and lower case chars are accepted.
004133  004513  //       : return 0 if not found, else returns the address of the first
004134  004514  //       : character of the match. NB:- The source pointer is not altered.
004135  004515        
004136  004516  func str_Length("ptr"), 1;
004137  004517  // Syntax: str_Length(ptr);
004138  004518  // Usage : len := str_Ptr(mystring);
004139  004519  // Notes : return the length of a byte aligned string excluding terminator
004140  004520        
004141  004521  func str_Printf("&ptr", "*format"), 1;
004142  004522  // Syntax: str_Printf("&ptr", "*format");
004143  004523  // Usage : r := str_Printf(&p, "hello");
004144  004524  // Notes : refer to documentation
004145  004525  //       :
004146  004526        
004147  004527  func str_Cat("dest","src"), 1;
004148  004528  // Syntax: str_Append("&dest","&src");
004149  004529  // Usage : str_Append(&buf,"Hello");
004150  004530  // Notes : Appends a copy of the source string to the destination string.
004151  004531  //       : The terminating null character in destination is overwritten by
004152  004532  //       : the first character of source, and a new null-character is appended
004153  004533  //       : at the end of the new string formed by the concatenation of both in destination.
004154  004534  //       : returns destination.
004155  004535        
004156  004536  func str_CatN("dest","src","count"), 1;
004157  004537  // Syntax: str_Append("&dest","&src","count");
004158  004538  // Usage : str_Append(&buf,"Monday",3);
004159  004539  // Notes : Appends a copy of the source string to the destination string.
004160  004540  //       : The number of characters copied is limited by "count".
004161  004541  //       : The terminating null character in destination is overwritten by
004162  004542  //       : the first character of source, and a new null-character is appended
004163  004543  //       : at the end of the new string formed by the concatenation of both in destination.
004164  004544  //       : returns destination.
004165  004545        
004166  004546        
004167  004547  func str_ByteMove("src", "dest", "count"), 1;
004168  004548  // Syntax   : str_ByteMove(src, dest, bytecount);
004169  004549  // Input    : STR *source points to byte aligned source.
004170  004550  //          : STR *dest   points to byte aligned destination.
004171  004551  //          : VAR count   number of bytes to transfer.
004172  004552  // Usage    : nextpos := str_ByteMove(s, d, 100);
004173  004553  // Notes    : copy bytes from "src" to "dest", stopping only
004174  004554  //          : when "count" is exhausted.
004175  004555  //          : No terminator is appended, it is purely a
004176  004556  //          : byte copy, and any zeroes encountered will
004177  004557  //          : also be copied.
004178  004558  // Returns  : returns a pointer to the end of the destination
004179  004559  //          : (which is "dest" + "count")
004180  004560        
004181  004561        
004182  004562  func str_Copy("dest", "src"), 1;
004183  004563  // Syntax   : str_Copy(dest, src);
004184  004564  // Input    : STR *dest   points to byte aligned destination.
004185  004565  //          : STR *source points to byte aligned source.
004186  004566  // Usage    : nextplace := str_Copy(d, s);
004187  004567  // Notes    : copy a string from "src" to "dest", stopping only
004188  004568  //          : when the end of source string "src" is encountered
004189  004569  //          : (0x00 terminator).
004190  004570  //          : The terminator is always appended, even if "src" is
004191  004571  //          : an empty string.
004192  004572  // Returns  : returns a pointer to the 0x00 string terminator at
004193  004573  //          : end of "dest" (which is "dest" + str_Length(src); )
004194  004574        
004195  004575        
004196  004576  func str_CopyN("dest", "src", "count"), 1;
004197  004577  // Syntax   : str_CopyN(dest, src, bytecount);
004198  004578  // Input    : STR *dest   points to byte aligned destination.
004199  004579  //          : STR *source points to byte aligned source.
004200  004580  //          : VAR count   max number of chars to copy.
004201  004581  // Usage    : nextplace := str_CopyN(d, s, 100);
004202  004582  // Notes    : copy a string from "src" to "dest", stopping only
004203  004583  //          : when "count" is exhausted, or end of source
004204  004584  //          : string "str" is encountered (0x00 string terminator).
004205  004585  //          : The terminator is always appended, even if
004206  004586  //          : "count" is zero, or "src" is a null string.
004207  004587  // Returns  : returns a pointer to the 0x00 string terminator
004208  004588  //          : (which is "dest" + whatever was copied)
004209  004589        
004210  004590        
004211  004591  func __reserved63(), 0; // do not remove
004212  004592  func __reserved64(), 0; // do not remove
004213  004593  func __reserved65(), 0; // do not remove
004214  004594  func __reserved66(), 0; // do not remove
004215  004595        
004216  004596  //=========================================================================================================
004217  004597  // FLASH memory functions
004218  004598  //=========================================================================================================
004219  004599  func flash_GetByte("bank", "ptr"), 1;
004220  004600  // Syntax   : flash_GetByte(bank, ptr);
004221  004601  // Usage    : myvar := flash_GetByte(FLASHBANK_2, 0x0017); // read first byte in data statement of bank 2
004222  004602  // Notes    : Reads a single byte from any flash location.
004223  004603  //          : If the bank is read protected, only the first 2 bytes can be read (0x55, 0xAA)
004224  004604  //          : which is the header signature for a valid program.
004225  004605  // Returns  : the byte value from the location
004226  004606        
004227  004607        
004228  004608  func flash_GetWord("bank", "ptr"), 1;
004229  004609  // Syntax   : flash_GetWord(bank, ptr);
004230  004610  // Usage    : myvar := flash_GetWord(FLASHBANK_2, 0x0000); // read first word in flash bank  (0xAA55)
004231  004611  // Notes    : Reads a single word from any flash location.
004232  004612  //          : The pointer is byte aligned.
004233  004613  //          : If the bank is read protected, only the first word can be read
004234  004614  //          : which is the header signature for a valid program (0xAA55).
004235  004615  // Returns  : the byte value from the location
004236  004616        
004237  004617        
004238  004618  func flash_Copy("bank", "ptr", "dest", "count"), 1;
004239  004619  // Syntax   : flash_Copy(bank, ptr);
004240  004620  // Usage    : myvar := flash_Copy(FLASHBANK_2, 0x1234, mybuf, 20); // read 20 bytes from FLASHBANK_2 starting from 0x1234
004241  004621  // Notes    : Copies bytes from any flash locations to a user buffer.
004242  004622  //          : The destination pointer is byte aligned, so a str_Ptr must be raised to get correct address.
004243  004623  //          : If the bank is read protected, 0 bytes will be read
004244  004624  //          : which is the header signature for a valid program (0xAA55).
004245  004625  // Returns  : the count of bytes transferred.
004246  004626        
004247  004627        
004248  004628  func flash_Run("bank"), 1;
004249  004629  // Syntax    : flash_Run(bankx);
004250  004630  // Usage     : res := flash_Run(FLASHBANK_5);
004251  004631  // Notes     : Restarts the processor, running code from the required
004252  004632  //           : flash bank. bank may be a variable, or one of the
004253  004633  //           : pre-defined constants:-
004254  004634  //           :    FLASHBANK_0                 //0x00
004255  004635  //           :    FLASHBANK_1                 //0x01
004256  004636  //           :    FLASHBANK_2                 //0x02
004257  004637  //           :    FLASHBANK_3                 //0x03
004258  004638  //           :    FLASHBANK_4                 //0x04
004259  004639  //           :    FLASHBANK_5                 //0x05
004260  004640  // returns    : This function should net return as it restarts
004261  004641  //        : the processor and jumps to the required bank,
004262  004642  //        : If it does return, -1 indicates incorrect/invalid
004263  004643  //        : bank number, and -2 indicates no valid program
004264  004644  //        : in the selected bank.
004265  004645        
004266  004646  func flash_Bank(), 1;
004267  004647  // Syntax   : flash_Bank();
004268  004648  // Usage    : myvar := flash_Bank();
004269  004649  // Notes    : Identifies which flash bank the code is running from.
004270  004650  // Returns  : The FLASH bank that code is currently running from, 0-5.
004271  004651        
004272  004652        
004273  004653  func flash_EraseBank("bank", "confirmation"), 1;
004274  004654  // Syntax   : flash_EraseBank(bank, confirmation);
004275  004655  // Usage    : result := flash_EraseBank(FLASHBANK_3, 0xDEAD); // erase an entire flash bank, confirm overwrite of protected program
004276  004656  // Notes    : This function should be used with extreme caution.
004277  004657  //          : The selected bank will be completely erased regardless of FLASH_WRITE_PROTECT status
004278  004658  //          : if the confirmation value is set to hex 0xDEAD. If confirmation is any other value,
004279  004659  //          : a protected bank will not be erased, and function will return with 0
004280  004660  //          : If the destination bank is the same as the execution bank, the processor will reset
004281  004661  //          : upon completion of erase. If the "bank" argument is set to ALL (-1) and confirmation is set to 0xDEAD
004282  004662  //          : FLASHBANK_0 thru FLASHBANK_5 are cleared.
004283  004663  //          : Used with caution, this is a good way to 'clean up' the entire flash when starting new projects.
004284  004664  // Returns  : returns true if the function succeeded
004285  004665  //          : NB:- reset processor if program is erasing itself, or the ALL bank option is selected.
004286  004666        
004287  004667  func flash_LoadFile("bank", "filename"), 1;
004288  004668  // Syntax   : flash_LoadFile(bank, ptr);
004289  004669  // Usage    : result := flash_LoadFile(FLASHBANK_2, "TETRIS10.EXE"); // load the file from disk into FLASHBANK_2
004290  004670  // Notes    : Copies a file from uSD to the required flashbank.
004291  004671  //          : The destination bank cannont be the execution bank, or a bank that is write protected
004292  004672  // Returns  : returns true if the function succeeded.
004293  004673        
004294  004674        
004295  004675  func flash_WriteBlock("sourceptr", "bank", "page"), 1;
004296  004676  // Syntax   : flash_WriteBlock(pbuf, bank, page);
004297  004677  // Usage    : result := flash_WriteBlock(buffer, FLASHBANK_5, 8); // store the 2k buffer to FLASHBANK_5, location 16384
004298  004678  // Notes    : Copies a 2kbyte buffer to the required flashbank in block 0-15.
004299  004679  //          : The address of each block is 0, 2048, 4096 etc, determined by the page number 0-15.
004300  004680  //          : The destination bank cannot be an execution bank, or a program bank that is write protected.
004301  004681  // Returns  : returns true if the function succeeded.
004302  004682        
004303  004683        
004304  004684  func flash_putstr("bank", "ptr"), 1;
004305  004685  // Syntax   : flash_putstr(bank, ptr);
004306  004686  // Usage    : flash_Copy(FLASHBANK_2, 350); // print a string from FLASHBANK_2, location 350
004307  004687  // Notes    : Works the same as putstr, however, the source of the asciiz string is in FLASH storage
004308  004688  //          : Output may be redirected with the to(..) function. Bit15 of ptr is assumed 0.
004309  004689  // Returns  : True if function succeeds, usually ignored. 0 if bank is read protected
004310  004690        
004311  004691  func flash_Blit16("bank", "offset", "count"), 1;
004312  004692  // Syntax   : flash_Blit16(bank, offset, pixelcount);
004313  004693  // Usage    : disp_setGRAM(10,10,29,29); flash_Blit16(FLASHBANK_5, 2048, 400); // display image at 10,10 (20 pixels square) from FLASH image source (800 bytes)
004314  004694  // Notes    : Blit an image to a GRAM window from FLASH storage.
004315  004695  //          : Image is stored 16bits per pixel (565) in a linear fashion to suit the GRAM mechanism
004316  004696  // Returns  : actual count (normally same as count, will be lower if bank bounds exceeded)
004317  004697        
004318  004698  func flash_Blit8("bank", "offset", "count"), 1;
004319  004699  // Syntax   : flash_Blit8(bank, offset, pixelcount);
004320  004700  // Usage    : disp_setGRAM(10,10,29,29); flash_Blit8(FLASHBANK_5, 2048, 400); // display image at 10,10 (20 pixels square) from FLASH image source (400 bytes)
004321  004701  // Notes    : Blit an image to a GRAM window from FLASH storage.
004322  004702  //          : Image is stored 8 bits per pixel (332 format) in a linear fashion to suit the GRAM mechanism
004323  004703  // Returns  : actual count (normally same as count, will be lower if bank bounds exceeded)
004324  004704        
004325  004705  func flash_Blit4("bank", "offset", "count", "palette16colour"), 1;
004326  004706  // Syntax   : flash_Blit16(bank, offset, pixelcount, pal16);
004327  004707  // Usage    : disp_setGRAM(10,10,29,29); flash_Blit4(FLASHBANK_5, 2048, 400); // display image at 10,10 (20 pixels square) from FLASH image source (200 bytes packed 4:4)
004328  004708  // Notes    : Blit an image to a GRAM window from FLASH storage.
004329  004709  //          : Image is stored in a linear fashion to suit the GRAM mechanism, palette is 16 x 16bit colours
004330  004710  // Returns  : actual count (normally same as count, will be lower if bank bounds exceeded)
004331  004711        
004332  004712  func flash_Blit2("bank", "offset", "count", "palette4colour"), 1;
004333  004713  // Syntax   : flash_Blit16(bank, offset, pixelcount, pal4);
004334  004714  // Usage    : disp_setGRAM(10,10,29,29); flash_Blit2(FLASHBANK_5, 2048, 400); // display image at 10,10 (20 pixels square) from FLASH image source (100 bytes packed 2:2:2:2)
004335  004715  // Notes    : Blit an image to a GRAM window from FLASH storage.
004336  004716  //          : Image is stored in a linear fashion to suit the GRAM mechanism, palette is 4 x 16bit colours
004337  004717  // Returns  : actual count (normally same as count, will be lower if bank bounds exceeded)
004338  004718        
004339  004719  func flash_Blit1("bank", "offset", "count", "pallete2colour"), 1;
004340  004720  // Syntax   : flash_Blit1(bank, offset, pixelcount, pal2);
004341  004721  // Usage    : disp_setGRAM(10,10,29,29); flash_Blit1(FLASHBANK_5, 2048, 400); // display image at 10,10 (20 pixels square) from FLASH image source (50 bytes packed 1:1:1:1:1:1:1:1)
004342  004722  // Notes    : Blit an image to a GRAM window from FLASH storage.
004343  004723  //          : Image is stored in a linear fashion to suit the GRAM mechanism, palette is 2 x 16bit colours
004344  004724  // Returns  : actual count (normally same as count, will be lower if bank bounds exceeded)
004345  004725        
004346  004726  func flash_Exec("bank", "arglistptr"), 1;
004347  004727  // Syntax: res := flash_Exec("bank","arglistptr");
004348  004728  // Usage : res := flash_Exec("bank","arglistptr");
004349  004729  // Notes : returns like a function, current program
004350  004730  //       : calling program is kept active and control returns to it.
004351  004731  //       : If arglistptr is 0, no arguments are passed, else
004352  004732  //       : arglist points to an array, the first element being
004353  004733  //       : the number of elements in the array.
004354  004734  //       : func 'main' in the called bank accepts the arguments.
004355  004735  // WARNING Not currently implemented!
004356  004736        
004357  004737        
004358  004738  func __reserved68(), 0; // do not remove
004359  004739  func __reserved69(), 0; // do not remove
004360  004740  func __reserved70(), 0; // do not remove
004361  004741        
004362  004742  //=========================================================================================================
004363  004743  // I/O and hardware functions
004364  004744  //=========================================================================================================
004365  004745        
004366  004746        
004367  004747        
004368  004748        
004369  004749  func pin_Pulseout("pin", "value"), 1;        // non blocking (program execution continues during pulse)
004370  004750  func pin_PulseoutB("pin", "value"), 1;    // blocking (program execution suspended during pulse)
004371  004751  // Syntax: pin_Pulseout(pin, value);
004372  004752  // Usage : pin_Pulseout(PA3, 100);                 // output 100msec pulse on PA3
004373  004753  // Notes : only available on PA0 to PA9
004374  004754  //       : Invert the state of an output for "value" milliseconds.
004375  004755  //       : pulseout is non blocking, that is, code execution may continue while
004376  004756  //       : a pulse is occuring, and pulses can occur on multiple pins simultaneously.
004377  004757  //       : If not already an output, pin is automatically made a push/pull output,
004378  004758  //       : and the last state of its output latch will determine pulse polarity.
004379  004759  //       : It's its open drain state is not altered if the pin was already an output.
004380  004760  //       : If pulseout is called while pulseout is still active, the pulse timer
004381  004761  //       : will simply be updated with the new "value" and the pulse will continue
004382  004762  //       : with the extended value.
004383  004763  //       : returns true if the pin number is legal (usually ignored)
004384  004764        
004385  004765        
004386  004766  func pin_Counter("pin", "mode", "OVFfunction"), 1;
004387  004767  // Syntax: pin_Counter(pin, mode, userfunc);
004388  004768  // Usage : pin_Counter(PA5, 1, stopfunc);         // count rising edge pulses on pin PA5, call stopfunc on overflow
004389  004769  // Notes : only available on PA4 to PA9
004390  004770  //       : Connect a counter to a pin to count transistions, and optionally call an event function
004391  004771  //       : when the 16bit counter wraps from 0xFFFF to zero. The counter can be read or written
004392  004772  //       : to at any time with peekW and pokeW, therefore, the count may be set to eg 0xFFF0 so that eg:
004393  004773  //       : user function "OVFfuction" will be called after 16 pulses. If "OVFfunction" is set to zero, only the
004394  004774  //       : counter will increment, and simply wrap back to zero from 0xFFFF. If "OVFfunction" points to a user
004395  004775  //       : function, wnen the event fires, pin_Counter will be disabled, and will need to be re-armed (ie '1shot' operation)
004396  004776  //       : The pin may be configured as an input or output, the function behaves the same.
004397  004777  //       : All six pin counters may be active simultaneously, and the maximum frequency of pin transistions
004398  004778  //       : should not exceed a few Khz in mode 1 and 2and are usually used for simple process control counting.
004399  004779  //       : "mode" has the following effect:-
004400  004780  //       : mode COUNT_OFF(0)  = disconnect the counter from the pin, "OVFfunction" therefore ignored, and counting is inhibited.
004401  004781  //       : mode COUNT_RISE(1) = increment on every rising edge
004402  004782  //       : mode COUNT_FALL(2) = increment on every falling edge
004403  004783  //       : mode COUNT_EDGE(3) = increment on every rising and falling edge
004404  004784        
004405  004785  //------------------------------------------------------------------//
004406  004786  // pin counter mode constants                                       //
004407  004787  //------------------------------------------------------------------//
004408  004788  #CONST
004409  004793  #END
004410  004794        
004411  004795  func Qencoder1("PHApin", "PHBpin", "mode"), 1;
004412  004796  // Syntax: Qencoder1(pinA, pinB, mode);
004413  004797  // Usage : Qencoder1(PA4, PA5, stopfunc);         // connect PA4 and PA5 pins to qudrature encoder module #1
004414  004798  // Notes : not available on pins PA14 and PA15
004415  004799  //       : Connect a quadrature encoder to a pair of pins The position counter and delta can be read
004416  004800  //       : or written to at any time with peekW and pokeW using the following constants:-
004417  004801  //       : It is necessary to configure the pins first, depending on your requirements, eg
004418  004802  //       :           pin_Set(PIN_INP_HI, PA4);     // PA4 as input, with pullup to Vcc
004419  004803  //       : or maybe  pin_Set(PIN_INP, PA4);        // PA4 as input, no pullup or pulldown
004420  004804  //       : Returns true if the pin numbers are legal (usually ignored)
004421  004805  //    QEN1_COUNTER_LO
004422  004806  //    QEN1_COUNTER_HI
004423  004807  //    QEN1_DELTA This is reset to 0 when read
004424  004808        
004425  004809  func Qencoder2("PHApin", "PHBpin", "mode"), 1;
004426  004810  // Syntax: Qencoder2(pinA, pinB, mode);
004427  004811  // Usage : Qencoder2(PA4, PA5, stopfunc);         // connect PA4 and PA5 pins to qudrature encoder module #2
004428  004812  // Notes : not available on pins PA14 and PA15
004429  004813  //       : Connect a quadrature encoder to a pair of pins The position counter and delta can be read
004430  004814  //       : or written to at any time with peekW and pokeW using the following constants:-
004431  004815  //       : It is necessary to configure the pins first, depending on your requirements, eg
004432  004816  //       :           pin_Set(PIN_INP_HI, PA4);     // PA4 as input, with pullup to Vcc
004433  004817  //       : or maybe  pin_Set(PIN_INP, PA4);        // PA4 as input, no pullup or pulldown
004434  004818  //       : Returns true if the pin numbers are legal (usually ignored)
004435  004819  //    QEN2_COUNTER_LO
004436  004820  //    QEN2_COUNTER_HI
004437  004821  //    QEN2_DELTA This is reset to 0 when read
004438  004822        
004439  004823        
004440  004824  func Qencoder1Reset(), 0;
004441  004825  // Syntax: Qencoder1Reset();
004442  004826  // Usage : Qencoder1Reset();     // reset the counter and delta value for encoder #1
004443  004827  // Notes :
004444  004828  //    QEN1_COUNTER_LO is reset to zero
004445  004829  //    QEN1_COUNTER_HI is reset to zero
004446  004830  //    QEN1_DELTA is reset to zero
004447  004831        
004448  004832  func Qencoder2Reset(), 0;
004449  004833  // Syntax: Qencoder2Reset();
004450  004834  // Usage : Qencoder2Reset();     // reset the counter and delta value for encoder #2
004451  004835  // Notes :
004452  004836  //    QEN2_COUNTER_LO is reset to zero
004453  004837  //    QEN2_COUNTER_HI is reset to zero
004454  004838  //    QEN2_DELTA is reset to zero
004455  004839        
004456  004840        
004457  004841  func __reserved71(), 0; // do not remove
004458  004842  func __reserved72(), 0; // do not remove
004459  004843        
004460  004844  func pwm_Init("pin", "mode", "value"), 1;    // set pin PA4-PA9 for the required PWM mode and select its source
004461  004845  // Syntax: pwm_Init(pin, value);
004462  004846  // Usage : pwm_Init(PA4, 1, 500);                 // output 50% duty cycle on PA4
004463  004847  // Notes : only available on PA4 to PA9
004464  004848  //       : Mode PWM_OFF(0)    : Turn off the PWM (pin is left as output)
004465  004849  //       : Mode PWM_PLAIN(1)  : Plain PWM value is 0-1000, corresponding to 0-100% duty cycle.
004466  004850  //       :                    : Raw frequency ~70khz. A value of 1 is not valid
004467  004851  //       : Mode PWM_SERVO(2)  : Servo PWM value is 100-200, corresponding to 1.00 to 2.00 ms
004468  004852  //       :                    : Values of 0 to 600 are valid (0-6ms), but should be used with caution.
004469  004853  //       :                    : Repetition rate ~50hz or 20ms
004470  004854  //       : Mode PWM_BINARY(3) : Binary PWM value is 0-1024, corresponding to 0-100% duty cycle.
004471  004855  //       :                    : Raw frequency ~68khz. A value of 1 is not valid
004472  004856  //       : pwm_Init is non blocking and the pwm continues until turn off
004473  004857  //       : Returns true if the pin number is legal (usually ignored)
004474  004858        
004475  004859  //------------------------------------------------------------------------------
004476  004860  // PWM Constants
004477  004861  //------------------------------------------------------------------------------
004478  004862  #CONST
004479  004867  #END
004480  004868        
004481  004869  func __reserved73(), 0; // do not remove
004482  004870  func __reserved74(), 0; // do not remove
004483  004871        
004484  004872  func __reserved75(), 0; // do not remove
004485  004873  func __reserved76(), 0; // do not remove
004486  004874  func __reserved77(), 0; // do not remove
004487  004875  func __reserved78(), 0; // do not remove
004488  004876  func __reserved79(), 0; // do not remove
004489  004877  func __reserved80(), 0; // do not remove
004490  004878        
004491  004879  func sys_PmmC(), 0;
004492  004880  // Syntax: sys_PmmC();
004493  004881  // Usage : to(mystring); sys_PmmC();   // save PmmC name and revision string to buffer
004494  004882  // Notes : print the system PmmC name and revision eg "Diablo16\n1.0"
004495  004883  //       : Can be captured to a buffer using the to( function
004496  004884  //       : Returns nothing.
004497  004885        
004498  004886  func sys_Driver(), 0;
004499  004887  // Syntax: sys_Driver();
004500  004888  // Usage : to(mystring); sys_Driver();   // save Driver name and date string to buffer
004501  004889  // Notes : print the system PmmC name and revision eg "uLCD-32WDTU-A\n130411"
004502  004890  //       : Can be captured to a buffer using the to( function
004503  004891  //       : Returns nothing.
004504  004892        
004505  004893  func gfx_Scope("left", "width", "yzero", "n", "xstep", "Yamp", "colorbg", "&old_y1", "&new_y1", "color1", "&old_y2", "&new_y2", "color2", "&old_y3", "&new_y3", "color3", "&old_y4", "&new_y4", "color4"), 0;
004506  004894  // Notes : Draws up to 4 waveforms from table(s) of vertices at the specified origin.
004507  004895  //       : "Left" is the left margin, "Width" is the width, "yzero" is the y position
004508  004896  //       : that corresponds to a y value of zero, normally "Top" + "Height" for
004509  004897  //       : a graph, or "Top" + "Height"/2 for a scope. "n" is the number of
004510  004898  //       : elements in each buffer. This will need to be greater than "width" for negative
004511  004899  //       : "xstep" values. "Yamp" is for amplification in the Y direction, 100 is unity.
004512  004900  //       : pass 0 as the address for any unused traces
004513  004901  //       : X position is incremented each point by "xstep" pixels.
004514  004902  //       : Y values are derived from a Y buffer "newy" (signed values).
004515  004903  //       : 2 buffers need to be supplied, "newy" contains new
004516  004904  //       : points to be drawn, "oldy" contains most recent set
004517  004905  //       : of points to be un-drawn. After the waveform is drawn,
004518  004906  //       : "newy" buffer is automatically copied to "oldy" buffer.
004519  004907        
004520  004908        
004521  004909  func ana_HS("rate", "samples", "&IO1", "&IO2", "&IO3", "&IO4", "COMPLETEfunction"), 0;
004522  004910  // Syntax: ana_HS(rate, samples, IO1buf, IO2buf, IO3buf, IO4buf, userFunction);
004523  004911  // Usage : ana_HS(1000, 10, IO1buf, 0, 0, 0, myFunc);
004524  004912  // Notes : Collects "samples" samples at "rate" frequency for 0 to 4 analogue pins
004525  004913  //       : and calls "COMPLETEfunction" when done.
004526  004914  //       : "rate" is samples in 100 of samples per second
004527  004915  //       : Any unused IOx pins should have their buffer addresses set to 0
004528  004916  //       : For performance reasons samples are taken in chunks of 32, thus if you
004529  004917  //       : request 33 samples there will be a delay of 31 samples before
004530  004918  //       : "COMPLETEfunction" is called
004531  004919  //       : If Touch is enabled this function should be called no more than once per
004532  004920  //       : millisecond, otherwise touch behaviour could be eratic.
004533  004921        
004534  004922        
004535  004923  func sys_ErrorMessage("msgnum"), 1;
004536  004924        
004537  004925  func __reserved84(), 0; // do not remove
004538  004926  func __reserved85(), 0; // do not remove
004539  004927  func __reserved86(), 0; // do not remove
004540  004928        
004541  004929  //==============================================//
004542  004930  // spi flash device specific functions          //
004543  004931  //==============================================//
004544  004932        
004545  004933  func spiflash_SIG("spi#", "enablepin"), 1;         // read Jedec signature from SPI Flash device
004546  004934  // Syntax   : spiflash_SIG("spi#","enablepin");
004547  004935  // Usage    : var := spiflash_SIG(SPI1, PA0);
004548  004936  // Notes    : A FLASH storage device connected to the selected SPI port, and correctly initialised with the
004549  004937  //          : spi_Init(...) function, the Electronic Signature of the device can be read using this function. The only
004550  004938  //          : devices supported so far are the M25Pxx range of devices which are 512Kbit to 128Mbit Serial Flash Memory.
004551  004939  //          : Other similar devices should also work, provided they do not exceed 128Mbit.
004552  004940  //          : Release from Deep Power-down, and Read Electronic Signature. Only the low order byte is valid, the upper
004553  004941  //          : byte is ignored.
004554  004942        
004555  004943  func spiflash_ID("spi#", "enablepin"), 1;          // read ID code from FLASH device
004556  004944  // Syntax   : spiflash_ID("spi#","enablepin");
004557  004945  // Usage    : var := spiflash_ID(SPI1, PA0);
004558  004946  // Notes    : A FLASH storage device connected to the selected SPI port, and correctly initialised with the
004559  004947  //          : spi_Init(...) function, the memory type and capacity from the flash device can be read using this function
004560  004948  //          : The only devices supported so far M25Pxx range of devices which are 512Kbit to 128Mbit Serial Flash Memory.
004561  004949  //          : Other similar devices should also work, provided they do not exceed 128Mbit.
004562  004950  //          : Reads the memory type and capacity from the serial FLASH device. Hi byte contains type, and low byte
004563  004951  //          : contains capacity. Refer to the device data sheet for further information.
004564  004952        
004565  004953  func spiflash_BulkErase("spi#", "enablepin"), 0;    // erase the entire FLASH device
004566  004954  // Syntax   : spiflash_BulkErase("spi#","enablepin");
004567  004955  // Usage    : spiflash_BulkErase(SPI1, PA0);
004568  004956  // Notes    : A FLASH storage device connected to the selected SPI port, and correctly initialised with the
004569  004957  //          : spi_Init(...) function, the FLASH device can be completely erased using this function. The only devices
004570  004958  //          : supported so far are the M25Pxx range of devices which are 512Kbit to 128Mbit Serial Flash Memory.
004571  004959  //          : Other similar devices should also work, provided they do not exceed 128Mbit.
004572  004960  //          : Erases the entire flash media device. The function returns no value, and the operation can take up to 80
004573  004961  //          : seconds depending on the size of the flash device. Note that not all devices support this command.
004574  004962        
004575  004963  func spiflash_BlockErase("spi#", "enablepin", "block"), 0;            // erase the required 64k flash block
004576  004964  // Syntax   : spiflash_BlockErase("spi#", "enablepin", "block")
004577  004965  // Usage    : var := spiflash_BlockErase(SPI1, PA0, block_num)
004578  004966  // Notes    : A FLASH storage device connected to the selected SPI port, and correctly initialised with the
004579  004967  //          : spi_Init(...) function, the FLASH block can be erased using this function. The only devices supported so
004580  004968  //          : far are the M25Pxx range of devices which are 512Kbit to 128Mbit Serial Flash Memory.
004581  004969  //          : Other similar devices should also work, provided they do not exceed 128Mbit.
004582  004970  //          : E.g. there are 32 x 64K blocks on a 2Mb flash device.
004583  004971  //          : blockAddress The address of the 64k FLASH block to be erased.
004584  004972  //          : Erases the required block in a FLASH media device. The function returns no value, and the operation
004585  004973  //          : can take up to 3 milliseconds.
004586  004974        
004587  004975  func spiflash_SetAdd("spi#", "HiWord", "LoWord"), 0;           // set stream byte address
004588  004976  // Syntax: spiflash_SetAdd(AddHiWord, AddLoWord);
004589  004977  // Usage : spiflash_SetAdd(SPI1, arg1, arg2);
004590  004978  // Notes : Set FLASH internal Address pointer for bytewise access on the specified SPI port
004591  004979        
004592  004980  func spiflash_Read("*dest", "size", "spi#", "enablepin"), 1;
004593  004981  // Syntax: res := spiflash_Read("*dest", "size", "spi#", "enablepin"),
004594  004982  // Usage : res := spiflash_Read(memblock, 20, SPI1, PA0);
004595  004983  // Notes : Reads the specified number of bytes from the FLASH memory device on the specified SPI port and enable pin
004596  004984  //       : into the specified destination. The destination is a string pointer (i.e. BYTE aligned). The source
004597  004985  //       : is the address set by spiflash_SetAdd(), or incremented by subsequent reads or writes.
004598  004986  //       : returns number of characters read
004599  004987  //       : if "dest" is zero, data is read direct to GRAM window
004600  004988  //       :
004601  004989        
004602  004990  func spiflash_Write("*source", "size", "spi#", "enablepin"), 1;
004603  004991  // Syntax: res := fwrite("*source", "size", "spi#", "enablepin"),
004604  004992  // Usage : res := fwrite(memblock, 20, SPI1, PA0);
004605  004993  // Notes : Writes the specified number of bytes to the FLASH memory device on the specified SPI port and enable pin
004606  004994  //       : from the specified source. The source is a standard address or pointer (i.e. WORD aligned). The target
004607  004995  //       : is the address set by spiflash_SetAdd(), or incremented by subsequent reads or writes.
004608  004996  //       : returns number of bytes written
004609  004997  //       :
004610  004998        
004611  004999  func spiflash_Image("x", "y", "spi#", "enablepin"), 1;
004612  005000  // Syntax: spiflash_Image(x, y, "spi#", "enablepin");
004613  005001  // Usage : spiflash_Image(10, 10, SPI1, PA0);
004614  005002  // Notes : Display an image from a file at the current FLASH position set by spiflash_SetAdd()
004615  005003  //       : The image is displayed at x,y (with respect to top left corner).
004616  005004        
004617  005005  func spiflash_PutC("char", "spi#", "enablepin"), 0;
004618  005006  // Syntax: spiflash_PutC("char", "spi#", "enablepin");
004619  005007  // Usage : spiflash_PutC('x', SPI1, PA0);
004620  005008  // Notes : Writes a character (or byte) to the FLASH memory device on the specified SPI port and enable pin
004621  005009  //       : from the specified source. The source is a standard address or pointer (i.e. WORD aligned). The target
004622  005010  //       : is the address set by spiflash_SetAdd(), or incremented by subsequent reads or writes.
004623  005011        
004624  005012  func spiflash_GetC("spi#", "enablepin"), 1;
004625  005013  // Syntax: spiflash_GetC("spi#", "enablepin");
004626  005014  // Usage : mychar := fgetC(SPI1, PA0);
004627  005015  // Notes : Reads a character (or byte) from the FLASH memory device on the specified SPI port and enable pin
004628  005016  //       : into the specified destination. The source is the address set by spiflash_SetAdd(), or incremented
004629  005017  //       : by subsequent reads or writes.
004630  005018  //       : returns next char from file
004631  005019        
004632  005020  func spiflash_PutW("word", "spi#", "enablepin"), 0;
004633  005021  // Syntax: spiflash_PutW("word", "spi#", "enablepin");
004634  005022  // Usage : spiflash_PutW(0x1234, SPI1, PA0);
004635  005023  // Notes : Writes a word to the FLASH memory device on the specified SPI port and enable pin
004636  005024  //       : from the specified source. The source is a standard address or pointer (i.e. WORD aligned). The target
004637  005025  //       : is the address set by spiflash_SetAdd(), or incremented by subsequent reads or writes.
004638  005026        
004639  005027  func spiflash_GetW("spi#", "enablepin"), 1;
004640  005028  // Syntax: spiflash_GetW("spi#", "enablepin");
004641  005029  // Usage : myword := fgetW(SPI1, PA0);
004642  005030  // Notes : Reads a word from the FLASH memory device on the specified SPI port and enable pin
004643  005031  //       : into the specified destination. The source is the address set by spiflash_SetAdd(), or incremented
004644  005032  //       : by subsequent reads or writes.
004645  005033  // Notes : returns next word in file
004646  005034        
004647  005035  func spiflash_PutS("*source", "spi#", "enablepin"), 1;
004648  005036  // Syntax: res := spiflash_Puts("*source", "spi#", "enablepin"),
004649  005037  // Usage : res := spiflash_Puts(mystring, SPI1, PA0);
004650  005038  // Notes : Writes a string to the FLASH memory device on the specified SPI port and enable pin
004651  005039  //       : from the specified source. The source is a standard address or pointer (i.e. WORD aligned). The target
004652  005040  //       : is the address set by spiflash_SetAdd(), or incremented by subsequent reads or writes.
004653  005041  //       : returns number of characters written
004654  005042  //       :
004655  005043        
004656  005044  func spiflash_GetS("*string", "size", "spi#", "enablepin"), 1;
004657  005045  // Syntax: res := spiflash_Gets("*string", "size", "spi#", "enablepin");
004658  005046  // Usage : res := spiflash_Gets(mystr , 81, SPI1, PA0); // read up to 80 chars
004659  005047  // Notes : Reads a string from the FLASH memory device on the specified SPI port and enable pin
004660  005048  //       : into the specified destination. The source is the address set by spiflash_SetAdd(), or incremented
004661  005049  //       : by subsequent reads or writes.
004662  005050  //       : returns pointer to string or null if failed.
004663  005051  //       : spiflash_GetS(...) automatically appends a null-terminator to the data read.
004664  005052  //       : NB:- only reads up to "size-1" characters into "string"
004665  005053  //       : spiflash_GetS(...) will stop reading when any of the following conditions are true:
004666  005054  //       : A] It has read n-1 bytes (one character is reserved for the null-terminator)
004667  005055  //       : B] It encounters a newline character (a line-feed in the compilers tested here), or
004668  005056  //       : C] It reaches the end of file
004669  005057  //       : D] A read error occurs.
004670  005058        
004671  005059  func spiflash_LoadFunction("spi#", "enablepin"), 1;
004672  005060  // Syntax: res := spiflash_LoadFunction("spi#", "enablepin");
004673  005061  // Usage : myfunc := spiflash_LoadFunction(SPI1, PA0);
004674  005062  // Notes : Load a function or program from the FLASH memory device on the specified SPI port and enable pin at
004675  005063  //       : the address set by spiflash_SetAdd(), or incremented by subsequent reads or writes and
004676  005064  //       : return a function pointer to the allocation.
004677  005065  //       : The function can then be invoked just like any other
004678  005066  //       : function would be called via a function pointer.
004679  005067  //       : Parameters may be passed to it in a conventional way.
004680  005068  //       : The function may be discarded at any time when no
004681  005069  //       : longer required, thus freeing its memory resources.
004682  005070  //       : The loaded function can be discarded with mem_Free(..)
004683  005071  //       : eg:
004684  005072  //       : popupWindow := spiflash_LoadFunction("popupWindow1.4fn");
004685  005073  //       : if(!popupWindow) goto LoadFunctionFailed; // could not load the function !!!
004686  005074  //       : then elsewhere in your program:-
004687  005075  //       : res := popupWindow(MYMODE,"My Title","My Popup Text");
004688  005076  //       : if(res == QUIT_APPLICATION) goto exitApp;
004689  005077  //       : Later in your program, when popupWindow is no longer
004690  005078  //       : required for the application:-
004691  005079  //       : res := mem_Free(popupWindow);
004692  005080  //       : if(!res) goto FreeFunctionFailed; // should never happen if memory not corrupted
004693  005081  //       : The callers stack is shared by the loaded function,
004694  005082  //       : however any global variables in the loaded function
004695  005083  //       : are private to that function.
004696  005084  //
004697  005085        
004698  005086  func spiflash_Run("spi#", "enablepin", "arglistptr"), 1;
004699  005087  // Syntax: res := spiflash_Run("spi#", "enablepin", "arglistptr");
004700  005088  // Usage : res := spiflash_Run(SPI1, PA0, argptr);
004701  005089  // Notes : current program releases any allocated memory but
004702  005090  //       : retains the stack and global memory.
004703  005091  //       : If arglistptr is 0, no arguments are passed, else
004704  005092  //       : arglist points to an array, the first element being
004705  005093  //       : the number of elements in the array.
004706  005094  //       : func 'main' in the called program accepts
004707  005095  //       : the arguments, if any. The arguments can only
004708  005096  //       : be passed by value, no pointers or references can be
004709  005097  //       : used as all memory is cleared before the file
004710  005098  //       : is loaded. Refer to spiflash_Exec and spiflash_LoadFunction
004711  005099  //       : for functions that can pass by reference.
004712  005100        
004713  005101  func spiflash_Exec("spi#", "enablepin", "arglistptr"), 1;
004714  005102  // Syntax: res := spiflash_Exec("spi#", "enablepin", "arglistptr");
004715  005103  // Usage : res := spiflash_Exec(SPI1, PA0, "arglistptr");
004716  005104  // Notes : returns like a function, current program
004717  005105  //       : calling program is kept active and control returns to it.
004718  005106  //       : If arglistptr is 0, no arguments are passed, else
004719  005107  //       : arglist points to an array, the first element being
004720  005108  //       : the number of elements in the array.
004721  005109  //       : func 'main' in the called program accepts the arguments.
004722  005110  //       : This function is similar to spiflash_LoadFunction(...), however,
004723  005111  //       : the function argument list is passed by pointer, and
004724  005112  //       : the memory consumed by the function is released as
004725  005113  //       : soon as the function completes.
004726  005114        
004727  005115  func spiflash_LoadImageControl("spi#", "enablepin"), 1;
004728  005116  // Syntax: hImagelist := spiflash_LoadImageControl ("spi#", "enablepin"),
004729  005117  // Usage : hImagelist := spiflash_LoadImageControl (SPI1, PA0);
004730  005118  // Notes : Reads a control file to create an image list from the FLASH memory device on the specified SPI port
004731  005119  //       : and enable pin. The source is the address set by spiflash_SetAdd(), or incremented by subsequent reads
004732  005120  //       : or writes. The ".dat" file is first and is immediately followed a ^Z and then by the ".gci' file.
004733  005121  //       : Returns NULL if function fails.
004734  005122  //       : Returns a handle (pointer to the memory allocation) to the
004735  005123  //       : image control list that has been created.
004736  005124        
004737  005125  // Notes : This function Calculates the size of a chunk of memory required for
004738  005126  //       : a image list and populates it from the image control file ("*.dat")
004739  005127  //       : therefore, when imagelist is no longer required, you must de-allocate
004740  005128  //       : the image list memory by using eg:- mem_Free(hImagelist);
004741  005129  //       : to restore the heap.
004742  005130  //       :
004743  005131        
004744  005132  func spiflash_PlayWAV("spi#", "enablepin"), 1;
004745  005133  // Syntax: spiflash_PlayWAV("spi#", "enablepin");
004746  005134  // Usage : spiflash_PlayWAV(SPI1, PA0);
004747  005135  // Notes : Play a wave file from the FLASH memory device on the specified SPI port and enable pin.
004748  005136  //       : The source is the address set by spiflash_SetAdd(), or incremented by subsequent reads
004749  005137  //       : or writes.
004750  005138  //       : This function automatically grabs a chunk
004751  005139  //       : of memory for a file buffer, and a wave
004752  005140  //       : buffer. The minimum memory requirement is
004753  005141  //       : about 580 bytes for the disk io service and
004754  005142  //       : a minimum wave buffer size of 1024. The size
004755  005143  //       : of the wave buffer allocation
004756  005144  //       : can be increased by the snd_BufSize function.
004757  005145  //       : The default size 1024 bytes.
004758  005146  //       : NB the memory is only required during the
004759  005147  //       : duration of play, and is automatically
004760  005148  //       : released while not in use.
004761  005149  //       : See the Sound Class services for other associated controls.
004762  005150  //       : If there are no errors, returns number of blocks to play (1 to 32767)
004763  005151  //       : If errors occured, the folling is returned
004764  005152  //       : -7  : Insufficient memory available for WAV buffer and file
004765  005153  //       : -6  : cant play this rate
004766  005154  //       : -5  : no data chunk found in first rsector
004767  005155  //       : -4  : no format data
004768  005156  //       : -3  : no wave chunk signature
004769  005157  //       : -2  : bad wave file format
004770  005158  //       : -1  : file not found
004771  005159        
004772  005160  //==============================================//
004773  005161  // more com functions                           //
004774  005162  //==============================================//
004775  005163        
004776  005164  func com1_TXblock("buf", "bufsize"), 0;                       // commence a block transmission
004777  005165  // Syntax   : com1_TXblock("buf", "bufsize");
004778  005166  // Usage    : com1_TXblock(mybuf, 30);                         // point to the TX buffer and send 30 character
004779  005167  // *Notes   : Bufsize bytes are transmitted to the serial port from the string pointer "buf".
004780  005168  //          : if a transmit buffer is active and space is available this function will return almost
004781  005169  //          : immediately otherwise it will block until until the space is available, or the data is transmitted.
004782  005170        
004783  005171  func com1_RXblock("buf", "bufsize"), 0;                       // commence a block reception
004784  005172  // Syntax   : com1_RXblock("buf", "bufsize");
004785  005173  // Usage    : com1_RXblock(mybuf, 30);                        // point to the RX buffer and receive 30 character
004786  005174  // *Notes   : Bufsize bytes are received from the serial port to the string pointer "buf".
004787  005175  //          : if a receive buffer is active and bufsize characters are available this function will return almost
004788  005176  //          : immediately otherwise it will block until until the required bytes are received.
004789  005177        
004790  005178  func com2_TXblock("buf", "bufsize"), 0;                       // commence a block transmission
004791  005179  // Syntax   : com_TXblock("buf", "bufsize");
004792  005180  // Usage    : com_TXblock(mybuf, 30);                         // point to the TX buffer and send 30 character
004793  005181  // *Notes   : Bufsize bytes are transmitted to the serial port from the string pointer "buf".
004794  005182  //          : if a transmit buffer is active and space is available this function will return almost
004795  005183  //          : immediately otherwise it will block until until the space is available, or the data is transmitted.
004796  005184        
004797  005185  func com2_RXblock("buf", "bufsize"), 0;                       // commence an block reception
004798  005186  // Syntax   : com_RXblock("buf", "bufsize");
004799  005187  // Usage    : com_RXblock(mybuf, 30);                        // point to the RX buffer and receive 30 character
004800  005188  // *Notes   : Bufsize bytes are received from the serial port to the string pointer "buf".
004801  005189  //          : if a receive buffer is active and bufsize characters are available this function will return almost
004802  005190  //          : immediately otherwise it will block until until the required bytes are received.
004803  005191        
004804  005192  func com3_TXblock("buf", "bufsize"), 0;                       // commence a block transmission
004805  005193  // Syntax   : com_TXblock("buf", "bufsize");
004806  005194  // Usage    : com_TXblock(mybuf, 30);                         // point to the TX buffer and send 30 character
004807  005195  // *Notes   : Bufsize bytes are transmitted to the serial port from the string pointer "buf".
004808  005196  //          : if a transmit buffer is active and space is available this function will return almost
004809  005197  //          : immediately otherwise it will block until until the space is available, or the data is transmitted.
004810  005198        
004811  005199  func com3_RXblock("buf", "bufsize"), 0;                       // commence an block reception
004812  005200  // Syntax   : com_RXblock("buf", "bufsize");
004813  005201  // Usage    : com_RXblock(mybuf, 30);                        // point to the RX buffer and receive 30 character
004814  005202  // *Notes   : Bufsize bytes are received from the serial port to the string pointer "buf".
004815  005203  //          : if a receive buffer is active and bufsize characters are available this function will return almost
004816  005204  //          : immediately otherwise it will block until until the required bytes are received.
004817  005205        
004818  005206  func disp_BlitPixelsFromCOM1(), 0;                     // Writes current GRAM window pixels to the display from the COM port
004819  005207  // Syntax: disp_BlitPixelsFromCOM1();                  New in v1.1
004820  005208  // Usage : disp_BlitPixelsFromCOM1();
004821  005209  // Notes : Writes the number of pixels defined by the last disp_setGRAM() call to the 
004822  005210  //       : display from the specified com port.
004823  005211        
004824  005212  func disp_BlitPixelsFromCOM2(), 0;                     // Writes current GRAM window pixels to the display from the COM port
004825  005213  // Syntax: disp_BlitPixelsFromCOM2();                  New in v1.1
004826  005214  // Usage : disp_BlitPixelsFromCOM2();
004827  005215  // Notes : Writes the number of pixels defined by the last disp_setGRAM() call to the 
004828  005216  //       : display from the specified com port.
004829  005217        
004830  005218  func disp_BlitPixelsFromCOM3(), 0;                     // Writes current GRAM window pixels to the display from the COM port
004831  005219  // Syntax: disp_BlitPixelsFromCOM3();                  New in v1.1
004832  005220  // Usage : disp_BlitPixelsFromCOM3();
004833  005221  // Notes : Writes the number of pixels defined by the last disp_setGRAM() call to the 
004834  005222  //       : display from the specified com port.
004835  005223        
004836  005224        
004837  005225  //==============================================//
004838  005226  // crc generation functions                     //
004839  005227  //==============================================//
004840  005228        
004841  005229  func crc_CSUM_8("buf","count"), 1;                      // given a pointer to a buffer and a byte count, calculate the 8bit LRC
004842  005230  // *Notes   : (if you calculate all of the incoming data
004843  005231  //          : INCLUDING the CRC, the result should be 0x00
004844  005232  //          : This is equivalent to simple addition of all bytes
004845  005233  //          : and returning the negated sum an 8 bit value.
004846  005234  //          : For the standard test string "123456789",
004847  005235  //          : crc_CSUM_8 will return 0x0023.
004848  005236        
004849  005237        
004850  005238  func crc_16("buf","count"), 1;                      // given a pointer to a buffer and a byte count, calculate CRC16
004851  005239  // *Notes   : The "mode" argument may be READ, WRITE or CHECK
004852  005240  //          : (if you calculate all of the incoming data
004853  005241  //          : INCLUDING the CRC, the result should be 0x0000
004854  005242  //          : For the standard test string "123456789",
004855  005243  //          : crc_16 will return 0xBB3D.
004856  005244        
004857  005245        
004858  005246  func crc_MODBUS("buf","count"), 1;                  // given a pointer to a buffer and a byte count, calculate CRC16 for MODBUS
004859  005247  // *Notes   : (if you calculate all of the incoming data
004860  005248  //          : INCLUDING the CRC, the result should be 0x0000
004861  005249  //          : For the standard test string "123456789",
004862  005250  //          : crc_MODBUS will return 0x4B37.
004863  005251        
004864  005252        
004865  005253  func crc_CCITT("buf","count","seed"), 1;            // given a pointer to a buffer, byte count and seed, calculate the 16bit CRC for seed
004866  005254  // *Notes   : (if you calculate all of the incoming data
004867  005255  //          : INCLUDING the CRC, the result should be 0x0000
004868  005256  //          : For the standard test string "123456789",
004869  005257  //          : crc_CCITT will return the following:-
004870  005258  //          : seed = 0 (XMODEM protocol) result = 0x31C3
004871  005259  //          : seed = 0xFFFF, result = 0x29B1
004872  005260  //          : seed = 0x1D0F, result = 0xE5CC
004873  005261        
004874  005262        
004875  005263  //------------------------------------------------------------------//
004876  005264  // CONSTANTS
004877  005265  //------------------------------------------------------------------//
004878  005266        
004879  005267  #CONST
004880  005271  #END
004881  005272        
004882  005273  // timebase constants for timebase_init
004883  005274  // NB only TB2 and TB4 can be used for synchronous A2D sampling.
004884  005275  #CONST
004885  005286  #END
004886  005287        
004887  005288        
004888  005289  // generic constants
004889  005290  #CONST
004890  005298  #END
004891  005299        
004892  005300        
004893  005301        
004894  005302  //gfx_Get() related constants
004895  005303  #CONST
004896  005312  #END
004897  005313        
004898  005314        
004899  005315        
004900  005316        
004901  005317  #CONST
004902  005330  #END
004903  005331        
004904  005332        
004905  005333  #CONST
004906  005358  #END
004907  005359        
004908  005360        
004909  005361        
004910  005362        
004911  005363  // timer control  related constants
004912  005364  #CONST
004913  005373  #END
004914  005374        
004915  005375        
004916  005376        
004917  005377  //------------------------------------------------------------------------------
004918  005378  // system WORD variables accesible with peekW and pokeW or pointer access
004919  005379  // Note that the txt_Set variables (0-15) and gfx_set variables (16-31)
004920  005380  // can also be accessed with peekW and pokeW
004921  005381  //------------------------------------------------------------------------------
004922  005382        
004923  005383  #CONST
004924  005478  #END
004925  005479        
004926  005480  #CONST
004927  005645  #END
004928  005646        
004929  005647        
004930  005648        
004931  005649  //==================================================================================================
004932  005650        
004933  005651        
004934  005652        
004935  000013      #ENDIF
004936  000014        
004937  000015        
004938  000016  //===========================================================================================
004939  000017        
004940  000018        
004941  000002        
004942  000003  // TODO: draw menu in respective loop.
004943  000004  // TODO: if there is something in the serial buffer can't cut.
004944  000005  // or use bus_SetChangeInterrupt(), how to update display tho.
004945  000006  // TODO: check input data that it doesn't exceed max dimensions
004946  000007        
file C:\Program Files (x86)\4D Labs\4D Workshop 4 IDE\include\4DGL_16bitColours.fnc

004947  000008  #inherit "4DGL_16bitColours.fnc"
004948  000008  #inherit "4DGL_16bitColours.fnc"
004949  000004  */
004950  000005        
004951  000006        
004952  000007        
004953  000008  #CONST
004954  000149  #END
004955  000150        
004956  000009        
file C:\Program Files (x86)\4D Labs\4D Workshop 4 IDE\include\VisualConst.inc

004957  000010  #inherit "VisualConst.inc"
004958  000010  #inherit "VisualConst.inc"
004959  000001  // Line Patterns
004960  000002  #constant  LPCOARSE    0xF0F0
004961  000002  #constant  LPCOARSE    0xF0F0
004962  000003  #constant  LPMEDIUM    0x3333
004963  000003  #constant  LPMEDIUM    0x3333
004964  000004  #constant  LPFINE      0xAAAA
004965  000004  #constant  LPFINE      0xAAAA
004966  000005  #constant  LPDASHDOT   0x03CF
004967  000005  #constant  LPDASHDOT   0x03CF
004968  000006  #constant  LPDASHDOTDOT 0x0333
004969  000006  #constant  LPDASHDOTDOT 0x0333
004970  000007  #constant  LPSOLID     0x0000
004971  000007  #constant  LPSOLID     0x0000
004972  000011        
file C:\Users\Chiuwe\Desktop\4D_Projects\GUI\Torch_GUI.4DWork\Torch_GUIConst.inc

004973  000012  #inherit "Torch_GUIConst.inc"
004974  000012  #inherit "Torch_GUIConst.inc"
004975  000001  // File generated 5/14/2014 5:43:17 PM
004976  000002  // Warning! This is a generated file, any manual changes will be
004977  000003  // lost during the next generation.
004978  000004        
004979  000005  // object indexes into ImageControl
004980  000006  #CONST
004981  000007  #END
004982  000008        
004983  000009  var disk, hndl ;
004984  000013        
004985  000014  // enum types
004986  000015  #constant line := 1, rectangle, circle, arc
004987  000015  #constant line := 1, rectangle, circle, arc
004988  000016  #constant NULL '\0'
004989  000016  #constant NULL '\0'
004990  000017  #constant false 0
004991  000017  #constant false 0
004992  000018  #constant true 1
004993  000018  #constant true 1
004994  000019  #constant max 30
004995  000019  #constant max 30
004996  000020  #constant maxBuff 50
004997  000020  #constant maxBuff 50
004998  000021  #constant DBG 0
004999  000021  #constant DBG 0
005000  000022        
005001  000023  var state, x, y, count, checkCount;
005002  000024  // TODO: shape to alloc() to this array to support edit function.
005003  000025  var list[max];
005004  000026  var checkList[max];
005005  000027  var cutBuffer[maxBuff];
005006  000028  var cutBuffer1[maxBuff];
005007  000029  var shapeParam[5] := [-1, 13, 13, 10, 16];
5008  0010
5009  0011
5010  0012
5011  0013
5012  0014
5013  0015
5014  0016
5015  0017
5016  0018
5017  0019
005018  000030        
005019  000031  func welcomeScreen()
005020  000032        
005021  000033      // TODO: should check if system is zeroed before beginning.
005022  000034        
005023  000035      gfx_Cls();
005024  000036      putstrCentred(400, 240, "Tap to begin.");
005025  000037      while (!(touch_Get(TOUCH_STATUS)))
005026  000038      wend
005027  000039        
005028  000040      mainMenu();
005029  000041  endfunc
005030  000042        
005031  000043  func updateGlobal()
005032  000044      state := touch_Get(TOUCH_STATUS);
005033  000045      x := touch_Get(TOUCH_GETX);
005034  000046      y := touch_Get(TOUCH_GETY);
005035  000047        
005036  000048      if(state == TOUCH_MOVING && DBG)                           // if there's movement
005037  000049          gfx_MoveTo(712,470);
005038  000050          txt_FGcolour(WHITE);
005039  000051          txt_BGcolour(BLACK);
005040  000052          print("X:",[DEC3ZB] x," Y:", [DEC3ZB] y);
005041  000053          txt_FGcolour(LIME);
005042  000054      endif
005043  000055  endfunc
005044  000056        
005045  000057  func printNumber(var *arr)
005046  000058      var i;
005047  000059        
005048  000060      print(arr[0], ".");
005049  000061      for(i := 0; i < arr[1]; i++)
005050  000062          print("0");
005051  000063      next
005052  000064      print(arr[2]);
005053  000065  endfunc
005054  000066        
005055  000067  // TODO: draw checkboxs.
005056  000068  func cutListPreview()
005057  000069      var i;
005058  000070        
005059  000071      gfx_MoveTo(165, 10);
005060  000072      txt_FGcolour(WHITE);
005061  000073      txt_BGcolour(BLACK);
005062  000074      print("Cut List\n");
005063  000075        
005064  000076      for(i := 0; i < count; i++)
005065  000077          switch(*(list[i]))
005066  000078              case line:
005067  000079                  print("Line: (");
005068  000080                  printNumber(list[i] + 1);
005069  000081                  print(", ");
005070  000082                  printNumber(list[i] + 4);
005071  000083                  print(") -> (");
005072  000084                  printNumber(list[i] + 7);
005073  000085                  print(", ");
005074  000086                  printNumber(list[i] + 10);
005075  000087                  print(")\n");
005076  000088              break;
005077  000089              case rectangle:
005078  000090                  print("Rectangle: (");
005079  000091                  printNumber(list[i] + 1);
005080  000092                  print(", ");
005081  000093                  printNumber(list[i] + 4);
005082  000094                  print(") W: ");
005083  000095                  printNumber(list[i] + 7);
005084  000096                  print(" H: ");
005085  000097                  printNumber(list[i] + 10);
005086  000098                  // TODO: change number in shapeParam[]
005087  000099                  //print("Rot: ");
005088  000100                  //printNumber(list[i] + 13);
005089  000101                  //print("deg.");
005090  000102                  print("\n");
005091  000103              break;
005092  000104              case circle:
005093  000105                  print("Circle: (");
005094  000106                  printNumber(list[i] + 1);
005095  000107                  print(", ");
005096  000108                  printNumber(list[i] + 4);
005097  000109                  print("), R: ");
005098  000110                  printNumber(list[i] + 7);
005099  000111                  print("\n");
005100  000112              break;
005101  000113              case arc:
005102  000114                  print("Arc: (");
005103  000115                  printNumber(list[i] + 1);
005104  000116                  print(", ");
005105  000117                  printNumber(list[i] + 4);
005106  000118                  print("), R: ");
005107  000119                  printNumber(list[i] + 7);
005108  000120                  print(" Start: ");
005109  000121                  printNumber(list[i] + 10);
005110  000122                  print(" deg. End: ");
005111  000123                  printNumber(list[i] + 13);
005112  000124                  print(" deg.\n");
005113  000125              break;
005114  000126          endswitch
005115  000127      next
005116  000128  endfunc
005117  000129        
005118  000130  func shapeMenu()
005119  000131        
005120  000132      gfx_Cls();
005121  000133      gfx_Button2(1, 0, 0, 150, 75, LIGHTGREY,BLACK,"Line");
005122  000134      gfx_Button2(1, 0, 75, 150, 75, LIGHTGREY,BLACK,"Rectangle");
005123  000135      gfx_Button2(1, 0, 150, 150, 75, LIGHTGREY,BLACK,"Circle");
005124  000136      gfx_Button2(1, 0, 225, 150, 75, LIGHTGREY,BLACK, "Arc");
005125  000137      gfx_Button2(0, 0, 300, 150, 75, LIGHTGREY, BLACK, "Ellipse");
005126  000138      gfx_Button2(1, 0, 405, 150, 75, LIGHTGREY, BLACK, "Main Menu");
005127  000139  endfunc
005128  000140        
005129  000141  func shapeLoop()
005130  000142      var exit;
005131  000143      var *param;
005132  000144        
005133  000145      while(!exit)
005134  000146          updateGlobal();
005135  000147        
005136  000148          if(state == TOUCH_PRESSED)
005137  000149              if(x >= 0 && x <= 150)
005138  000150                  if(y >= 0 && y <= 75)           // Lines
005139  000151                      param := lineParam();
005140  000152                  else if(y >= 75 && y <= 150)    // Rectangles
005141  000153                      param := rectParam();
005142  000154                  else if(y >= 150 && y <= 225)   // Circles
005143  000155                      param := cirParam();
005144  000156                  else if(y >= 225 && y <= 300)   // Arcs
005145  000157                      param := arcParam();
005146  000158                  else if(y >= 300 && y <= 375)
005147  000159                      param := ellipseParam();
005148  000160                  else if(y >= 405 && y <= 480)   // Main Menu
005149  000161                      exit := 1;
005150  000162                  endif
005151  000163              endif
005152  000164          endif
005153  000165        
005154  000166          if(param)
005155  000167              list[count] := param;
005156  000168              if(DBG)
005157  000169                  var i;
005158  000170        
005159  000171                  gfx_MoveTo(200, 0);
005160  000172                  print(param, " == ", list[count], "\n");
005161  000173                  for(i := 0; i < shapeParam[*(list[count])]; i++)
005162  000174                      print(*(list[count] + i), "\n");
005163  000175                  next
005164  000176              endif
005165  000177              count++;
005166  000178              param := NULL;
005167  000179          endif
005168  000180      wend
005169  000181        
005170  000182      mainMenu();
005171  000183  endfunc
005172  000184        
005173  000185  func shapeInputTemplate()
005174  000186        
005175  000187      gfx_Cls();
005176  000188      gfx_Line(5, 5, 30, 5, RED);
005177  000189      gfx_TriangleFilled(30, 10, 35, 5, 30, 0, RED);
005178  000190      gfx_Line(5, 5, 5, 30, BLUE);
005179  000191      gfx_TriangleFilled(0, 30, 10, 30, 5, 35, BLUE);
005180  000192      gfx_MoveTo(40, 0);
005181  000193      txt_BGcolour(BLACK);
005182  000194      txt_FGcolour(RED);
005183  000195      print("X");
005184  000196      gfx_MoveTo(2, 40);
005185  000197      txt_FGcolour(BLUE);
005186  000198      print("Y");
005187  000199      gfx_CircleFilled(5, 5, 2, YELLOW);
005188  000200      gfx_Button2(1, 530, 0, 90, 120, LIGHTGREY, BLACK, "7");
005189  000201      gfx_Button2(1, 620, 0, 90, 120, LIGHTGREY, BLACK, "8");
005190  000202      gfx_Button2(1, 710, 0, 90, 120, LIGHTGREY, BLACK, "9");
005191  000203      gfx_Button2(1, 530, 120, 90, 120, LIGHTGREY, BLACK, "4");
005192  000204      gfx_Button2(1, 620, 120, 90, 120, LIGHTGREY, BLACK, "5");
005193  000205      gfx_Button2(1, 710, 120, 90, 120, LIGHTGREY, BLACK, "6");
005194  000206      gfx_Button2(1, 530, 240, 90, 120, LIGHTGREY, BLACK, "1");
005195  000207      gfx_Button2(1, 620, 240, 90, 120, LIGHTGREY, BLACK, "2");
005196  000208      gfx_Button2(1, 710, 240, 90, 120, LIGHTGREY, BLACK, "3");
005197  000209      gfx_Button2(1, 530, 360, 90, 120, LIGHTGREY, BLACK, "0");
005198  000210      gfx_Button2(1, 620, 360, 90, 120, LIGHTGREY, BLACK, ".");
005199  000211      gfx_Button2(1, 710, 360, 90, 120, LIGHTGREY, CRIMSON, "back");
005200  000212      gfx_Button3(1, 0, 405, 150, 75, RED, BLACK, "CANCEL");
005201  000213      gfx_Button3(1, 380, 405, 150, 75, LIME, BLACK, "ADD");
005202  000214      txt_BGcolour(BLACK);
005203  000215      txt_FGcolour(WHITE);
005204  000216      putstrCentred(270, 445, "NOTE: Units are in inches.");
005205  000217  endfunc
005206  000218        
005207  000219  // This function assumes that updateGlobal() is called beforehand.
005208  000220  func numPadInput()
005209  000221      var val := -1;
005210  000222        
005211  000223      if(y >= 0 && y <= 120)
005212  000224          if(x >= 530 && x <= 620)            // 7
005213  000225              val := 7;
005214  000226          else if(x >= 620 && x <= 710)       // 8
005215  000227              val := 8;
005216  000228          else if(x >= 710 && x <800)         // 9
005217  000229              val := 9;
005218  000230          endif
005219  000231      else if(y >= 120 && y <= 240)
005220  000232          if(x >= 530 && x <= 620)            // 4
005221  000233              val := 4;
005222  000234          else if(x >= 620 && x <= 710)       // 5
005223  000235              val := 5;
005224  000236          else if(x >= 710 && x <800)         // 6
005225  000237              val := 6;
005226  000238          endif
005227  000239      else if(y >= 240 && y <= 360)
005228  000240          if(x >= 530 && x <= 620)            // 1
005229  000241              val := 1;
005230  000242          else if(x >= 620 && x <= 710)       // 2
005231  000243              val := 2;
005232  000244          else if(x >= 710 && x <800)         // 3
005233  000245              val := 3;
005234  000246          endif
005235  000247      else if(y >= 360 && y <= 480)
005236  000248          if(x >= 530 && x <= 620)            // 0
005237  000249              val := 0;
005238  000250          else if(x >= 620 && x <= 710)       // .
005239  000251              val := 10;
005240  000252          else if(x >= 710 && x <800)         // del
005241  000253              val := 11;
005242  000254          endif
005243  000255      endif
005244  000256      return val;
005245  000257  endfunc
005246  000258        
005247  000259  // TODO: make box selection more obvious, change color of box
005248  000260  func lineParam()
005249  000261      var exit, select, num, prevBoxSelect, update, i, j, tmp, param;
005250  000262      var boxSelect := 0xFF;
005251  000263      var dec[4];
005252  000264        
005253  000265      param := mem_AllocZ(shapeParam[line] * 2);    // shape type | before dec | # of 0s | after dec ...
005254  000266      *(param) := line;
005255  000267        
005256  000268      shapeInputTemplate();
005257  000269      gfx_Line(40, 60, 470, 350, WHITE);
005258  000270      gfx_CircleFilled(40, 60, 2, CYAN);
005259  000271      gfx_CircleFilled(470, 350, 2,  CORAL);
005260  000272      txt_BGcolour(BLACK);
005261  000273      txt_FGcolour(CYAN);
005262  000274      gfx_MoveTo(60, 22);
005263  000275      print("Start X: ");
005264  000276      gfx_MoveTo(60, 46);
005265  000277      print("Start Y: ");
005266  000278      txt_FGcolour(CORAL);
005267  000279      gfx_MoveTo(365, 232);
005268  000280      print("End X: ");
005269  000281      gfx_MoveTo(365, 256);
005270  000282      print("End Y: ");
005271  000283      txt_FGcolour(BLACK);
005272  000284      txt_BGcolour(WHITE);
005273  000285        
005274  000286      while(!exit)
005275  000287          if((boxSelect != prevBoxSelect) || update)
005276  000288              gfx_Panel(boxSelect >> 0 & 1, 134, 18, 100, 20, (boxSelect >> 0 & 1) ? WHITE : RED);
005277  000289              gfx_Panel(boxSelect >> 1 & 1, 134, 42, 100, 20, (boxSelect >> 1 & 1) ? WHITE : RED);
005278  000290              gfx_Panel(boxSelect >> 2 & 1, 423, 228, 100, 20, (boxSelect >> 2 & 1) ? WHITE : RED);
005279  000291              gfx_Panel(boxSelect >> 3 & 1, 423, 252, 100, 20, (boxSelect >> 3 & 1) ? WHITE : RED);
005280  000292              prevBoxSelect := boxSelect;
005281  000293              update := false;
005282  000294          endif
005283  000295        
005284  000296          // TODO: helper function to print numbers.
005285  000297        
005286  000298          for(i := 0; i < shapeParam[line] / 3; i++)
005287  000299              switch(i)
005288  000300                  case 0:
005289  000301                      gfx_MoveTo(138, 22);                   // start x
005290  000302                      break;
005291  000303                  case 1:
005292  000304                       gfx_MoveTo(138, 46);                  // start y
005293  000305                      break;
005294  000306                  case 2:
005295  000307                       gfx_MoveTo(427, 232);                 // end x
005296  000308                      break;
005297  000309                  case 3:
005298  000310                       gfx_MoveTo(427, 256);                 // end y
005299  000311                      break;
005300  000312              endswitch
005301  000313              tmp := (i * 3) + 1;
005302  000314              if(*(param + tmp))
005303  000315                  print(*(param + tmp));
005304  000316              endif
005305  000317              if(dec[i])
005306  000318                  print(".");
005307  000319                  for(j := 0; j < *(param + (tmp + 1)); j++)
005308  000320                      print("0");
005309  000321                  next
005310  000322                  if(*(param + (tmp + 2)))
005311  000323                      print(*(param + (tmp + 2)));
005312  000324                  endif
005313  000325              endif
005314  000326          next
005315  000327        
005316  000328          updateGlobal();
005317  000329          if(state == TOUCH_PRESSED)
005318  000330              // TODO: figure out why ternary doesn't work
005319  000331              if(x >= 134 && x <= 234 && y >= 18 && y <= 38)           // start x box
005320  000332                  if(*(param + 3) || dec[0])
005321  000333                      select := 3;
005322  000334                  else
005323  000335                      select := 1;
005324  000336                  endif
005325  000337                  boxSelect := 0xFF ^ (1 << 0);
005326  000338              else if(x >= 134 && x <= 234 && y >= 42 && y <= 62)     // start y box
005327  000339                  if(*(param + 6) || dec[1])
005328  000340                      select := 6;
005329  000341                  else
005330  000342                      select := 4;
005331  000343                  endif
005332  000344                  boxSelect := 0xFF ^ (1 << 1);
005333  000345              else if(x >= 423 && x <= 523 && y >= 228 && y <= 248)    // end x box
005334  000346                  if(*(param + 9) || dec[2])
005335  000347                      select := 9;
005336  000348                  else
005337  000349                      select := 7;
005338  000350                  endif
005339  000351                  boxSelect := 0xFF ^ (1 << 2);
005340  000352              else if(x >= 423 && x <= 523 && y >= 252 && y <= 272)    // end y box
005341  000353                  if(*(param + 12) || dec[3])
005342  000354                      select := 12;
005343  000355                  else
005344  000356                      select := 10;
005345  000357                  endif
005346  000358                  boxSelect := 0xFF ^ (1 << 3);
005347  000359              else if(y >= 405 && y <= 480)
005348  000360                  if(x >= 0 && x <= 150)                               // cancel
005349  000361                      exit := -1;
005350  000362                  else if(x >= 380 && x <= 530)                        // add
005351  000363                      exit := 1;
005352  000364                  endif
005353  000365              else
005354  000366                  boxSelect := 0xFF;                                    // deselect box
005355  000367              endif
005356  000368              num := numPadInput();
005357  000369              if(select && (num >= 0))
005358  000370                  if(num == 11)                                        // delete
005359  000371                      if(*(param + select))
005360  000372                          *(param + select) := *(param + select) / 10;
005361  000373                      else
005362  000374                          if(!(select % 3) && dec[(select - 3) / 3])
005363  000375                              if(*(param + (select - 1)))              // determines if # of 0's should be decremented
005364  000376                                  (*(param + (select - 1)))--;
005365  000377                              else                                     // removes decimal point
005366  000378                                  dec[(select - 1) / 3] := false;
005367  000379                                  select := select - 2;
005368  000380                              endif
005369  000381                          endif
005370  000382                      endif
005371  000383                      update := true;
005372  000384                  else if(num == 10)                                   // decimal point
005373  000385                      if((select % 3 == 1) && !dec[(select - 1) / 3])
005374  000386                          dec[(select - 1) / 3] := true;
005375  000387                          select := select + 2;
005376  000388                      endif
005377  000389                  else                                                 // numbers
005378  000390                      *(param + select) := *(param + select) * 10 + num;
005379  000391                      if(!(select % 3) && dec[(select - 3) / 3] && !num && !*(param + select))
005380  000392                          (*(param + (select - 1)))++;
005381  000393                      endif
005382  000394                  endif
005383  000395              endif
005384  000396              if(boxSelect == 0xFF && num == -1 && !exit)              // deselect box
005385  000397                  select := 0;
005386  000398              endif
005387  000399          endif
005388  000400        
005389  000401          if(DBG)
005390  000402              gfx_MoveTo(0, 0);
005391  000403              print("param:\n");
005392  000404              for(i := 0; i < shapeParam[line]; i++)
005393  000405                  print([HEX](*(param + i)), "\n");
005394  000406              next
005395  000407              print("select: ", select);
005396  000408              gfx_MoveTo(400, 0);
005397  000409              for(i := 0; i < 4; i++)
005398  000410                  print(dec[i], "\n");
005399  000411              next
005400  000412          endif
005401  000413      wend
005402  000414      shapeMenu();
005403  000415        
005404  000416      if(DBG)
005405  000417          gfx_MoveTo(0, 0);
005406  000418          print("param address: ", param, "\n");
005407  000419          for(i := 0; i < shapeParam[line]; i++)
005408  000420              print(*(param + i), "\n");
005409  000421          next
005410  000422      endif
005411  000423     return (exit == 1) ? param : NULL;
005412  000424  endfunc
005413  000425        
005414  000426  // TODO: add degree for rotation.
005415  000427  func rectParam()
005416  000428      var exit, select, num, prevBoxSelect, update, i, j, tmp, param;
005417  000429      var boxSelect := 0xFF;
005418  000430      var dec[5];
005419  000431        
005420  000432      param := mem_AllocZ(shapeParam[rectangle] * 2);    // shape type | before dec | # of 0s | after dec ...
005421  000433      *(param) := rectangle;
005422  000434        
005423  000435      shapeInputTemplate();
005424  000436      gfx_Rectangle(120, 75, 500, 375, WHITE);
005425  000437      gfx_Line(120, 75, 500, 75, MEDIUMBLUE);
005426  000438      gfx_Line(120, 75, 120, 375, LIME);
005427  000439      gfx_CircleFilled(120, 75, 2, CYAN);
005428  000440      txt_BGcolour(BLACK);
005429  000441      txt_FGcolour(CYAN);
005430  000442      gfx_MoveTo(40, 26);
005431  000443      print("X: ");
005432  000444      gfx_MoveTo(40, 50);
005433  000445      print("Y: ");
005434  000446      txt_FGcolour(MEDIUMBLUE);
005435  000447      gfx_MoveTo(250, 34);
005436  000448      print("Width: ");
005437  000449      txt_FGcolour(LIME);
005438  000450      gfx_MoveTo(10, 200);
005439  000451      print("Height: ");
005440  000452      txt_BGcolour(WHITE);
005441  000453      txt_FGcolour(BLACK);
005442  000454        
005443  000455      while(!exit)
005444  000456           if((boxSelect != prevBoxSelect) || update)
005445  000457              gfx_Panel(boxSelect >> 0 & 1, 65, 22, 100, 20, (boxSelect >> 0 & 1) ? WHITE : RED);
005446  000458              gfx_Panel(boxSelect >> 1 & 1, 65, 46, 100, 20, (boxSelect >> 1 & 1) ? WHITE : RED);
005447  000459              gfx_Panel(boxSelect >> 2 & 1, 307, 30, 100, 20, (boxSelect >> 2 & 1) ? WHITE : RED);
005448  000460              gfx_Panel(boxSelect >> 3 & 1, 10, 215, 100, 20, (boxSelect >> 3 & 1) ? WHITE : RED);
005449  000461              prevBoxSelect := boxSelect;
005450  000462              update := false;
005451  000463          endif
005452  000464        
005453  000465          for(i := 0; i < shapeParam[rectangle] / 3; i++)
005454  000466              switch(i)
005455  000467                  case 0:
005456  000468                      gfx_MoveTo(69, 26);                    // X
005457  000469                      break;
005458  000470                  case 1:
005459  000471                       gfx_MoveTo(69, 50);                   // Y
005460  000472                      break;
005461  000473                  case 2:
005462  000474                       gfx_MoveTo(311, 34);                  // Width
005463  000475                      break;
005464  000476                  case 3:
005465  000477                       gfx_MoveTo(14, 219);                  // Height
005466  000478                      break;
005467  000479              endswitch
005468  000480              tmp := (i * 3) + 1;
005469  000481              if(*(param + tmp))
005470  000482                  print(*(param + tmp));
005471  000483              endif
005472  000484              if(dec[i])
005473  000485                  print(".");
005474  000486                  for(j := 0; j < *(param + (tmp + 1)); j++)
005475  000487                      print("0");
005476  000488                  next
005477  000489                  if(*(param + (tmp + 2)))
005478  000490                      print(*(param + (tmp + 2)));
005479  000491                  endif
005480  000492              endif
005481  000493          next
005482  000494        
005483  000495          updateGlobal();
005484  000496          if(state == TOUCH_PRESSED)
005485  000497              // TODO: figure out why ternary doesn't work
005486  000498              if(x >= 65 && x <= 165 && y >= 22 && y <= 42)             // X box
005487  000499                  if(*(param + 3) || dec[0])
005488  000500                      select := 3;
005489  000501                  else
005490  000502                      select := 1;
005491  000503                  endif
005492  000504                  boxSelect := 0xFF ^ (1 << 0);
005493  000505              else if(x >= 65 && x <= 165 && y >= 46 && y <= 66)       // Y box
005494  000506                  if(*(param + 6) || dec[1])
005495  000507                      select := 6;
005496  000508                  else
005497  000509                      select := 4;
005498  000510                  endif
005499  000511                  boxSelect := 0xFF ^ (1 << 1);
005500  000512              else if(x >= 307 && x <= 407 && y >= 30 && y <= 50)      // Width box
005501  000513                  if(*(param + 9) || dec[2])
005502  000514                      select := 9;
005503  000515                  else
005504  000516                      select := 7;
005505  000517                  endif
005506  000518                  boxSelect := 0xFF ^ (1 << 2);
005507  000519              else if(x >= 10 && x <= 110 && y >= 215 && y <= 235)     // Height box
005508  000520                  if(*(param + 12) || dec[3])
005509  000521                      select := 12;
005510  000522                  else
005511  000523                      select := 10;
005512  000524                  endif
005513  000525                  boxSelect := 0xFF ^ (1 << 3);
005514  000526              else if(y >= 405 && y <= 480)
005515  000527                  if(x >= 0 && x <= 150)                               // cancel
005516  000528                      exit := -1;
005517  000529                  else if(x >= 380 && x <= 530)                        // add
005518  000530                      exit := 1;
005519  000531                  endif
005520  000532              else
005521  000533                  boxSelect := 0xFF;                                    // deselect box
005522  000534              endif
005523  000535              num := numPadInput();
005524  000536              if(select && (num >= 0))
005525  000537                  if(num == 11)                                        // delete
005526  000538                      if(*(param + select))
005527  000539                          *(param + select) := *(param + select) / 10;
005528  000540                      else
005529  000541                          if(!(select % 3) && dec[(select - 3) / 3])
005530  000542                              if(*(param + (select - 1)))              // determines if # of 0's should be decremented
005531  000543                                  (*(param + (select - 1)))--;
005532  000544                              else                                     // removes decimal point
005533  000545                                  dec[(select - 1) / 3] := false;
005534  000546                                  select := select - 2;
005535  000547                              endif
005536  000548                          endif
005537  000549                      endif
005538  000550                      update := true;
005539  000551                  else if(num == 10)                                   // decimal point
005540  000552                      if((select % 3 == 1) && !dec[(select - 1) / 3])
005541  000553                          dec[(select - 1) / 3] := true;
005542  000554                          select := select + 2;
005543  000555                      endif
005544  000556                  else                                                 // numbers
005545  000557                      *(param + select) := *(param + select) * 10 + num;
005546  000558                      if(!(select % 3) && dec[(select - 3) / 3] && !num && !*(param + select))
005547  000559                          (*(param + (select - 1)))++;
005548  000560                      endif
005549  000561                  endif
005550  000562              endif
005551  000563              if(boxSelect == 0xFF && num == -1 && !exit)              // deselect box
005552  000564                  select := 0;
005553  000565              endif
005554  000566          endif
005555  000567        
005556  000568          if(DBG)
005557  000569              gfx_MoveTo(0, 0);
005558  000570              print("param:\n");
005559  000571              for(i := 0; i < shapeParam[rectangle]; i++)
005560  000572                  print([HEX](*(param + i)), "\n");
005561  000573              next
005562  000574              print("select: ", select);
005563  000575              gfx_MoveTo(400, 0);
005564  000576              for(i := 0; i < 4; i++)
005565  000577                  print(dec[i], "\n");
005566  000578              next
005567  000579          endif
005568  000580      wend
005569  000581      shapeMenu();
005570  000582        
005571  000583      if(DBG)
005572  000584          gfx_MoveTo(0, 0);
005573  000585          print("param address: ", param, "\n");
005574  000586          for(i := 0; i < shapeParam[rectangle]; i++)
005575  000587              print(*(param + i), "\n");
005576  000588          next
005577  000589      endif
005578  000590      return (exit == 1) ? param : NULL;
005579  000591  endfunc
005580  000592        
005581  000593  func cirParam()
005582  000594      var exit, select, num, prevBoxSelect, update, i, j, tmp, param;
005583  000595      var boxSelect := 0xFF;
005584  000596      var dec[5];
005585  000597        
005586  000598      param := mem_AllocZ(shapeParam[circle] * 2);    // shape type | before dec | # of 0s | after dec ...
005587  000599      *(param) := circle;
005588  000600        
005589  000601      shapeInputTemplate();
005590  000602      gfx_Circle(265, 202, 200, WHITE);
005591  000603      gfx_CircleFilled(265, 202, 2, CYAN);
005592  000604      gfx_LinePattern(0b1100110011001100);
005593  000605      gfx_Line(265, 202, 417, 332, LIME);
005594  000606      gfx_LinePattern(0);
005595  000607      txt_BGcolour(BLACK);
005596  000608      txt_FGcolour(CYAN);
005597  000609      gfx_MoveTo(160, 150);
005598  000610      print("Center X: ");
005599  000611      gfx_MoveTo(160, 174);
005600  000612      print("Center Y: ");
005601  000613      txt_FGcolour(LIME);
005602  000614      gfx_MoveTo(250, 275);
005603  000615      print("Radius:");
005604  000616      txt_BGcolour(WHITE);
005605  000617      txt_FGcolour(BLACK);
005606  000618        
005607  000619      while(!exit)
005608  000620           if((boxSelect != prevBoxSelect) || update)
005609  000621              gfx_Panel(boxSelect >> 0 & 1, 241, 146, 100, 20, (boxSelect >> 0 & 1) ? WHITE : RED);
005610  000622              gfx_Panel(boxSelect >> 1 & 1, 241, 170, 100, 20, (boxSelect >> 1 & 1) ? WHITE : RED);
005611  000623              gfx_Panel(boxSelect >> 2 & 1, 250, 290, 100, 20, (boxSelect >> 2 & 1) ? WHITE : RED);
005612  000624              prevBoxSelect := boxSelect;
005613  000625              update := false;
005614  000626          endif
005615  000627        
005616  000628          for(i := 0; i < shapeParam[circle] / 3; i++)
005617  000629              switch(i)
005618  000630                  case 0:
005619  000631                      gfx_MoveTo(245, 150);                  // Center X
005620  000632                      break;
005621  000633                  case 1:
005622  000634                       gfx_MoveTo(245, 174);                 // Center Y
005623  000635                      break;
005624  000636                  case 2:
005625  000637                       gfx_MoveTo(254, 294);                 // Radius
005626  000638                      break;
005627  000639              endswitch
005628  000640              tmp := (i * 3) + 1;
005629  000641              if(*(param + tmp))
005630  000642                  print(*(param + tmp));
005631  000643              endif
005632  000644              if(dec[i])
005633  000645                  print(".");
005634  000646                  for(j := 0; j < *(param + (tmp + 1)); j++)
005635  000647                      print("0");
005636  000648                  next
005637  000649                  if(*(param + (tmp + 2)))
005638  000650                      print(*(param + (tmp + 2)));
005639  000651                  endif
005640  000652              endif
005641  000653          next
005642  000654        
005643  000655          updateGlobal();
005644  000656          if(state == TOUCH_PRESSED)
005645  000657              // TODO: figure out why ternary doesn't work
005646  000658              if(x >= 241 && x <= 341 && y >= 146 && y <= 166)         // X box
005647  000659                  if(*(param + 3) || dec[0])
005648  000660                      select := 3;
005649  000661                  else
005650  000662                      select := 1;
005651  000663                  endif
005652  000664                  boxSelect := 0xFF ^ (1 << 0);
005653  000665              else if(x >= 241 && x <= 341 && y >= 170 && y <= 190)    // Y box
005654  000666                  if(*(param + 6) || dec[1])
005655  000667                      select := 6;
005656  000668                  else
005657  000669                      select := 4;
005658  000670                  endif
005659  000671                  boxSelect := 0xFF ^ (1 << 1);
005660  000672              else if(x >= 250 && x <= 350 && y >= 290 && y <= 310)    // Radius box
005661  000673                  if(*(param + 9) || dec[2])
005662  000674                      select := 9;
005663  000675                  else
005664  000676                      select := 7;
005665  000677                  endif
005666  000678                  boxSelect := 0xFF ^ (1 << 2);
005667  000679              else if(y >= 405 && y <= 480)
005668  000680                  if(x >= 0 && x <= 150)                               // cancel
005669  000681                      exit := -1;
005670  000682                  else if(x >= 380 && x <= 530)                        // add
005671  000683                      exit := 1;
005672  000684                  endif
005673  000685              else
005674  000686                  boxSelect := 0xFF;                                    // deselect box
005675  000687              endif
005676  000688              num := numPadInput();
005677  000689              if(select && (num >= 0))
005678  000690                  if(num == 11)                                        // delete
005679  000691                      if(*(param + select))
005680  000692                          *(param + select) := *(param + select) / 10;
005681  000693                      else
005682  000694                          if(!(select % 3) && dec[(select - 3) / 3])
005683  000695                              if(*(param + (select - 1)))              // determines if # of 0's should be decremented
005684  000696                                  (*(param + (select - 1)))--;
005685  000697                              else                                     // removes decimal point
005686  000698                                  dec[(select - 1) / 3] := false;
005687  000699                                  select := select - 2;
005688  000700                              endif
005689  000701                          endif
005690  000702                      endif
005691  000703                      update := true;
005692  000704                  else if(num == 10)                                   // decimal point
005693  000705                      if((select % 3 == 1) && !dec[(select - 1) / 3])
005694  000706                          dec[(select - 1) / 3] := true;
005695  000707                          select := select + 2;
005696  000708                      endif
005697  000709                  else                                                 // numbers
005698  000710                      *(param + select) := *(param + select) * 10 + num;
005699  000711                      if(!(select % 3) && dec[(select - 3) / 3] && !num && !*(param + select))
005700  000712                          (*(param + (select - 1)))++;
005701  000713                      endif
005702  000714                  endif
005703  000715              endif
005704  000716              if(boxSelect == 0xFF && num == -1 && !exit)              // deselect box
005705  000717                  select := 0;
005706  000718              endif
005707  000719          endif
005708  000720        
005709  000721          if(DBG)
005710  000722              gfx_MoveTo(0, 0);
005711  000723              print("param:\n");
005712  000724              for(i := 0; i < shapeParam[circle]; i++)
005713  000725                  print([HEX](*(param + i)), "\n");
005714  000726              next
005715  000727              print("select: ", select);
005716  000728              gfx_MoveTo(400, 0);
005717  000729              for(i := 0; i < 4; i++)
005718  000730                  print(dec[i], "\n");
005719  000731              next
005720  000732          endif
005721  000733      wend
005722  000734      shapeMenu();
005723  000735        
005724  000736      if(DBG)
005725  000737          gfx_MoveTo(0, 0);
005726  000738          print("param address: ", param, "\n");
005727  000739          for(i := 0; i < shapeParam[circle]; i++)
005728  000740              print(*(param + i), "\n");
005729  000741          next
005730  000742      endif
005731  000743      return (exit == 1) ? param : NULL;
005732  000744  endfunc
005733  000745        
005734  000746  func arcParam()
005735  000747      var exit, select, num, prevBoxSelect, update, i, j, tmp, param;
005736  000748      var boxSelect := 0xFF;
005737  000749      var dec[5];
005738  000750        
005739  000751      param := mem_AllocZ(shapeParam[arc] * 2);    // shape type | before dec | # of 0s | after dec ...
005740  000752      *(param) := arc;
005741  000753        
005742  000754      shapeInputTemplate();
005743  000755      gfx_Arc(190, 100, 300, 10, 0, 120, 0);
005744  000756      gfx_Line(190, 100, 490, 100, GOLD);
005745  000757      gfx_Line(190, 100, 40, 359, TEAL);
005746  000758      gfx_CircleFilled(190, 100, 2, CYAN);
005747  000759      gfx_LinePattern(0b1100110011001100);
005748  000760      gfx_Line(190, 100, 418, 295, LIME);
005749  000761      gfx_LinePattern(0);
005750  000762      txt_BGcolour(BLACK);
005751  000763      txt_FGcolour(CYAN);
005752  000764      gfx_MoveTo(50, 40);
005753  000765      print("Center X: ");
005754  000766      gfx_MoveTo(50, 64);
005755  000767      print("Center Y: ");
005756  000768      txt_FGcolour(LIME);
005757  000769      gfx_MoveTo(300, 150);
005758  000770      print("Radius:");
005759  000771      gfx_MoveTo(300, 40);
005760  000772      txt_FGcolour(GOLD);
005761  000773      print("Start Degree:");
005762  000774      txt_FGcolour(TEAL);
005763  000775      gfx_MoveTo(130, 230);
005764  000776      print("End Degree:");
005765  000777      txt_BGcolour(WHITE);
005766  000778      txt_FGcolour(BLACK);
005767  000779        
005768  000780      while(!exit)
005769  000781           if((boxSelect != prevBoxSelect) || update)
005770  000782              gfx_Panel(boxSelect >> 0 & 1, 131, 36, 100, 20, (boxSelect >> 0 & 1) ? WHITE : RED);
005771  000783              gfx_Panel(boxSelect >> 1 & 1, 131, 60, 100, 20, (boxSelect >> 1 & 1) ? WHITE : RED);
005772  000784              gfx_Panel(boxSelect >> 2 & 1, 300, 165, 100, 20, (boxSelect >> 2 & 1) ? WHITE : RED);
005773  000785              gfx_Panel(boxSelect >> 3 & 1, 300, 55, 100, 20, (boxSelect >> 3 & 1) ? WHITE : RED);
005774  000786              gfx_Panel(boxSelect >> 4 & 1, 130, 245, 100, 20, (boxSelect >> 4 & 1) ? WHITE : RED);
005775  000787              prevBoxSelect := boxSelect;
005776  000788              update := false;
005777  000789          endif
005778  000790        
005779  000791          for(i := 0; i < shapeParam[arc] / 3; i++)
005780  000792              switch(i)
005781  000793                  case 0:
005782  000794                      gfx_MoveTo(135, 40);                   // Center X
005783  000795                      break;
005784  000796                  case 1:
005785  000797                      gfx_MoveTo(135, 64);                   // Center Y
005786  000798                      break;
005787  000799                  case 2:
005788  000800                      gfx_MoveTo(304, 169);                  // Radius
005789  000801                      break;
005790  000802                  case 3:
005791  000803                      gfx_MoveTo(304, 59);                   // Start Degree
005792  000804                      break;
005793  000805                  case 4:
005794  000806                      gfx_MoveTo(134, 249);                  // End Degree
005795  000807                      break;
005796  000808              endswitch
005797  000809              tmp := (i * 3) + 1;
005798  000810              if(*(param + tmp))
005799  000811                  print(*(param + tmp));
005800  000812              endif
005801  000813              if(dec[i])
005802  000814                  print(".");
005803  000815                  for(j := 0; j < *(param + (tmp + 1)); j++)
005804  000816                      print("0");
005805  000817                  next
005806  000818                  if(*(param + (tmp + 2)))
005807  000819                      print(*(param + (tmp + 2)));
005808  000820                  endif
005809  000821              endif
005810  000822          next
005811  000823        
005812  000824          updateGlobal();
005813  000825          if(state == TOUCH_PRESSED)
005814  000826              // TODO: figure out why ternary doesn't work
005815  000827              if(x >= 131 && x <= 231 && y >= 36 && y <= 56)         // X box
005816  000828                  if(*(param + 3) || dec[0])
005817  000829                      select := 3;
005818  000830                  else
005819  000831                      select := 1;
005820  000832                  endif
005821  000833                  boxSelect := 0xFF ^ (1 << 0);
005822  000834              else if(x >= 131 && x <= 231 && y >= 60 && y <= 80)    // Y box
005823  000835                  if(*(param + 6) || dec[1])
005824  000836                      select := 6;
005825  000837                  else
005826  000838                      select := 4;
005827  000839                  endif
005828  000840                  boxSelect := 0xFF ^ (1 << 1);
005829  000841              else if(x >= 300 && x <= 400 && y >= 165 && y <= 185)    // Radius box
005830  000842                  if(*(param + 9) || dec[2])
005831  000843                      select := 9;
005832  000844                  else
005833  000845                      select := 7;
005834  000846                  endif
005835  000847                  boxSelect := 0xFF ^ (1 << 2);
005836  000848              else if(x >= 300 && x <= 400 && y >= 55 && y <= 75)    // Start Degree box
005837  000849                  if(*(param + 12) || dec[3])
005838  000850                      select := 12;
005839  000851                  else
005840  000852                      select := 10;
005841  000853                  endif
005842  000854                  boxSelect := 0xFF ^ (1 << 3);
005843  000855              else if(x >= 130 && x <= 230 && y >= 245 && y <= 265)    // End Degree box
005844  000856                  if(*(param + 15) || dec[4])
005845  000857                      select := 15;
005846  000858                  else
005847  000859                      select := 13;
005848  000860                  endif
005849  000861                  boxSelect := 0xFF ^ (1 << 4);
005850  000862              else if(y >= 405 && y <= 480)
005851  000863                  if(x >= 0 && x <= 150)                               // cancel
005852  000864                      exit := -1;
005853  000865                  else if(x >= 380 && x <= 530)                        // add
005854  000866                      exit := 1;
005855  000867                  endif
005856  000868              else
005857  000869                  boxSelect := 0xFF;                                    // deselect box
005858  000870              endif
005859  000871              num := numPadInput();
005860  000872              if(select && (num >= 0))
005861  000873                  if(num == 11)                                        // delete
005862  000874                      if(*(param + select))
005863  000875                          *(param + select) := *(param + select) / 10;
005864  000876                      else
005865  000877                          if(!(select % 3) && dec[(select - 3) / 3])
005866  000878                              if(*(param + (select - 1)))              // determines if # of 0's should be decremented
005867  000879                                  (*(param + (select - 1)))--;
005868  000880                              else                                     // removes decimal point
005869  000881                                  dec[(select - 1) / 3] := false;
005870  000882                                  select := select - 2;
005871  000883                              endif
005872  000884                          endif
005873  000885                      endif
005874  000886                      update := true;
005875  000887                  else if(num == 10)                                   // decimal point
005876  000888                      if((select % 3 == 1) && !dec[(select - 1) / 3])
005877  000889                          dec[(select - 1) / 3] := true;
005878  000890                          select := select + 2;
005879  000891                      endif
005880  000892                  else                                                 // numbers
005881  000893                      *(param + select) := *(param + select) * 10 + num;
005882  000894                      if(!(select % 3) && dec[(select - 3) / 3] && !num && !*(param + select))
005883  000895                          (*(param + (select - 1)))++;
005884  000896                      endif
005885  000897                  endif
005886  000898              endif
005887  000899              if(boxSelect == 0xFF && num == -1 && !exit)              // deselect box
005888  000900                  select := 0;
005889  000901              endif
005890  000902          endif
005891  000903        
005892  000904          if(DBG)
005893  000905              gfx_MoveTo(0, 0);
005894  000906              print("param:\n");
005895  000907              for(i := 0; i < shapeParam[arc]; i++)
005896  000908                  print([HEX](*(param + i)), "\n");
005897  000909              next
005898  000910              print("select: ", select);
005899  000911              gfx_MoveTo(400, 0);
005900  000912              for(i := 0; i < 4; i++)
005901  000913                  print(dec[i], "\n");
005902  000914              next
005903  000915          endif
005904  000916      wend
005905  000917      shapeMenu();
005906  000918        
005907  000919      if(DBG)
005908  000920          gfx_MoveTo(0, 0);
005909  000921          print("param address: ", param, "\n");
005910  000922          for(i := 0; i < shapeParam[arc]; i++)
005911  000923              print(*(param + i), "\n");
005912  000924          next
005913  000925      endif
005914  000926      return (exit == 1) ? param : NULL;
005915  000927  endfunc
005916  000928        
005917  000929  func ellipseParam()
005918  000930        
005919  000931  endfunc
005920  000932        
005921  000933  func gasSettings()
005922  000934      var exit;
005923  000935        
005924  000936      gfx_Cls();
005925  000937      txt_Opacity(TRANSPARENT);
005926  000938      txt_Width(4);
005927  000939      txt_Height(4);
005928  000940        
005929  000941      txt_FGcolour(CYAN);
005930  000942      gfx_Panel(1, 22, 10, 300, 105, NAVY);
005931  000943      gfx_MoveTo(26, 14);
005932  000944      print("Plate\nThickness");
005933  000945      txt_FGcolour(NAVY);
005934  000946      gfx_Panel(1, 22, 115, 300, 300, CYAN);
005935  000947      gfx_MoveTo(125, 119);
005936  000948      print("1/8\n1/4\n3/8\n1/2\n3/4\n1");
005937  000949        
005938  000950      txt_FGcolour(CYAN);
005939  000951      gfx_Panel(1, 322, 10, 110, 105, NAVY);
005940  000952      gfx_MoveTo(326, 14);
005941  000953      print("Tip\nNo.");
005942  000954      txt_FGcolour(NAVY);
005943  000955      gfx_Panel(1, 322, 115, 110, 300, CYAN);
005944  000956      gfx_MoveTo(345, 119);
005945  000957      print("00\n0\n0\n1\n2\n2");
005946  000958        
005947  000959      txt_FGcolour(CYAN);
005948  000960      gfx_Panel(1, 432, 10, 205 , 105, NAVY);
005949  000961      gfx_MoveTo(436, 14);
005950  000962      print("Oxygen\nPSIG");
005951  000963      txt_FGcolour(NAVY);
005952  000964      gfx_Panel(1, 432, 115, 205, 300, CYAN);
005953  000965      gfx_MoveTo(500, 119);
005954  000966      print("20\n30\n30\n40\n45\n45");
005955  000967        
005956  000968      txt_FGcolour(CYAN);
005957  000969      gfx_Panel(1, 637, 10, 140, 105, NAVY);
005958  000970      gfx_MoveTo(641, 14);
005959  000971      print("Fuel");
005960  000972      gfx_MoveTo(641, 62);
005961  000973      print("PSIG");
005962  000974      txt_FGcolour(NAVY);
005963  000975      gfx_Panel(1, 637, 115, 140, 300, CYAN);
005964  000976      gfx_MoveTo(660, 119);
005965  000977      print("2.8\n2.8\n2.8\n2.8\n2.8\n2.8");
005966  000978      txt_Opacity(OPAQUE);
005967  000979      txt_Width(1);
005968  000980      txt_Height(1);
005969  000981      txt_FGcolour(LIME);
005970  000982      putstrCentred(400, 450, "Tap to return to Main Menu.");
005971  000983        
005972  000984      while (!exit)
005973  000985          updateGlobal();
005974  000986          if(state == TOUCH_PRESSED)
005975  000987              exit := 1;
005976  000988          endif
005977  000989      wend
005978  000990        
005979  000991      mainMenu();
005980  000992  endfunc
005981  000993        
005982  000994  func thicknessInput()
005983  000995      var exit, prevSelect, select := 0xFF;
005984  000996        
005985  000997      gfx_Cls();
005986  000998      gfx_Panel(1, 325, 90, 150, 20, NAVY);
005987  000999      gfx_Panel(1, 325, 110, 150, 225, GRAY);
005988  001000      gfx_MoveTo(275, 100);
005989  001001      txt_FGcolour(CYAN);
005990  001002      txt_BGcolour(NAVY);
005991  001003      putstrCentred(400, 100, "Plate Thickness");
005992  001004      gfx_Button3(1, 330, 295, 140, 30, LIME, RED, "OK!");
005993  001005        
005994  001006      while(!exit)
005995  001007          if(select != prevSelect)
005996  001008              gfx_RadioButton(select >> 0 & 1, 330, 115, 100, 20, RED, BLACK, "1/8 th");
005997  001009              gfx_RadioButton(select >> 1 & 1, 330, 145, 100, 20, RED, BLACK, "1/4 th");
005998  001010              gfx_RadioButton(select >> 2 & 1, 330, 175, 100, 20, RED, BLACK, "3/8 th");
005999  001011              gfx_RadioButton(select >> 3 & 1, 330, 205, 100, 20, RED, BLACK, "1/2 th");
006000  001012              gfx_RadioButton(select >> 4 & 1, 330, 235, 100, 20, RED, BLACK, "3/4 th");
006001  001013              gfx_RadioButton(select >> 5 & 1, 330, 265, 100, 20, RED, BLACK, "1 inch");
006002  001014              prevSelect := select;
006003  001015          endif
006004  001016          updateGlobal();
006005  001017        
006006  001018          if(state == TOUCH_PRESSED)
006007  001019              if(x >= 330 && x <= 430)
006008  001020                  if(y >= 115 && y <= 135)         // 1/8 th
006009  001021                      select := ~(1 << 0);
006010  001022                  else if(y >= 145 && y <= 165)    // 1/4 th
006011  001023                       select := ~(1 << 1);
006012  001024                  else if(y >= 175 && y <= 195)    // 3/8 th
006013  001025                       select := ~(1 << 2);
006014  001026                  else if(y >= 205 && y <= 225)    // 1/2 th
006015  001027                       select := ~(1 << 3);
006016  001028                  else if(y >= 235 && y <= 255)    // 3/4 th
006017  001029                       select := ~(1 << 4);
006018  001030                  else if(y >= 265 && y <= 285)    // 1 inch
006019  001031                       select := ~(1 << 5);
006020  001032                  endif
006021  001033              endif
006022  001034              if(select != 0xFF && x >= 330 && x <= 470 && y >= 295 && y <= 325)    // ok
006023  001035                  exit := 1;
006024  001036              endif
006025  001037          endif
006026  001038      wend
006027  001039        
006028  001040      return select;
006029  001041  endfunc
006030  001042        
006031  001043  func cutCommand()
006032  001044      var exit, i, j;
006033  001045      var thickness;
006034  001046        
006035  001047      thickness := thicknessInput();
006036  001048        
006037  001049      gfx_Cls();
006038  001050      print("Sending Cut List...\n");
006039  001051      serout1(0x00);
006040  001052      serout1(0x00);
006041  001053      serout1(HIbyte(thickness));
006042  001054      serout1(LObyte(thickness));
006043  001055      for(i := 0; i < count; i++)
006044  001056          for( j := 0; j < shapeParam[*(list[i])]; j++)
006045  001057              serout1(HIbyte(*(list[i] + j)));
006046  001058              serout1(LObyte(*(list[i] + j)));
006047  001059              serout(*(list[i] + j));
006048  001060              if(DBG)
006049  001061                  print(*(list[i]+j), "\n");
006050  001062              endif
006051  001063          next
006052  001064      next
006053  001065        
006054  001066      serout(0xFF);          // cut command.
006055  001067      serout(0xFF);
006056  001068      serout1(0xFF);
006057  001069      serout1(0xFF);
006058  001070        
006059  001071      while (!exit)
006060  001072          updateGlobal();
006061  001073          if(state == TOUCH_PRESSED)
006062  001074              exit := 1;
006063  001075          endif
006064  001076      wend
006065  001077        
006066  001078      mainMenu();
006067  001079  endfunc
006068  001080        
006069  001081  func mainMenu()
006070  001082      var buttonState;
006071  001083        
006072  001084      // TODO: Fix ternary.
006073  001085      if(count)
006074  001086          buttonState := 1;
006075  001087      else
006076  001088          buttonState := 0;
006077  001089      endif
006078  001090        
006079  001091      gfx_Cls();
006080  001092      gfx_Button2(1, 0, 0, 150, 80, LIGHTGREY, BLACK, "Add Shape");
006081  001093      gfx_Button2(0, 0, 160, 150, 80, LIGHTGREY, BLACK, "Save");
006082  001094      gfx_Button2(0, 0, 240, 150, 80, LIGHTGREY, BLACK, "Load");
006083  001095      gfx_Button2(1, 0, 400, 150, 80, LIGHTGREY, BLACK, "Gas Settings");
006084  001096      gfx_Button2(buttonState, 150, 400, 150, 80, LIGHTGREY, BLACK, "Clear List");
006085  001097      gfx_Button2(checkCount, 300, 400, 150, 80, LIGHTGREY, BLACK, "Remove");
006086  001098      // TODO: change state to "checkCount == 1"...
006087  001099      gfx_Button2(0, 450, 400, 150, 80, LIGHTGREY, BLACK, "Edit");
006088  001100      gfx_Button2(buttonState, 650, 400, 150, 80, LIGHTGREY, RED, "Cut");
006089  001101      cutListPreview();
006090  001102  endfunc
006091  001103        
006092  001104  func interrupt()
006093  001105      gfx_Cls();
006094  001106      print("thisworks!");
006095  001107      print(PA13);
006096  001108  endfunc
006097  001109        
006098  001110  func main()
006099  001111      var hstrings ; // Handle to access uSD strings, uncomment if required
006100  001112      var hFontn ;   // Handle to access uSD fonts, uncomment if required and change n to font number
006101  001113  //  Uncomment the following if uSD images, fonts or strings used.
006102  001114        
006103  001115      putstr("Mounting...\n");
006104  001116      if (!(disk:=file_Mount()))
006105  001117          while(!(disk :=file_Mount()))
006106  001118              putstr("Drive not mounted...");
006107  001119              pause(200);
006108  001120              gfx_Cls();
006109  001121              pause(200);
006110  001122          wend
006111  001123      endif
006112  001124  //    gfx_TransparentColour(0x0020);    // uncomment if transparency required
006113  001125  //    gfx_Transparency(ON);             // uncomment if transparency required
006114  001126        
006115  001127      hFontn := file_LoadImageControl("TORCH_~1.dan", "TORCH_~1.gcn", 1); // Open handle to access uSD fonts, uncomment if required and change n to font number dropping a and c if > 9
006116  001128      hstrings := file_Open("TORCH_~1.txf", 'r') ; // Open handle to access uSD strings, uncomment if required
006117  001129      hndl := file_LoadImageControl("TORCH_~1.dat", "TORCH_~1.gci", 1);
006118  001130        
006119  001131        
006120  001132      COM1_RX_pin(PA0);
006121  001133      COM1_TX_pin(PA1);
006122  001134      com1_Init(cutBuffer1, maxBuff * 2, 0);
006123  001135      com_SetBaud(COM1, 9600);
006124  001136      com_Init(cutBuffer, maxBuff * 2, 0);     // setup serial with Arduino
006125  001137      setbaud(6);
006126  001138        
006127  001139      gfx_ScreenMode(LANDSCAPE) ;   // change manually if orientation change
006128  001140      touch_Set(TOUCH_ENABLE);
006129  001141        
006130  001142      //bus_SetChangeInterrupt(interrupt, (1 << M_PA13));
006131  001143      welcomeScreen();
006132  001144        
006133  001145      repeat
006134  001146          updateGlobal();
006135  001147        
006136  001148          if(state == TOUCH_PRESSED)
006137  001149              if(y >= 400 && y <= 480)
006138  001150                  if(x >= 0 && x <= 150)                          // Gas Settings
006139  001151                      gasSettings();
006140  001152                  else if(x >= 150 && x <= 300 && count)          // Clear List
006141  001153                      while(count)
006142  001154                          mem_Free(list[count - 1]);
006143  001155                          count--;
006144  001156                      wend
006145  001157                      mainMenu();
006146  001158                  else if(x >= 300 && x <= 450)                   // Remove
006147  001159                      // TODO: add function.
006148  001160                  else if(x >= 450 && x <= 600)                   // Edit
006149  001161                  else if(x >= 650 && x <= 800 && count)          // Cut
006150  001162                      cutCommand();
006151  001163                  endif
006152  001164              endif
006153  001165              if(x >= 0 && x <= 150)
006154  001166                  if(y >= 0 && y <= 80)                           // Shape Menu
006155  001167                      shapeMenu();
006156  001168                      shapeLoop();
006157  001169                  else if(y >= 160 && y <= 240)                   // Save
006158  001170                  else if(y >= 240 && y <= 320)                   // Load
006159  001171                  endif
006160  001172              endif
006161  001173              // TODO: add checklist... should be dynamic
006162  001174          endif
006163  001175      forever
006164  001176  endfunc
006165  001177        
006166  001178  func colors()
006167  001179      var exit;
006168  001180        
006169  001181      gfx_Cls();
006170  001182      gfx_Button2(1, 0, 0, 80, 34, ALICEBLUE, BLACK, "ALICEBLUE");
006171  001183      gfx_Button2(1, 80, 0, 80, 34, ANTIQUEWHITE, BLACK, "ANTIQUEWHITE");
006172  001184      gfx_Button2(1, 160, 0, 80, 34, AQUA, BLACK, "AQUA");
006173  001185      gfx_Button2(1, 240, 0, 80, 34, AQUAMARINE, BLACK, "AQUAMARINE");
006174  001186      gfx_Button2(1, 320, 0, 80, 34, AZURE, BLACK, "AZURE");
006175  001187      gfx_Button2(1, 400, 0, 80, 34, BEIGE, BLACK, "BEIGE");
006176  001188      gfx_Button2(1, 480, 0, 80, 34, BISQUE, BLACK, "BISQUE");
006177  001189      gfx_Button2(1, 560, 0, 80, 34, BLACK, BLACK, "BLACK");
006178  001190      gfx_Button2(1, 640, 0, 80, 34, BLANCHEDALMOND, BLACK, "BLANCHEDALMOND");
006179  001191      gfx_Button2(1, 720, 0, 80, 34, BLUE, BLACK, "BLUE");
006180  001192        
006181  001193      gfx_Button2(1, 0, 34, 80, 34, BLUEVIOLET, BLACK, "BLUEVIOLET");
006182  001194      gfx_Button2(1, 80, 34, 80, 34, BROWN, BLACK, "BROWN");
006183  001195      gfx_Button2(1, 160, 34, 80, 34, BURLYWOOD, BLACK, "BURLYWOOD");
006184  001196      gfx_Button2(1, 240, 34, 80, 34, CADETBLUE, BLACK, "CADETBLUE");
006185  001197      gfx_Button2(1, 320, 34, 80, 34, CHARTREUSE, BLACK, "CHARTREUSE");
006186  001198      gfx_Button2(1, 400, 34, 80, 34, CHOCOLATE, BLACK, "CHOCOLATE");
006187  001199      gfx_Button2(1, 480, 34, 80, 34, CORAL, BLACK, "CORAL");
006188  001200      gfx_Button2(1, 560, 34, 80, 34, CORNFLOWERBLUE, BLACK, "CORNFLOWERBLUE");
006189  001201      gfx_Button2(1, 640, 34, 80, 34, CORNSILK, BLACK, "CORNSILK");
006190  001202      gfx_Button2(1, 720, 34, 80, 34, CRIMSON, BLACK, "CRIMSON");
006191  001203        
006192  001204      gfx_Button2(1, 0, 68, 80, 34, CYAN, BLACK, "CYAN");
006193  001205      gfx_Button2(1, 80, 68, 80, 34, DARKBLUE, BLACK, "DARKBLUE");
006194  001206      gfx_Button2(1, 160, 68, 80, 34, DARKCYAN, BLACK, "DARKCYAN");
006195  001207      gfx_Button2(1, 240, 68, 80, 34, DARKGOLDENROD, BLACK, "DARKGOLDENROD");
006196  001208      gfx_Button2(1, 320, 68, 80, 34, DARKGRAY, BLACK, "DARKGRAY");
006197  001209      gfx_Button2(1, 400, 68, 80, 34, DARKGREEN, BLACK, "DARKGREEN");
006198  001210      gfx_Button2(1, 480, 68, 80, 34, DARKKHAKI, BLACK, "DARKKHAKI");
006199  001211      gfx_Button2(1, 560, 68, 80, 34, DARKMAGENTA, BLACK, "DARKMAGENTA");
006200  001212      gfx_Button2(1, 640, 68, 80, 34, DARKOLIVEGREEN, BLACK, "DARKOLIVEGREEN");
006201  001213      gfx_Button2(1, 720, 68, 80, 34, DARKORANGE, BLACK, "DARKORANGE");
006202  001214        
006203  001215      gfx_Button2(1, 0, 102, 80, 34, DARKORCHID, BLACK, "DARKORCHID");
006204  001216      gfx_Button2(1, 80, 102, 80, 34, DARKRED, BLACK, "DARKRED");
006205  001217      gfx_Button2(1, 160, 102, 80, 34, DARKSALMON, BLACK, "DARKSALMON");
006206  001218      gfx_Button2(1, 240, 102, 80, 34, DARKSEAGREEN, BLACK, "DARKSEAGREEN");
006207  001219      gfx_Button2(1, 320, 102, 80, 34, DARKSLATEBLUE, BLACK, "DARKSLATEBLUE");
006208  001220      gfx_Button2(1, 400, 102, 80, 34, DARKSLATEGRAY, BLACK, "DARKSLATEGRAY");
006209  001221      gfx_Button2(1, 480, 102, 80, 34, DARKTURQUOISE, BLACK, "DARKTURQUOISE");
006210  001222      gfx_Button2(1, 560, 102, 80, 34, DARKVIOLET, BLACK, "DARKVIOLET");
006211  001223      gfx_Button2(1, 640, 102, 80, 34, DEEPPINK, BLACK, "DEEPPINK");
006212  001224      gfx_Button2(1, 720, 102, 80, 34, DEEPSKYBLUE, BLACK, "DEEPSKYBLUE");
006213  001225        
006214  001226      gfx_Button2(1, 0, 136, 80, 34, DIMGRAY, BLACK, "DIMGRAY");
006215  001227      gfx_Button2(1, 80, 136, 80, 34, DODGERBLUE, BLACK, "DODGERBLUE");
006216  001228      gfx_Button2(1, 160, 136, 80, 34, FIREBRICK, BLACK, "FIREBRICK");
006217  001229      gfx_Button2(1, 240, 136, 80, 34, FLORALWHITE, BLACK, "FLORALWHITE");
006218  001230      gfx_Button2(1, 320, 136, 80, 34, FORESTGREEN, BLACK, "FORESTGREEN");
006219  001231      gfx_Button2(1, 400, 136, 80, 34, FUCHSIA, BLACK, "FUCHSIA");
006220  001232      gfx_Button2(1, 480, 136, 80, 34, GAINSBORO, BLACK, "GAINSBORO");
006221  001233      gfx_Button2(1, 560, 136, 80, 34, GHOSTWHITE, BLACK, "GHOSTWHITE");
006222  001234      gfx_Button2(1, 640, 136, 80, 34, GOLD, BLACK, "GOLD");
006223  001235      gfx_Button2(1, 720, 136, 80, 34, GOLDENROD, BLACK, "GOLDENROD");
006224  001236        
006225  001237      gfx_Button2(1, 0, 170, 80, 34, GRAY, BLACK, "GRAY");
006226  001238      gfx_Button2(1, 80, 170, 80, 34, GREEN, BLACK, "GREEN");
006227  001239      gfx_Button2(1, 160, 170, 80, 34, GREENYELLOW, BLACK, "GREENYELLOW");
006228  001240      gfx_Button2(1, 240, 170, 80, 34, HONEYDEW, BLACK, "HONEYDEW");
006229  001241      gfx_Button2(1, 320, 170, 80, 34, HOTPINK, BLACK, "HOTPINK");
006230  001242      gfx_Button2(1, 400, 170, 80, 34, INDIANRED, BLACK, "INDIANRED");
006231  001243      gfx_Button2(1, 480, 170, 80, 34, INDIGO, BLACK, "INDIGO");
006232  001244      gfx_Button2(1, 560, 170, 80, 34, IVORY, BLACK, "IVORY");
006233  001245      gfx_Button2(1, 640, 170, 80, 34, KHAKI, BLACK, "KHAKI");
006234  001246      gfx_Button2(1, 720, 170, 80, 34, LAVENDER, BLACK, "LAVENDER");
006235  001247        
006236  001248      gfx_Button2(1, 0, 204, 80, 34, LAVENDERBLUSH, BLACK, "LAVENDERBLUSH");
006237  001249      gfx_Button2(1, 80, 204, 80, 34, LAWNGREEN, BLACK, "LAWNGREEN");
006238  001250      gfx_Button2(1, 160, 204, 80, 34, LEMONCHIFFON, BLACK, "LEMONCHIFFON");
006239  001251      gfx_Button2(1, 240, 204, 80, 34, LIGHTBLUE, BLACK, "LIGHTBLUE");
006240  001252      gfx_Button2(1, 320, 204, 80, 34, LIGHTCORAL, BLACK, "LIGHTCORAL");
006241  001253      gfx_Button2(1, 400, 204, 80, 34, LIGHTCYAN, BLACK, "LIGHTCYAN");
006242  001254      gfx_Button2(1, 480, 204, 80, 34, LIGHTGOLD, BLACK, "LIGHTGOLD");
006243  001255      gfx_Button2(1, 560, 204, 80, 34, LIGHTGREEN, BLACK, "LIGHTGREEN");
006244  001256      gfx_Button2(1, 640, 204, 80, 34, LIGHTGREY, BLACK, "LIGHTGREY");
006245  001257      gfx_Button2(1, 720, 204, 80, 34, LIGHTPINK, BLACK, "LIGHTPINK");
006246  001258        
006247  001259      gfx_Button2(1, 0, 238, 80, 34, LIGHTSALMON, BLACK, "LIGHTSALMON");
006248  001260      gfx_Button2(1, 80, 238, 80, 34, LIGHTSEAGREEN, BLACK, "LIGHTSEAGREEN");
006249  001261      gfx_Button2(1, 160, 238, 80, 34, LIGHTSKYBLUE, BLACK, "LIGHTSKYBLUE");
006250  001262      gfx_Button2(1, 240, 238, 80, 34, LIGHTSLATEGRAY, BLACK, "LIGHTSLATEGRAY");
006251  001263      gfx_Button2(1, 320, 238, 80, 34, LIGHTSTEELBLUE, BLACK, "LIGHTSTEELBLUE");
006252  001264      gfx_Button2(1, 400, 238, 80, 34, LIGHTYELLOW, BLACK, "LIGHTYELLOW");
006253  001265      gfx_Button2(1, 480, 238, 80, 34, LIME, BLACK, "LIME");
006254  001266      gfx_Button2(1, 560, 238, 80, 34, LIMEGREEN, BLACK, "LIMEGREEN");
006255  001267      gfx_Button2(1, 640, 238, 80, 34, LINEN, BLACK, "LINEN");
006256  001268      gfx_Button2(1, 720, 238, 80, 34, MAGENTA, BLACK, "MAGENTA");
006257  001269        
006258  001270      gfx_Button2(1, 0, 272, 80, 34, MAROON, BLACK, "MAROON");
006259  001271      gfx_Button2(1, 80, 272, 80, 34, MEDIUMAQUAMARINE, BLACK, "MEDIUMAQUAMARINE");
006260  001272      gfx_Button2(1, 160, 272, 80, 34, MEDIUMBLUE, BLACK, "MEDIUMBLUE");
006261  001273      gfx_Button2(1, 240, 272, 80, 34, MEDIUMORCHID, BLACK, "MEDIUMORCHID");
006262  001274      gfx_Button2(1, 320, 272, 80, 34, MEDIUMPURPLE, BLACK, "MEDIUMPURPLE");
006263  001275      gfx_Button2(1, 400, 272, 80, 34, MEDIUMSEAGREEN, BLACK, "MEDIUMSEAGREEN");
006264  001276      gfx_Button2(1, 480, 272, 80, 34, MEDIUMSLATEBLUE, BLACK, "MEDIUMSLATEBLUE");
006265  001277      gfx_Button2(1, 560, 272, 80, 34, MEDIUMSPRINGGREEN, BLACK, "MEDIUMSPRINGGREEN");
006266  001278      gfx_Button2(1, 640, 272, 80, 34, MEDIUMTURQUOISE, BLACK, "MEDIUMTURQUOISE");
006267  001279      gfx_Button2(1, 720, 272, 80, 34, MEDIUMVIOLETRED, BLACK, "MEDIUMVIOLETRED");
006268  001280        
006269  001281      gfx_Button2(1, 0, 306, 80, 34, MIDNIGHTBLUE, BLACK, "MIDNIGHTBLUE");
006270  001282      gfx_Button2(1, 80, 306, 80, 34, MINTCREAM, BLACK, "MINTCREAM");
006271  001283      gfx_Button2(1, 160, 306, 80, 34, MISTYROSE, BLACK, "MISTYROSE");
006272  001284      gfx_Button2(1, 240, 306, 80, 34, MOCCASIN, BLACK, "MOCCASIN");
006273  001285      gfx_Button2(1, 320, 306, 80, 34, NAVAJOWHITE, BLACK, "NAVAJOWHITE");
006274  001286      gfx_Button2(1, 400, 306, 80, 34, NAVY, BLACK, "NAVY");
006275  001287      gfx_Button2(1, 480, 306, 80, 34, OLDLACE, BLACK, "OLDLACE");
006276  001288      gfx_Button2(1, 560, 306, 80, 34, OLIVE, BLACK, "OLIVE");
006277  001289      gfx_Button2(1, 640, 306, 80, 34, OLIVEDRAB, BLACK, "OLIVEDRAB");
006278  001290      gfx_Button2(1, 720, 306, 80, 34, ORANGE, BLACK, "ORANGE");
006279  001291        
006280  001292      gfx_Button2(1, 0, 340, 80, 34, ORANGERED, BLACK, "ORANGERED");
006281  001293      gfx_Button2(1, 80, 340, 80, 34, ORCHID, BLACK, "ORCHID");
006282  001294      gfx_Button2(1, 160, 340, 80, 34, PALEGOLDENROD, BLACK, "PALEGOLDENROD");
006283  001295      gfx_Button2(1, 240, 340, 80, 34, PALEGREEN, BLACK, "PALEGREEN");
006284  001296      gfx_Button2(1, 320, 340, 80, 34, PALETURQUOISE, BLACK, "PALETURQUOISE");
006285  001297      gfx_Button2(1, 400, 340, 80, 34, PALEVIOLETRED, BLACK, "PALEVIOLETRED");
006286  001298      gfx_Button2(1, 480, 340, 80, 34, PAPAYAWHIP, BLACK, "PAPAYAWHIP");
006287  001299      gfx_Button2(1, 560, 340, 80, 34, PEACHPUFF, BLACK, "PEACHPUFF");
006288  001300      gfx_Button2(1, 640, 340, 80, 34, PERU, BLACK, "PERU");
006289  001301      gfx_Button2(1, 720, 340, 80, 34, PINK, BLACK, "PINK");
006290  001302        
006291  001303      gfx_Button2(1, 0, 374, 80, 34, PLUM, BLACK, "PLUM");
006292  001304      gfx_Button2(1, 80, 374, 80, 34, POWDERBLUE, BLACK, "POWDERBLUE");
006293  001305      gfx_Button2(1, 160, 374, 80, 34, PURPLE, BLACK, "PURPLE");
006294  001306      gfx_Button2(1, 240, 374, 80, 34, RED, BLACK, "RED");
006295  001307      gfx_Button2(1, 320, 374, 80, 34, ROSYBROWN, BLACK, "ROSYBROWN");
006296  001308      gfx_Button2(1, 400, 374, 80, 34, ROYALBLUE, BLACK, "ROYALBLUE");
006297  001309      gfx_Button2(1, 480, 374, 80, 34, SADDLEBROWN, BLACK, "SADDLEBROWN");
006298  001310      gfx_Button2(1, 560, 374, 80, 34, SALMON, BLACK, "SALMON");
006299  001311      gfx_Button2(1, 640, 374, 80, 34, SANDYBROWN, BLACK, "SANDYBROWN");
006300  001312      gfx_Button2(1, 720, 374, 80, 34, SEAGREEN, BLACK, "SEAGREEN");
006301  001313        
006302  001314      gfx_Button2(1, 0, 408, 80, 34, SEASHELL, BLACK, "SEASHELL");
006303  001315      gfx_Button2(1, 80, 408, 80, 34, SIENNA, BLACK, "SIENNA");
006304  001316      gfx_Button2(1, 160, 408, 80, 34, SILVER, BLACK, "SILVER");
006305  001317      gfx_Button2(1, 240, 408, 80, 34, SKYBLUE, BLACK, "SKYBLUE");
006306  001318      gfx_Button2(1, 320, 408, 80, 34, SLATEBLUE, BLACK, "SLATEBLUE");
006307  001319      gfx_Button2(1, 400, 408, 80, 34, SLATEGRAY, BLACK, "SLATEGRAY");
006308  001320      gfx_Button2(1, 480, 408, 80, 34, SNOW, BLACK, "SNOW");
006309  001321      gfx_Button2(1, 560, 408, 80, 34, SPRINGGREEN, BLACK, "SPRINGGREEN");
006310  001322      gfx_Button2(1, 640, 408, 80, 34, STEELBLUE, BLACK, "STEELBLUE");
006311  001323      gfx_Button2(1, 720, 408, 80, 34, TAN, BLACK, "TAN");
006312  001324        
006313  001325      gfx_Button2(1, 0, 442, 80, 34, TEAL, BLACK, "TEAL");
006314  001326      gfx_Button2(1, 80, 442, 80, 34, THISTLE, BLACK, "THISTLE");
006315  001327      gfx_Button2(1, 160, 442, 80, 34, TOMATO, BLACK, "TOMATO");
006316  001328      gfx_Button2(1, 240, 442, 80, 34, TURQUOISE, BLACK, "TURQUOISE");
006317  001329      gfx_Button2(1, 320, 442, 80, 34, VIOLET, BLACK, "VIOLET");
006318  001330      gfx_Button2(1, 400, 442, 80, 34, WHEAT, BLACK, "WHEAT");
006319  001331      gfx_Button2(1, 480, 442, 80, 34, WHITE, BLACK, "WHITE");
006320  001332      gfx_Button2(1, 560, 442, 80, 34, WHITESMOKE, BLACK, "WHITESMOKE");
006321  001333      gfx_Button2(1, 640, 442, 80, 34, YELLOW, BLACK, "YELLOW");
006322  001334      gfx_Button2(1, 720, 442, 80, 34, YELLOWGREEN, BLACK, "YELLOWGREEN");
006323  001335        
006324  001336      while (!exit)
006325  001337          updateGlobal();
006326  001338          if(state == TOUCH_PRESSED)
006327  001339              exit := 1;
006328  001340          endif
006329  001341      wend
006330  001342        
006331  001343      mainMenu();
006332  001344  endfunc
006333  001345        
Notice: no execution path to func 'colors'
Notice: no execution path to func 'interrupt'


Symbol Table:
name                 decimal    hex
__MAXBANKS                             6  0x00000006 (const dword)  (not used)
__MAXMEM                           32768  0x00008000 (const dword)  (usage 1)
__MAXPROG                          32750  0x00007fee (const dword)  (usage 1)
__PLATFORM                             3  0x00000003 (const dword)  (not used)
__reserved1                          -51  0xffffffcd (PmmC func) args[0] r=0  (not used)
__reserved10                        -111  0xffffff91 (PmmC func) args[0] r=0  (not used)
__reserved13                        -123  0xffffff85 (PmmC func) args[0] r=0  (not used)
__reserved14                        -124  0xffffff84 (PmmC func) args[0] r=0  (not used)
__reserved17                        -201  0xffffff37 (PmmC func) args[0] r=0  (not used)
__reserved18                        -202  0xffffff36 (PmmC func) args[0] r=0  (not used)
__reserved19                        -203  0xffffff35 (PmmC func) args[0] r=0  (not used)
__reserved2                          -52  0xffffffcc (PmmC func) args[0] r=0  (not used)
__reserved20                        -204  0xffffff34 (PmmC func) args[0] r=0  (not used)
__reserved21                        -205  0xffffff33 (PmmC func) args[0] r=0  (not used)
__reserved22                        -206  0xffffff32 (PmmC func) args[0] r=0  (not used)
__reserved23                        -220  0xffffff24 (PmmC func) args[0] r=0  (not used)
__reserved24                        -221  0xffffff23 (PmmC func) args[0] r=0  (not used)
__reserved25                        -222  0xffffff22 (PmmC func) args[0] r=0  (not used)
__reserved26                        -223  0xffffff21 (PmmC func) args[0] r=0  (not used)
__reserved3                          -69  0xffffffbb (PmmC func) args[0] r=0  (not used)
__reserved30                        -283  0xfffffee5 (PmmC func) args[0] r=0  (not used)
__reserved4                          -70  0xffffffba (PmmC func) args[0] r=0  (not used)
__reserved42                        -373  0xfffffe8b (PmmC func) args[0] r=0  (not used)
__reserved43                        -387  0xfffffe7d (PmmC func) args[0] r=0  (not used)
__reserved44                        -388  0xfffffe7c (PmmC func) args[0] r=0  (not used)
__reserved45                        -389  0xfffffe7b (PmmC func) args[0] r=0  (not used)
__reserved46                        -390  0xfffffe7a (PmmC func) args[0] r=0  (not used)
__reserved5                          -76  0xffffffb4 (PmmC func) args[0] r=0  (not used)
__reserved51                        -411  0xfffffe65 (PmmC func) args[0] r=0  (not used)
__reserved52                        -412  0xfffffe64 (PmmC func) args[0] r=0  (not used)
__reserved53                        -422  0xfffffe5a (PmmC func) args[0] r=0  (not used)
__reserved54                        -423  0xfffffe59 (PmmC func) args[0] r=0  (not used)
__reserved55                        -455  0xfffffe39 (PmmC func) args[0] r=0  (not used)
__reserved56                        -456  0xfffffe38 (PmmC func) args[0] r=0  (not used)
__reserved57                        -457  0xfffffe37 (PmmC func) args[0] r=0  (not used)
__reserved58                        -458  0xfffffe36 (PmmC func) args[0] r=0  (not used)
__reserved59                        -466  0xfffffe2e (PmmC func) args[0] r=0  (not used)
__reserved6                          -77  0xffffffb3 (PmmC func) args[0] r=0  (not used)
__reserved60                        -467  0xfffffe2d (PmmC func) args[0] r=0  (not used)
__reserved61                        -468  0xfffffe2c (PmmC func) args[0] r=0  (not used)
__reserved62                        -469  0xfffffe2b (PmmC func) args[0] r=0  (not used)
__reserved63                        -490  0xfffffe16 (PmmC func) args[0] r=0  (not used)
__reserved64                        -491  0xfffffe15 (PmmC func) args[0] r=0  (not used)
__reserved65                        -492  0xfffffe14 (PmmC func) args[0] r=0  (not used)
__reserved66                        -493  0xfffffe13 (PmmC func) args[0] r=0  (not used)
__reserved68                        -509  0xfffffe03 (PmmC func) args[0] r=0  (not used)
__reserved69                        -510  0xfffffe02 (PmmC func) args[0] r=0  (not used)
__reserved70                        -511  0xfffffe01 (PmmC func) args[0] r=0  (not used)
__reserved71                        -519  0xfffffdf9 (PmmC func) args[0] r=0  (not used)
__reserved72                        -520  0xfffffdf8 (PmmC func) args[0] r=0  (not used)
__reserved73                        -522  0xfffffdf6 (PmmC func) args[0] r=0  (not used)
__reserved74                        -523  0xfffffdf5 (PmmC func) args[0] r=0  (not used)
__reserved75                        -524  0xfffffdf4 (PmmC func) args[0] r=0  (not used)
__reserved76                        -525  0xfffffdf3 (PmmC func) args[0] r=0  (not used)
__reserved77                        -526  0xfffffdf2 (PmmC func) args[0] r=0  (not used)
__reserved78                        -527  0xfffffdf1 (PmmC func) args[0] r=0  (not used)
__reserved79                        -528  0xfffffdf0 (PmmC func) args[0] r=0  (not used)
__reserved8                         -109  0xffffff93 (PmmC func) args[0] r=0  (not used)
__reserved80                        -529  0xfffffdef (PmmC func) args[0] r=0  (not used)
__reserved84                        -535  0xfffffde9 (PmmC func) args[0] r=0  (not used)
__reserved85                        -536  0xfffffde8 (PmmC func) args[0] r=0  (not used)
__reserved86                        -537  0xfffffde7 (PmmC func) args[0] r=0  (not used)
__reserved9                         -110  0xffffff92 (PmmC func) args[0] r=0  (not used)
__translate                           -8  0xfffffff8 (PmmC func) args[4] r=1  (not used)
ABS                                  -53  0xffffffcb (PmmC func) args[1] r=1  (not used)
ALICEBLUE                          63455  0x0000f7df (const dword)  (usage 2)
ALL                                65535  0x0000ffff (const dword)  (not used)
ana_HS                              -533  0xfffffdeb (PmmC func) args[7] r=0  (not used)
ANTIQUEWHITE                       65370  0x0000ff5a (const dword)  (usage 2)
APPEND                                 0  0x00000000 (const dword)  (not used)
AQUA                                2047  0x000007ff (const dword)  (usage 2)
AQUAMARINE                         32762  0x00007ffa (const dword)  (usage 2)
arc                                    4  0x00000004 (const dword)  (usage 18)
arcParam                            3041  0x00000be1 (User func) args[0] r=0  (usage 3)
AUDIO_ENABLE                          17  0x00000011 (const dword)  (not used)
AZURE                              63487  0x0000f7ff (const dword)  (usage 2)
BACKGROUND_COLOUR                     17  0x00000011 (const dword)  (not used)
BAUD_110                               0  0x00000000 (const dword)  (not used)
BAUD_115200                           13  0x0000000d (const dword)  (not used)
BAUD_1200                              3  0x00000003 (const dword)  (not used)
BAUD_128000                           14  0x0000000e (const dword)  (not used)
BAUD_14400                             7  0x00000007 (const dword)  (not used)
BAUD_19200                             8  0x00000008 (const dword)  (not used)
BAUD_2400                              4  0x00000004 (const dword)  (not used)
BAUD_256000                           15  0x0000000f (const dword)  (not used)
BAUD_300                               1  0x00000001 (const dword)  (not used)
BAUD_300000                           16  0x00000010 (const dword)  (not used)
BAUD_31250                             9  0x00000009 (const dword)  (not used)
BAUD_375000                           17  0x00000011 (const dword)  (not used)
BAUD_38400                            10  0x0000000a (const dword)  (not used)
BAUD_4800                              5  0x00000005 (const dword)  (not used)
BAUD_500000                           18  0x00000012 (const dword)  (not used)
BAUD_56000                            11  0x0000000b (const dword)  (not used)
BAUD_57600                            12  0x0000000c (const dword)  (not used)
BAUD_600                               2  0x00000002 (const dword)  (not used)
BAUD_600000                           19  0x00000013 (const dword)  (not used)
BAUD_9600                              6  0x00000006 (const dword)  (not used)
BEIGE                              63419  0x0000f7bb (const dword)  (usage 2)
BEVEL_RADIUS                          27  0x0000001b (const dword)  (not used)
BEVEL_SHADOW                          29  0x0000001d (const dword)  (not used)
BEVEL_WIDTH                           28  0x0000001c (const dword)  (not used)
BIN                                    2  0x00000002 (const dword)  (not used)
BIN1                                 258  0x00000102 (const dword)  (not used)
BIN10                               2562  0x00000a02 (const dword)  (not used)
BIN10Z                              6658  0x00001a02 (const dword)  (not used)
BIN10ZB                            10754  0x00002a02 (const dword)  (not used)
BIN11                               2818  0x00000b02 (const dword)  (not used)
BIN11Z                              6914  0x00001b02 (const dword)  (not used)
BIN11ZB                            11010  0x00002b02 (const dword)  (not used)
BIN12                               3074  0x00000c02 (const dword)  (not used)
BIN12Z                              7170  0x00001c02 (const dword)  (not used)
BIN12ZB                            11266  0x00002c02 (const dword)  (not used)
BIN13                               3330  0x00000d02 (const dword)  (not used)
BIN13Z                              7426  0x00001d02 (const dword)  (not used)
BIN13ZB                            11522  0x00002d02 (const dword)  (not used)
BIN14                               3586  0x00000e02 (const dword)  (not used)
BIN14Z                              7682  0x00001e02 (const dword)  (not used)
BIN14ZB                            11778  0x00002e02 (const dword)  (not used)
BIN15                               3842  0x00000f02 (const dword)  (not used)
BIN15Z                              7938  0x00001f02 (const dword)  (not used)
BIN15ZB                            12034  0x00002f02 (const dword)  (not used)
BIN16                                  2  0x00000002 (const dword)  (not used)
BIN16Z                              4098  0x00001002 (const dword)  (not used)
BIN16ZB                             8194  0x00002002 (const dword)  (not used)
BIN1Z                               4354  0x00001102 (const dword)  (not used)
BIN1ZB                              8450  0x00002102 (const dword)  (not used)
BIN2                                 514  0x00000202 (const dword)  (not used)
BIN2Z                               4610  0x00001202 (const dword)  (not used)
BIN2ZB                              8706  0x00002202 (const dword)  (not used)
BIN3                                 770  0x00000302 (const dword)  (not used)
BIN3Z                               4866  0x00001302 (const dword)  (not used)
BIN3ZB                              8962  0x00002302 (const dword)  (not used)
BIN4                                1026  0x00000402 (const dword)  (not used)
BIN4Z                               5122  0x00001402 (const dword)  (not used)
BIN4ZB                              9218  0x00002402 (const dword)  (not used)
BIN5                                1282  0x00000502 (const dword)  (not used)
BIN5Z                               5378  0x00001502 (const dword)  (not used)
BIN5ZB                              9474  0x00002502 (const dword)  (not used)
BIN6                                1538  0x00000602 (const dword)  (not used)
BIN6Z                               5634  0x00001602 (const dword)  (not used)
BIN6ZB                              9730  0x00002602 (const dword)  (not used)
BIN7                                1794  0x00000702 (const dword)  (not used)
BIN7Z                               5890  0x00001702 (const dword)  (not used)
BIN7ZB                              9986  0x00002702 (const dword)  (not used)
BIN8                                2050  0x00000802 (const dword)  (not used)
BIN8Z                               6146  0x00001802 (const dword)  (not used)
BIN8ZB                             10242  0x00002802 (const dword)  (not used)
BIN9                                2306  0x00000902 (const dword)  (not used)
BIN9Z                               6402  0x00001902 (const dword)  (not used)
BIN9ZB                             10498  0x00002902 (const dword)  (not used)
BINZ                                4098  0x00001002 (const dword)  (not used)
BINZB                               8194  0x00002002 (const dword)  (not used)
BISQUE                             65336  0x0000ff38 (const dword)  (usage 2)
BLACK                                  0  0x00000000 (const dword)  (usage 414)
BLANCHEDALMOND                     65369  0x0000ff59 (const dword)  (usage 2)
BLUE                                  31  0x0000001f (const dword)  (usage 11)
BLUEVIOLET                         35164  0x0000895c (const dword)  (usage 2)
BOLD                                  16  0x00000010 (const dword)  (not used)
BOTTOM_POS                             5  0x00000005 (const dword)  (not used)
BROWN                              41285  0x0000a145 (const dword)  (usage 2)
BURLYWOOD                          56784  0x0000ddd0 (const dword)  (usage 2)
bus_ClearPins                       -119  0xffffff89 (PmmC func) args[1] r=0  (not used)
BUS_RD_PIN                             4  0x00000004 (const dword)  (not used)
bus_Read                            -117  0xffffff8b (PmmC func) args[0] r=1  (not used)
bus_Read8                           -122  0xffffff86 (PmmC func) args[0] r=1  (not used)
bus_SetChangeInterrupt              -120  0xffffff88 (PmmC func) args[2] r=1  (not used)
bus_SetPins                         -118  0xffffff8a (PmmC func) args[1] r=0  (not used)
BUS_WR_PIN                             3  0x00000003 (const dword)  (not used)
bus_Write8                          -121  0xffffff87 (PmmC func) args[1] r=0  (not used)
BUTTON_DOWN                            0  0x00000000 (const dword)  (not used)
BUTTON_UP                              1  0x00000001 (const dword)  (not used)
ByteSwap                             -49  0xffffffcf (PmmC func) args[1] r=1  (not used)
C:\Users\Chiuwe\Desktop\4D_Projects\GUI\Torch_GUI.4Dg    2710  0x00000a96 (const ??? 0)  (not used)
CADETBLUE                          23796  0x00005cf4 (const dword)  (usage 2)
charheight                           -12  0xfffffff4 (PmmC func) args[1] r=1  (not used)
CHARTREUSE                         32736  0x00007fe0 (const dword)  (usage 2)
charwidth                            -11  0xfffffff5 (PmmC func) args[1] r=1  (not used)
checkCount                            12  0x0000000c (mem) word (global)  (usage 3)
CHECKED                                0  0x00000000 (const dword)  (not used)
checkList                             74  0x0000004a (mem) word[30] (global)Notice: global var 'checkList' is never used
  (not used)
CHOCOLATE                          54083  0x0000d343 (const dword)  (usage 2)
CHR                                  129  0x00000081 (const dword)  (not used)
circle                                 3  0x00000003 (const dword)  (usage 18)
cirParam                            5003  0x0000138b (User func) args[0] r=0  (usage 3)
CLIPPING                              19  0x00000013 (const dword)  (not used)
colors                            UNRESOLVED (User func) args[0] r=0  (not used)
COLOUR16                               0  0x00000000 (const dword)  (not used)
COLOUR8                                1  0x00000001 (const dword)  (not used)
COM0                               63492  0x0000f804 (const dword)  (not used)
COM1                               63493  0x0000f805 (const dword)  (usage 3)
com1_Count                          -249  0xffffff07 (PmmC func) args[0] r=1  (not used)
com1_Error                          -257  0xfffffeff (PmmC func) args[0] r=1  (not used)
com1_Full                           -253  0xffffff03 (PmmC func) args[0] r=1  (not used)
com1_Init                           -233  0xffffff17 (PmmC func) args[3] r=0  (usage 3)
com1_Reset                          -245  0xffffff0b (PmmC func) args[0] r=0  (not used)
COM1_RX_pin                         -226  0xffffff1e (PmmC func) args[1] r=1  (usage 3)
com1_RXblock                        -558  0xfffffdd2 (PmmC func) args[2] r=0  (not used)
com1_Sync                           -261  0xfffffefb (PmmC func) args[0] r=1  (not used)
COM1_TX_pin                         -229  0xffffff1b (PmmC func) args[1] r=1  (usage 3)
com1_TXblock                        -557  0xfffffdd3 (PmmC func) args[2] r=0  (not used)
com1_TXbuffer                       -265  0xfffffef7 (PmmC func) args[3] r=0  (not used)
com1_TXbufferHold                   -277  0xfffffeeb (PmmC func) args[1] r=1  (not used)
com1_TXcount                        -269  0xfffffef3 (PmmC func) args[0] r=1  (not used)
com1_TXemptyEvent                   -273  0xfffffeef (PmmC func) args[1] r=1  (not used)
COM2                               63494  0x0000f806 (const dword)  (not used)
com2_Count                          -250  0xffffff06 (PmmC func) args[0] r=1  (not used)
com2_Error                          -258  0xfffffefe (PmmC func) args[0] r=1  (not used)
com2_Full                           -254  0xffffff02 (PmmC func) args[0] r=1  (not used)
com2_Init                           -234  0xffffff16 (PmmC func) args[3] r=0  (not used)
com2_Reset                          -246  0xffffff0a (PmmC func) args[0] r=0  (not used)
COM2_RX_pin                         -227  0xffffff1d (PmmC func) args[1] r=1  (not used)
com2_RXblock                        -560  0xfffffdd0 (PmmC func) args[2] r=0  (not used)
com2_Sync                           -262  0xfffffefa (PmmC func) args[0] r=1  (not used)
COM2_TX_pin                         -230  0xffffff1a (PmmC func) args[1] r=1  (not used)
com2_TXblock                        -559  0xfffffdd1 (PmmC func) args[2] r=0  (not used)
com2_TXbuffer                       -266  0xfffffef6 (PmmC func) args[3] r=0  (not used)
com2_TXbufferHold                   -278  0xfffffeea (PmmC func) args[1] r=1  (not used)
com2_TXcount                        -270  0xfffffef2 (PmmC func) args[0] r=1  (not used)
com2_TXemptyEvent                   -274  0xfffffeee (PmmC func) args[1] r=1  (not used)
COM3                               63495  0x0000f807 (const dword)  (not used)
com3_Count                          -251  0xffffff05 (PmmC func) args[0] r=1  (not used)
com3_Error                          -259  0xfffffefd (PmmC func) args[0] r=1  (not used)
com3_Full                           -255  0xffffff01 (PmmC func) args[0] r=1  (not used)
com3_Init                           -235  0xffffff15 (PmmC func) args[3] r=0  (not used)
com3_Reset                          -247  0xffffff09 (PmmC func) args[0] r=0  (not used)
COM3_RX_pin                         -228  0xffffff1c (PmmC func) args[1] r=1  (not used)
com3_RXblock                        -562  0xfffffdce (PmmC func) args[2] r=0  (not used)
com3_Sync                           -263  0xfffffef9 (PmmC func) args[0] r=1  (not used)
COM3_TX_pin                         -231  0xffffff19 (PmmC func) args[1] r=1  (not used)
com3_TXblock                        -561  0xfffffdcf (PmmC func) args[2] r=0  (not used)
com3_TXbuffer                       -267  0xfffffef5 (PmmC func) args[3] r=0  (not used)
com3_TXbufferHold                   -279  0xfffffee9 (PmmC func) args[1] r=1  (not used)
com3_TXcount                        -271  0xfffffef1 (PmmC func) args[0] r=1  (not used)
com3_TXemptyEvent                   -275  0xfffffeed (PmmC func) args[1] r=1  (not used)
com_Count                           -248  0xffffff08 (PmmC func) args[0] r=1  (not used)
com_Error                           -256  0xffffff00 (PmmC func) args[0] r=1  (not used)
com_Full                            -252  0xffffff04 (PmmC func) args[0] r=1  (not used)
com_Init                            -232  0xffffff18 (PmmC func) args[3] r=0  (usage 3)
com_Mode                            -280  0xfffffee8 (PmmC func) args[4] r=1  (not used)
com_Reset                           -244  0xffffff0c (PmmC func) args[0] r=0  (not used)
com_RXblock                         -282  0xfffffee6 (PmmC func) args[2] r=0  (not used)
com_SetBaud                         -225  0xffffff1f (PmmC func) args[2] r=1  (usage 3)
com_Sync                            -260  0xfffffefc (PmmC func) args[0] r=1  (not used)
com_TXblock                         -281  0xfffffee7 (PmmC func) args[2] r=0  (not used)
com_TXbuffer                        -264  0xfffffef8 (PmmC func) args[3] r=0  (not used)
com_TXbufferHold                    -276  0xfffffeec (PmmC func) args[1] r=1  (not used)
com_TXcount                         -268  0xfffffef4 (PmmC func) args[0] r=1  (not used)
com_TXemptyEvent                    -272  0xfffffef0 (PmmC func) args[1] r=1  (not used)
CONTRAST                              25  0x00000019 (const dword)  (not used)
CORAL                              64490  0x0000fbea (const dword)  (usage 8)
CORNFLOWERBLUE                     25789  0x000064bd (const dword)  (usage 2)
CORNSILK                           65499  0x0000ffdb (const dword)  (usage 2)
COS                                  -58  0xffffffc6 (PmmC func) args[1] r=1  (not used)
count                                 10  0x0000000a (mem) word (global)  (usage 39)
COUNT_EDGE                             3  0x00000003 (const dword)  (not used)
COUNT_FALL                             2  0x00000002 (const dword)  (not used)
COUNT_OFF                              0  0x00000000 (const dword)  (not used)
COUNT_RISE                             1  0x00000001 (const dword)  (not used)
crc_16                              -567  0xfffffdc9 (PmmC func) args[2] r=1  (not used)
crc_CCITT                           -569  0xfffffdc7 (PmmC func) args[3] r=1  (not used)
crc_CSUM_8                          -566  0xfffffdca (PmmC func) args[2] r=1  (not used)
crc_MODBUS                          -568  0xfffffdc8 (PmmC func) args[2] r=1  (not used)
CRIMSON                            55463  0x0000d8a7 (const dword)  (usage 5)
cutBuffer                            134  0x00000086 (mem) word[50] (global)  (usage 3)
cutBuffer1                           234  0x000000ea (mem) word[50] (global)  (usage 3)
cutCommand                          1576  0x00000628 (User func) args[0] r=0  (usage 3)
cutListPreview                     11570  0x00002d32 (User func) args[0] r=0  (usage 3)
CY                                   -64  0xffffffc0 (PmmC func) args[0] r=1  (not used)
CYAN                                2047  0x000007ff (const dword)  (usage 53)
DARKBLUE                              17  0x00000011 (const dword)  (usage 2)
DARKCYAN                            1105  0x00000451 (const dword)  (usage 2)
DARKGOLDENROD                      48161  0x0000bc21 (const dword)  (usage 2)
DARKGRAY                           44373  0x0000ad55 (const dword)  (usage 2)
DARKGREEN                            800  0x00000320 (const dword)  (usage 2)
DARKKHAKI                          48557  0x0000bdad (const dword)  (usage 2)
DARKMAGENTA                        34833  0x00008811 (const dword)  (usage 2)
DARKOLIVEGREEN                     21317  0x00005345 (const dword)  (usage 2)
DARKORANGE                         64608  0x0000fc60 (const dword)  (usage 2)
DARKORCHID                         39321  0x00009999 (const dword)  (usage 2)
DARKRED                            34816  0x00008800 (const dword)  (usage 2)
DARKSALMON                         60591  0x0000ecaf (const dword)  (usage 2)
DARKSEAGREEN                       36337  0x00008df1 (const dword)  (usage 2)
DARKSLATEBLUE                      18929  0x000049f1 (const dword)  (usage 2)
DARKSLATEGRAY                      10857  0x00002a69 (const dword)  (usage 2)
DARKTURQUOISE                       1658  0x0000067a (const dword)  (usage 2)
DARKVIOLET                         36890  0x0000901a (const dword)  (usage 2)
DBG                                    0  0x00000000 (const dword)  (usage 33)
DEBUG_MODE                            64  0x00000040 (const dword)  (not used)
DEC                                 1290  0x0000050a (const dword)  (not used)
DEC1                                 266  0x0000010a (const dword)  (not used)
DEC1Z                               4362  0x0000110a (const dword)  (not used)
DEC1ZB                              8458  0x0000210a (const dword)  (not used)
DEC2                                 522  0x0000020a (const dword)  (not used)
DEC2Z                               4618  0x0000120a (const dword)  (not used)
DEC2ZB                              8714  0x0000220a (const dword)  (not used)
DEC3                                 778  0x0000030a (const dword)  (not used)
DEC3Z                               4874  0x0000130a (const dword)  (not used)
DEC3ZB                              8970  0x0000230a (const dword)  (usage 6)
DEC4                                1034  0x0000040a (const dword)  (not used)
DEC4Z                               5130  0x0000140a (const dword)  (not used)
DEC4ZB                              9226  0x0000240a (const dword)  (not used)
DEC5                                1290  0x0000050a (const dword)  (not used)
DEC5Z                               5386  0x0000150a (const dword)  (not used)
DEC5ZB                              9482  0x0000250a (const dword)  (not used)
DECZ                                5386  0x0000150a (const dword)  (not used)
DECZB                               9482  0x0000250a (const dword)  (not used)
DEEPPINK                           63666  0x0000f8b2 (const dword)  (usage 2)
DEEPSKYBLUE                         1535  0x000005ff (const dword)  (usage 2)
DIABLO                                 3  0x00000003 (const dword)  (usage 3)
DIMGRAY                            27469  0x00006b4d (const dword)  (usage 2)
DISABLE                                0  0x00000000 (const dword)  (not used)
disk                                   0  0x00000000 (mem) word (global)  (usage 6)
DISK_BUF                              15  0x0000000f (const dword)  (not used)
DISK_DATA_HI                           7  0x00000007 (const dword)  (not used)
DISK_DATA_LO                           6  0x00000006 (const dword)  (not used)
DISK_FAT_HI                            3  0x00000003 (const dword)  (not used)
DISK_FAT_LO                            2  0x00000002 (const dword)  (not used)
DISK_FATCOPIES                        12  0x0000000c (const dword)  (not used)
DISK_FATSIZE                          11  0x0000000b (const dword)  (not used)
DISK_FIRST_SECT_HI                     1  0x00000001 (const dword)  (not used)
DISK_FIRST_SECT_LO                     0  0x00000000 (const dword)  (not used)
DISK_MAXCLUS_HI                        9  0x00000009 (const dword)  (not used)
DISK_MAXCLUS_LO                        8  0x00000008 (const dword)  (not used)
DISK_MAXROOT                          10  0x0000000a (const dword)  (not used)
DISK_ROOT_HI                           5  0x00000005 (const dword)  (not used)
DISK_ROOT_LO                           4  0x00000004 (const dword)  (not used)
DISK_SECT_PER_CLUS                    13  0x0000000d (const dword)  (not used)
DISK_TYPE                             14  0x0000000e (const dword)  (not used)
disp_BlitPixelsFromCOM0             -372  0xfffffe8c (PmmC func) args[0] r=0  (not used)
disp_BlitPixelsFromCOM1             -563  0xfffffdcd (PmmC func) args[0] r=0  (not used)
disp_BlitPixelsFromCOM2             -564  0xfffffdcc (PmmC func) args[0] r=0  (not used)
disp_BlitPixelsFromCOM3             -565  0xfffffdcb (PmmC func) args[0] r=0  (not used)
disp_Disconnect                     -371  0xfffffe8d (PmmC func) args[0] r=0  (not used)
disp_Init                           -370  0xfffffe8e (PmmC func) args[0] r=0  (not used)
disp_ReadWord                       -367  0xfffffe91 (PmmC func) args[0] r=1  (not used)
disp_setGRAM                        -363  0xfffffe95 (PmmC func) args[4] r=0  (not used)
disp_SetReg                         -362  0xfffffe96 (PmmC func) args[2] r=0  (not used)
disp_Sync                           -369  0xfffffe8f (PmmC func) args[1] r=0  (not used)
disp_WrGRAM                         -364  0xfffffe94 (PmmC func) args[1] r=0  (not used)
disp_WriteControl                   -365  0xfffffe93 (PmmC func) args[1] r=0  (not used)
disp_WriteWord                      -366  0xfffffe92 (PmmC func) args[1] r=0  (not used)
DODGERBLUE                          7327  0x00001c9f (const dword)  (usage 2)
DOWN                                   0  0x00000000 (const dword)  (not used)
DSK                                63490  0x0000f802 (const dword)  (not used)
ellipseParam                        3040  0x00000be0 (User func) args[0] r=0  (usage 3)
ENABLE                                 1  0x00000001 (const dword)  (not used)
EVE_SP                               -65  0xffffffbf (PmmC func) args[0] r=1  (not used)
EVE_SSIZE                            -66  0xffffffbe (PmmC func) args[0] r=1  (not used)
EXTERN                            7704288  0x00758ee0(macro)  /**/   (not used)
false                                  0  0x00000000 (const dword)  (usage 24)
FALSE_REASON                         141  0x0000008d (const dword)  (not used)
FCY_1                                 20  0x00000014 (const dword)  (not used)
FCY_256                               23  0x00000017 (const dword)  (not used)
FCY_64                                22  0x00000016 (const dword)  (not used)
FCY_8                                 21  0x00000015 (const dword)  (not used)
FE_CANNOT_INIT                        15  0x0000000f (const dword)  (not used)
FE_CANNOT_READ_MBR                    16  0x00000010 (const dword)  (not used)
FE_DIR_FULL                           12  0x0000000c (const dword)  (not used)
FE_DISK_FULL                          13  0x0000000d (const dword)  (not used)
FE_DISK_NOT_MNTD                       6  0x00000006 (const dword)  (not used)
FE_EOF                                10  0x0000000a (const dword)  (not used)
FE_FAT_EOF                             9  0x00000009 (const dword)  (not used)
FE_FILE_NOT_FOUND                      7  0x00000007 (const dword)  (not used)
FE_FILE_OVERWRITE                     14  0x0000000e (const dword)  (not used)
FE_FILE_TIMEOUT                       26  0x0000001a (const dword)  (not used)
FE_FIND_ERROR                         19  0x00000013 (const dword)  (not used)
FE_IDE_ERROR                           1  0x00000001 (const dword)  (not used)
FE_INVALID_BR                          5  0x00000005 (const dword)  (not used)
FE_INVALID_CLUSTER                    11  0x0000000b (const dword)  (not used)
FE_INVALID_FILE                        8  0x00000008 (const dword)  (not used)
FE_INVALID_FNAME                      20  0x00000014 (const dword)  (not used)
FE_INVALID_MBR                         4  0x00000004 (const dword)  (not used)
FE_INVALID_MEDIA                      21  0x00000015 (const dword)  (not used)
FE_INVALID_MODE                       18  0x00000012 (const dword)  (not used)
FE_MALLOC_FAILED                      17  0x00000011 (const dword)  (not used)
FE_NOT_PRESENT                         2  0x00000002 (const dword)  (not used)
FE_OK                                  0  0x00000000 (const dword)  (not used)
FE_PARTITION_TYPE                      3  0x00000003 (const dword)  (not used)
FE_SECTOR_READ_FAIL                   22  0x00000016 (const dword)  (not used)
FE_SECTOR_WRITE_FAIL                  23  0x00000017 (const dword)  (not used)
FILE_ATTRIBUTES                       18  0x00000012 (const dword)  (not used)
FILE_BUFFER                           22  0x00000016 (const dword)  (not used)
file_Close                          -431  0xfffffe51 (PmmC func) args[1] r=1  (not used)
file_Count                          -425  0xfffffe57 (PmmC func) args[1] r=1  (not used)
FILE_CURR_CLUSTER                      1  0x00000001 (const dword)  (not used)
FILE_CURR_SECTOR                       2  0x00000002 (const dword)  (not used)
FILE_CURR_SECTOR_POS                   3  0x00000003 (const dword)  (not used)
FILE_CURR_SECTOR_TOP                   4  0x00000004 (const dword)  (not used)
FILE_DATE                             10  0x0000000a (const dword)  (not used)
file_Dir                            -426  0xfffffe56 (PmmC func) args[1] r=1  (not used)
FILE_DISK                             21  0x00000015 (const dword)  (not used)
FILE_ENTRY                            20  0x00000014 (const dword)  (not used)
file_Erase                          -446  0xfffffe42 (PmmC func) args[1] r=1  (not used)
file_Error                          -424  0xfffffe58 (PmmC func) args[0] r=1  (not used)
file_Exec                           -450  0xfffffe3e (PmmC func) args[2] r=1  (not used)
file_Exists                         -429  0xfffffe53 (PmmC func) args[1] r=1  (not used)
file_FindFirst                      -427  0xfffffe55 (PmmC func) args[1] r=1  (not used)
file_FindNext                       -428  0xfffffe54 (PmmC func) args[0] r=1  (not used)
FILE_FIRST_CLUSTER                     0  0x00000000 (const dword)  (not used)
file_GetC                           -441  0xfffffe47 (PmmC func) args[1] r=1  (not used)
file_GetS                           -445  0xfffffe43 (PmmC func) args[3] r=1  (not used)
file_GetW                           -443  0xfffffe45 (PmmC func) args[1] r=1  (not used)
file_Image                          -438  0xfffffe4a (PmmC func) args[3] r=1  (not used)
file_Index                          -434  0xfffffe4e (PmmC func) args[4] r=1  (not used)
file_LoadFunction                   -448  0xfffffe40 (PmmC func) args[1] r=1  (not used)
file_LoadImageControl               -451  0xfffffe3d (PmmC func) args[3] r=1  (usage 6)
FILE_MODE                             17  0x00000011 (const dword)  (not used)
file_Mount                          -452  0xfffffe3c (PmmC func) args[0] r=1  (usage 6)
FILE_NAME                             11  0x0000000b (const dword)  (not used)
file_Open                           -430  0xfffffe52 (PmmC func) args[2] r=1  (usage 3)
FILE_PAGEFLAG                         19  0x00000013 (const dword)  (not used)
file_PlayWAV                        -454  0xfffffe3a (PmmC func) args[1] r=1  (not used)
file_PutC                           -440  0xfffffe48 (PmmC func) args[2] r=1  (not used)
file_PutS                           -444  0xfffffe44 (PmmC func) args[2] r=1  (not used)
file_PutW                           -442  0xfffffe46 (PmmC func) args[2] r=1  (not used)
file_Read                           -432  0xfffffe50 (PmmC func) args[3] r=1  (not used)
file_Rewind                         -447  0xfffffe41 (PmmC func) args[1] r=1  (not used)
file_Run                            -449  0xfffffe3f (PmmC func) args[2] r=1  (not used)
file_ScreenCapture                  -439  0xfffffe49 (PmmC func) args[5] r=1  (not used)
file_Seek                           -433  0xfffffe4f (PmmC func) args[3] r=1  (not used)
FILE_SEEK_POS_HI                       6  0x00000006 (const dword)  (not used)
FILE_SEEK_POS_LO                       5  0x00000005 (const dword)  (not used)
file_Size                           -437  0xfffffe4b (PmmC func) args[3] r=1  (not used)
FILE_SIZE_HI                           8  0x00000008 (const dword)  (not used)
FILE_SIZE_LO                           7  0x00000007 (const dword)  (not used)
file_Tell                           -435  0xfffffe4d (PmmC func) args[3] r=1  (not used)
FILE_TIME                              9  0x00000009 (const dword)  (not used)
file_Unmount                        -453  0xfffffe3b (PmmC func) args[0] r=0  (not used)
file_Write                          -436  0xfffffe4c (PmmC func) args[3] r=1  (not used)
FILLPATTERN_0                      65504  0x0000ffe0 (const dword)  (not used)
FILLPATTERN_1                      65505  0x0000ffe1 (const ??? 0)  (not used)
FILLPATTERN_10                     65514  0x0000ffea (const ??? 0)  (not used)
FILLPATTERN_11                     65515  0x0000ffeb (const ??? 0)  (not used)
FILLPATTERN_12                     65516  0x0000ffec (const ??? 0)  (not used)
FILLPATTERN_13                     65517  0x0000ffed (const ??? 0)  (not used)
FILLPATTERN_14                     65518  0x0000ffee (const ??? 0)  (not used)
FILLPATTERN_15                     65519  0x0000ffef (const ??? 0)  (not used)
FILLPATTERN_16                     65520  0x0000fff0 (const ??? 0)  (not used)
FILLPATTERN_17                     65521  0x0000fff1 (const ??? 0)  (not used)
FILLPATTERN_18                     65522  0x0000fff2 (const ??? 0)  (not used)
FILLPATTERN_19                     65523  0x0000fff3 (const ??? 0)  (not used)
FILLPATTERN_2                      65506  0x0000ffe2 (const ??? 0)  (not used)
FILLPATTERN_20                     65524  0x0000fff4 (const ??? 0)  (not used)
FILLPATTERN_21                     65525  0x0000fff5 (const ??? 0)  (not used)
FILLPATTERN_22                     65526  0x0000fff6 (const ??? 0)  (not used)
FILLPATTERN_23                     65527  0x0000fff7 (const ??? 0)  (not used)
FILLPATTERN_24                     65528  0x0000fff8 (const ??? 0)  (not used)
FILLPATTERN_25                     65529  0x0000fff9 (const ??? 0)  (not used)
FILLPATTERN_26                     65530  0x0000fffa (const ??? 0)  (not used)
FILLPATTERN_27                     65531  0x0000fffb (const ??? 0)  (not used)
FILLPATTERN_28                     65532  0x0000fffc (const ??? 0)  (not used)
FILLPATTERN_29                     65533  0x0000fffd (const ??? 0)  (not used)
FILLPATTERN_3                      65507  0x0000ffe3 (const ??? 0)  (not used)
FILLPATTERN_30                     65534  0x0000fffe (const ??? 0)  (not used)
FILLPATTERN_31                     65535  0x0000ffff (const ??? 0)  (not used)
FILLPATTERN_4                      65508  0x0000ffe4 (const ??? 0)  (not used)
FILLPATTERN_5                      65509  0x0000ffe5 (const ??? 0)  (not used)
FILLPATTERN_6                      65510  0x0000ffe6 (const ??? 0)  (not used)
FILLPATTERN_7                      65511  0x0000ffe7 (const ??? 0)  (not used)
FILLPATTERN_8                      65512  0x0000ffe8 (const ??? 0)  (not used)
FILLPATTERN_9                      65513  0x0000ffe9 (const ??? 0)  (not used)
FIREBRICK                          45316  0x0000b104 (const dword)  (usage 2)
flash_Bank                          -498  0xfffffe0e (PmmC func) args[0] r=1  (not used)
flash_Blit1                         -507  0xfffffe05 (PmmC func) args[4] r=1  (not used)
flash_Blit16                        -503  0xfffffe09 (PmmC func) args[3] r=1  (not used)
flash_Blit2                         -506  0xfffffe06 (PmmC func) args[4] r=1  (not used)
flash_Blit4                         -505  0xfffffe07 (PmmC func) args[4] r=1  (not used)
flash_Blit8                         -504  0xfffffe08 (PmmC func) args[3] r=1  (not used)
flash_Copy                          -496  0xfffffe10 (PmmC func) args[4] r=1  (not used)
flash_EraseBank                     -499  0xfffffe0d (PmmC func) args[2] r=1  (not used)
flash_Exec                          -508  0xfffffe04 (PmmC func) args[2] r=1  (not used)
flash_GetByte                       -494  0xfffffe12 (PmmC func) args[2] r=1  (not used)
flash_GetWord                       -495  0xfffffe11 (PmmC func) args[2] r=1  (not used)
flash_LoadFile                      -500  0xfffffe0c (PmmC func) args[2] r=1  (not used)
flash_putstr                        -502  0xfffffe0a (PmmC func) args[2] r=1  (not used)
FLASH_READ_PROTECT                    16  0x00000010 (const dword)  (not used)
flash_Run                           -497  0xfffffe0f (PmmC func) args[1] r=1  (not used)
FLASH_WRITE_PROTECT                   32  0x00000020 (const dword)  (not used)
flash_WriteBlock                    -501  0xfffffe0b (PmmC func) args[3] r=1  (not used)
FLASHBANK_0                            0  0x00000000 (const dword)  (not used)
FLASHBANK_1                            1  0x00000001 (const dword)  (not used)
FLASHBANK_2                            2  0x00000002 (const dword)  (not used)
FLASHBANK_3                            3  0x00000003 (const dword)  (not used)
FLASHBANK_4                            4  0x00000004 (const dword)  (not used)
FLASHBANK_5                            5  0x00000005 (const dword)  (not used)
FLORALWHITE                        65502  0x0000ffde (const dword)  (usage 2)
flt_ABS                              -84  0xffffffac (PmmC func) args[2] r=1  (not used)
flt_ACOS                             -85  0xffffffab (PmmC func) args[2] r=1  (not used)
flt_ADD                              -97  0xffffff9f (PmmC func) args[3] r=1  (not used)
flt_ASIN                             -86  0xffffffaa (PmmC func) args[2] r=1  (not used)
flt_ATAN                             -87  0xffffffa9 (PmmC func) args[2] r=1  (not used)
flt_CEIL                             -90  0xffffffa6 (PmmC func) args[2] r=1  (not used)
flt_COS                              -88  0xffffffa8 (PmmC func) args[2] r=1  (not used)
flt_DIV                             -100  0xffffff9c (PmmC func) args[3] r=1  (not used)
flt_EQ                              -101  0xffffff9b (PmmC func) args[2] r=1  (not used)
flt_EXP                              -89  0xffffffa7 (PmmC func) args[2] r=1  (not used)
flt_FLOOR                            -91  0xffffffa5 (PmmC func) args[2] r=1  (not used)
flt_FTOI                            -108  0xffffff94 (PmmC func) args[1] r=1  (not used)
flt_GE                              -104  0xffffff98 (PmmC func) args[2] r=1  (not used)
flt_GT                              -103  0xffffff99 (PmmC func) args[2] r=1  (not used)
flt_ITOF                             -79  0xffffffb1 (PmmC func) args[2] r=1  (not used)
flt_LE                              -106  0xffffff96 (PmmC func) args[2] r=1  (not used)
flt_LOG                              -93  0xffffffa3 (PmmC func) args[2] r=1  (not used)
flt_LT                              -105  0xffffff97 (PmmC func) args[2] r=1  (not used)
flt_LTOF                             -81  0xffffffaf (PmmC func) args[2] r=1  (not used)
flt_MUL                              -99  0xffffff9d (PmmC func) args[3] r=1  (not used)
flt_NE                              -102  0xffffff9a (PmmC func) args[2] r=1  (not used)
flt_POW                              -96  0xffffffa0 (PmmC func) args[3] r=1  (not used)
flt_PRINT                            -83  0xffffffad (PmmC func) args[2] r=1  (not used)
flt_SGN                             -107  0xffffff95 (PmmC func) args[1] r=1  (not used)
flt_SIN                              -92  0xffffffa4 (PmmC func) args[2] r=1  (not used)
flt_SQR                              -94  0xffffffa2 (PmmC func) args[2] r=1  (not used)
flt_SUB                              -98  0xffffff9e (PmmC func) args[3] r=1  (not used)
flt_TAN                              -95  0xffffffa1 (PmmC func) args[2] r=1  (not used)
flt_UITOF                            -80  0xffffffb0 (PmmC func) args[2] r=1  (not used)
flt_ULTOF                            -82  0xffffffae (PmmC func) args[2] r=1  (not used)
flt_VAL                              -78  0xffffffb2 (PmmC func) args[2] r=1  (not used)
FONT1                                  1  0x00000001 (const dword)  (not used)
FONT2                                  2  0x00000002 (const dword)  (not used)
FONT3                                  3  0x00000003 (const dword)  (not used)
FONT_1                                 1  0x00000001 (const dword)  (not used)
FONT_10                               10  0x0000000a (const dword)  (not used)
FONT_11                               11  0x0000000b (const dword)  (not used)
FONT_2                                 2  0x00000002 (const dword)  (not used)
FONT_3                                 3  0x00000003 (const dword)  (not used)
FONT_4                                 4  0x00000004 (const dword)  (not used)
FONT_5                                 5  0x00000005 (const dword)  (not used)
FONT_6                                 6  0x00000006 (const dword)  (not used)
FONT_7                                 7  0x00000007 (const dword)  (not used)
FONT_8                                 8  0x00000008 (const dword)  (not used)
FONT_9                                 9  0x00000009 (const dword)  (not used)
FONT_ID                                2  0x00000002 (const dword)  (not used)
FONT_SIZE                              2  0x00000002 (const dword)  (not used)
FORESTGREEN                         9284  0x00002444 (const dword)  (usage 2)
FRAME_DELAY                           22  0x00000016 (const dword)  (not used)
FUCHSIA                            63519  0x0000f81f (const dword)  (usage 2)
GAINSBORO                          57083  0x0000defb (const dword)  (usage 2)
gasSettings                         2502  0x000009c6 (User func) args[0] r=0  (usage 3)
GFX                                63489  0x0000f801 (const dword)  (not used)
gfx_332to565                        -165  0xffffff5b (PmmC func) args[1] r=1  (not used)
gfx_565to332                        -166  0xffffff5a (PmmC func) args[1] r=1  (not used)
gfx_Arc                             -172  0xffffff54 (PmmC func) args[7] r=0  (usage 3)
gfx_BevelRadius                     -194  0xffffff3e (PmmC func) args[1] r=1  (not used)
gfx_BevelShadow                     -196  0xffffff3c (PmmC func) args[1] r=1  (not used)
gfx_BevelWidth                      -195  0xffffff3d (PmmC func) args[1] r=1  (not used)
gfx_BGcolour                        -184  0xffffff48 (PmmC func) args[1] r=1  (not used)
GFX_BOTTOM                            51  0x00000033 (const dword)  (not used)
gfx_BoxTo                           -149  0xffffff6b (PmmC func) args[2] r=0  (not used)
gfx_Bullet                          -146  0xffffff6e (PmmC func) args[1] r=0  (not used)
gfx_Button                          -155  0xffffff65 (PmmC func) args[9] r=1  (not used)
gfx_Button2                         -156  0xffffff64 (PmmC func) args[8] r=0  (usage 358)
gfx_Button3                         -157  0xffffff63 (PmmC func) args[8] r=0  (usage 9)
gfx_ChangeColour                    -151  0xffffff69 (PmmC func) args[2] r=0  (not used)
gfx_CheckBox                        -158  0xffffff62 (PmmC func) args[8] r=0  (not used)
gfx_Circle                          -136  0xffffff78 (PmmC func) args[4] r=0  (usage 3)
gfx_CircleFilled                    -137  0xffffff77 (PmmC func) args[4] r=0  (usage 18)
GFX_CLIP_BOTTOM                      114  0x00000072 (const dword)  (not used)
GFX_CLIP_BOTTOM_VAL                  110  0x0000006e (const dword)  (not used)
GFX_CLIP_LEFT                        111  0x0000006f (const dword)  (not used)
GFX_CLIP_LEFT_VAL                    107  0x0000006b (const dword)  (not used)
GFX_CLIP_RIGHT                       113  0x00000071 (const dword)  (not used)
GFX_CLIP_RIGHT_VAL                   109  0x0000006d (const dword)  (not used)
GFX_CLIP_TOP                         112  0x00000070 (const dword)  (not used)
GFX_CLIP_TOP_VAL                     108  0x0000006c (const dword)  (not used)
gfx_Clipping                        -186  0xffffff46 (PmmC func) args[1] r=1  (not used)
gfx_ClipWindow                      -150  0xffffff6a (PmmC func) args[4] r=0  (not used)
gfx_Cls                             -126  0xffffff82 (PmmC func) args[0] r=0  (usage 28)
gfx_Contrast                        -192  0xffffff40 (PmmC func) args[1] r=1  (not used)
gfx_Dot                             -145  0xffffff6f (PmmC func) args[0] r=0  (not used)
gfx_Ellipse                         -153  0xffffff67 (PmmC func) args[5] r=0  (not used)
gfx_EllipseFilled                   -154  0xffffff66 (PmmC func) args[5] r=0  (not used)
gfx_FillPattern                     -170  0xffffff56 (PmmC func) args[2] r=1  (not used)
gfx_FrameDelay                      -189  0xffffff43 (PmmC func) args[1] r=1  (not used)
gfx_Get                             -182  0xffffff4a (PmmC func) args[1] r=1  (not used)
gfx_GetPixel                        -139  0xffffff75 (PmmC func) args[2] r=1  (not used)
gfx_Gradient                        -176  0xffffff50 (PmmC func) args[7] r=0  (not used)
gfx_Hline                           -132  0xffffff7c (PmmC func) args[4] r=1  (not used)
gfx_IncX                            -147  0xffffff6d (PmmC func) args[0] r=1  (not used)
gfx_IncY                            -148  0xffffff6c (PmmC func) args[0] r=1  (not used)
GFX_LAST_CHAR_HEIGHT                 120  0x00000078 (const dword)  (not used)
GFX_LAST_CHAR_WIDTH                  119  0x00000077 (const dword)  (not used)
GFX_LAST_STR_HEIGHT                  122  0x0000007a (const dword)  (not used)
GFX_LAST_STR_WIDTH                   121  0x00000079 (const dword)  (not used)
GFX_LEFT                              48  0x00000030 (const dword)  (not used)
gfx_Line                            -131  0xffffff7d (PmmC func) args[5] r=0  (usage 27)
gfx_LinePattern                     -193  0xffffff3f (PmmC func) args[1] r=1  (usage 12)
gfx_LineRel                         -130  0xffffff7e (PmmC func) args[2] r=0  (not used)
gfx_LineTo                          -129  0xffffff7f (PmmC func) args[2] r=0  (not used)
gfx_MoveRel                         -128  0xffffff80 (PmmC func) args[2] r=0  (not used)
gfx_MoveTo                          -127  0xffffff81 (PmmC func) args[2] r=0  (usage 177)
gfx_ObjectColour                    -185  0xffffff47 (PmmC func) args[1] r=1  (not used)
gfx_Orbit                           -142  0xffffff72 (PmmC func) args[2] r=0  (not used)
gfx_OrbitInit                       -141  0xffffff73 (PmmC func) args[2] r=0  (not used)
gfx_Origin                          -169  0xffffff57 (PmmC func) args[2] r=0  (not used)
gfx_OutlineColour                   -191  0xffffff41 (PmmC func) args[1] r=1  (not used)
gfx_Panel                           -161  0xffffff5f (PmmC func) args[6] r=0  (usage 78)
gfx_PenSize                         -183  0xffffff49 (PmmC func) args[1] r=1  (not used)
gfx_PieSlice                        -171  0xffffff55 (PmmC func) args[9] r=0  (not used)
gfx_PointWithinBox                  -199  0xffffff39 (PmmC func) args[3] r=1  (not used)
gfx_PointWithinRectangle            -200  0xffffff38 (PmmC func) args[3] r=1  (not used)
gfx_Polygon                         -144  0xffffff70 (PmmC func) args[4] r=0  (not used)
gfx_PolygonFilled                   -168  0xffffff58 (PmmC func) args[4] r=0  (not used)
gfx_Polyline                        -143  0xffffff71 (PmmC func) args[4] r=0  (not used)
gfx_PutPixel                        -138  0xffffff76 (PmmC func) args[3] r=0  (not used)
gfx_RadioButton                     -159  0xffffff61 (PmmC func) args[8] r=0  (usage 18)
gfx_ReadBresLine                    -178  0xffffff4e (PmmC func) args[5] r=1  (not used)
gfx_ReadGRAMarea                    -180  0xffffff4c (PmmC func) args[5] r=1  (not used)
gfx_Rectangle                       -134  0xffffff7a (PmmC func) args[5] r=0  (usage 3)
gfx_RectangleFilled                 -135  0xffffff79 (PmmC func) args[5] r=0  (not used)
gfx_RGBto565                        -164  0xffffff5c (PmmC func) args[3] r=1  (not used)
GFX_RIGHT                             50  0x00000032 (const dword)  (not used)
gfx_RoundGradient                   -177  0xffffff4f (PmmC func) args[8] r=0  (not used)
gfx_RoundPanel                      -175  0xffffff51 (PmmC func) args[8] r=0  (not used)
gfx_RoundRect                       -173  0xffffff53 (PmmC func) args[6] r=0  (not used)
gfx_Scope                           -532  0xfffffdec (PmmC func) args[19] r=0  (not used)
gfx_ScreenCopyPaste                 -163  0xffffff5d (PmmC func) args[6] r=0  (not used)
gfx_ScreenMode                      -190  0xffffff42 (PmmC func) args[1] r=1  (usage 3)
gfx_Set                             -125  0xffffff83 (PmmC func) args[2] r=0  (not used)
gfx_SetClipRegion                   -152  0xffffff68 (PmmC func) args[0] r=0  (not used)
gfx_Slider                          -162  0xffffff5e (PmmC func) args[8] r=1  (not used)
gfx_Slider2                         -160  0xffffff60 (PmmC func) args[8] r=1  (not used)
gfx_Surround                        -174  0xffffff52 (PmmC func) args[7] r=0  (not used)
GFX_THUMB_BORDER_DARK                 76  0x0000004c (const dword)  (not used)
GFX_THUMB_BORDER_LIGHT                77  0x0000004d (const dword)  (not used)
GFX_THUMB_PERCENT                     75  0x0000004b (const dword)  (not used)
GFX_TOP                               49  0x00000031 (const dword)  (not used)
GFX_TOUCH_REGION_X1                  103  0x00000067 (const dword)  (not used)
GFX_TOUCH_REGION_X2                  105  0x00000069 (const dword)  (not used)
GFX_TOUCH_REGION_Y1                  104  0x00000068 (const dword)  (not used)
GFX_TOUCH_REGION_Y2                  106  0x0000006a (const dword)  (not used)
gfx_Transparency                    -188  0xffffff44 (PmmC func) args[1] r=1  (not used)
gfx_TransparentColour               -187  0xffffff45 (PmmC func) args[1] r=1  (not used)
gfx_Triangle                        -140  0xffffff74 (PmmC func) args[7] r=0  (not used)
gfx_TriangleFilled                  -167  0xffffff59 (PmmC func) args[7] r=0  (usage 6)
gfx_Vline                           -133  0xffffff7b (PmmC func) args[4] r=1  (not used)
gfx_WriteBresLine                   -179  0xffffff4d (PmmC func) args[5] r=0  (not used)
gfx_WriteGRAMarea                   -181  0xffffff4b (PmmC func) args[5] r=0  (not used)
GFX_X1                                52  0x00000034 (const dword)  (not used)
GFX_X2                                54  0x00000036 (const dword)  (not used)
GFX_X_ORG                             56  0x00000038 (const dword)  (not used)
GFX_XMAX                              46  0x0000002e (const dword)  (not used)
gfx_Xorigin                         -197  0xffffff3b (PmmC func) args[1] r=1  (not used)
GFX_Y1                                53  0x00000035 (const dword)  (not used)
GFX_Y2                                55  0x00000037 (const dword)  (not used)
GFX_Y_ORG                             57  0x00000039 (const dword)  (not used)
GFX_YMAX                              47  0x0000002f (const dword)  (not used)
gfx_Yorigin                         -198  0xffffff3a (PmmC func) args[1] r=1  (not used)
GHOSTWHITE                         65503  0x0000ffdf (const dword)  (usage 2)
GOLD                               65184  0x0000fea0 (const dword)  (usage 8)
GOLDENROD                          56612  0x0000dd24 (const dword)  (usage 2)
GRAD_DOWN                             32  0x00000020 (const dword)  (not used)
GRAD_LEFT                             80  0x00000050 (const dword)  (not used)
GRAD_RIGHT                            48  0x00000030 (const dword)  (not used)
GRAD_UP                               64  0x00000040 (const dword)  (not used)
GRAD_WAVE_HOR                        112  0x00000070 (const dword)  (not used)
GRAD_WAVE_VER                         96  0x00000060 (const dword)  (not used)
GRAM_PIXEL_COUNT_HI                  116  0x00000074 (const dword)  (not used)
GRAM_PIXEL_COUNT_LO                  115  0x00000073 (const dword)  (not used)
GRAY                               33808  0x00008410 (const dword)  (usage 5)
GREEN                               1024  0x00000400 (const dword)  (usage 2)
GREENYELLOW                        45029  0x0000afe5 (const dword)  (usage 2)
HEX                                 5136  0x00001410 (const dword)  (usage 12)
HEX1                                4368  0x00001110 (const dword)  (not used)
HEX1Z                                272  0x00000110 (const dword)  (not used)
HEX1ZB                              8464  0x00002110 (const dword)  (not used)
HEX2                                4624  0x00001210 (const dword)  (not used)
HEX2Z                                528  0x00000210 (const dword)  (not used)
HEX2ZB                              8720  0x00002210 (const dword)  (not used)
HEX3                                4880  0x00001310 (const dword)  (not used)
HEX3Z                                784  0x00000310 (const dword)  (not used)
HEX3ZB                              8976  0x00002310 (const dword)  (not used)
HEX4                                5136  0x00001410 (const dword)  (not used)
HEX4Z                               1040  0x00000410 (const dword)  (not used)
HEX4ZB                              9232  0x00002410 (const dword)  (not used)
HEXZ                                1040  0x00000410 (const dword)  (not used)
HEXZB                               9232  0x00002410 (const dword)  (not used)
HI                                     1  0x00000001 (const dword)  (not used)
HIbyte                               -48  0xffffffd0 (PmmC func) args[1] r=1  (usage 6)
HIDE                                   2  0x00000002 (const dword)  (not used)
hndl                                   2  0x00000002 (mem) word (global)  (usage 3)
HONEYDEW                           63486  0x0000f7fe (const dword)  (usage 2)
HOTPINK                            64342  0x0000fb56 (const dword)  (usage 2)
HYPER                                  3  0x00000003 (const dword)  (not used)
I2C1                               63520  0x0000f820 (const dword)  (not used)
I2C1_Ack                            -305  0xfffffecf (PmmC func) args[0] r=0  (not used)
I2C1_AckPoll                        -314  0xfffffec6 (PmmC func) args[1] r=1  (not used)
I2C1_AckStatus                      -311  0xfffffec9 (PmmC func) args[0] r=1  (not used)
I2C1_Close                          -287  0xfffffee1 (PmmC func) args[0] r=0  (not used)
I2C1_Getn                           -323  0xfffffebd (PmmC func) args[2] r=1  (not used)
I2C1_Gets                           -320  0xfffffec0 (PmmC func) args[2] r=1  (not used)
I2C1_Idle                           -317  0xfffffec3 (PmmC func) args[0] r=1  (not used)
I2C1_Nack                           -308  0xfffffecc (PmmC func) args[0] r=0  (not used)
I2C1_Open                           -284  0xfffffee4 (PmmC func) args[3] r=1  (not used)
I2C1_Putn                           -329  0xfffffeb7 (PmmC func) args[2] r=1  (not used)
I2C1_Puts                           -326  0xfffffeba (PmmC func) args[1] r=1  (not used)
I2C1_Read                           -299  0xfffffed5 (PmmC func) args[0] r=1  (not used)
I2C1_Restart                        -296  0xfffffed8 (PmmC func) args[0] r=1  (not used)
I2C1_Start                          -290  0xfffffede (PmmC func) args[0] r=1  (not used)
I2C1_Stop                           -293  0xfffffedb (PmmC func) args[0] r=1  (not used)
I2C1_Write                          -302  0xfffffed2 (PmmC func) args[1] r=1  (not used)
I2C2                               63521  0x0000f821 (const dword)  (not used)
I2C2_Ack                            -306  0xfffffece (PmmC func) args[0] r=0  (not used)
I2C2_AckPoll                        -315  0xfffffec5 (PmmC func) args[1] r=1  (not used)
I2C2_AckStatus                      -312  0xfffffec8 (PmmC func) args[0] r=1  (not used)
I2C2_Close                          -288  0xfffffee0 (PmmC func) args[0] r=0  (not used)
I2C2_Getn                           -324  0xfffffebc (PmmC func) args[2] r=1  (not used)
I2C2_Gets                           -321  0xfffffebf (PmmC func) args[2] r=1  (not used)
I2C2_Idle                           -318  0xfffffec2 (PmmC func) args[0] r=1  (not used)
I2C2_Nack                           -309  0xfffffecb (PmmC func) args[0] r=0  (not used)
I2C2_Open                           -285  0xfffffee3 (PmmC func) args[3] r=1  (not used)
I2C2_Putn                           -330  0xfffffeb6 (PmmC func) args[2] r=1  (not used)
I2C2_Puts                           -327  0xfffffeb9 (PmmC func) args[1] r=1  (not used)
I2C2_Read                           -300  0xfffffed4 (PmmC func) args[0] r=1  (not used)
I2C2_Restart                        -297  0xfffffed7 (PmmC func) args[0] r=1  (not used)
I2C2_Start                          -291  0xfffffedd (PmmC func) args[0] r=1  (not used)
I2C2_Stop                           -294  0xfffffeda (PmmC func) args[0] r=1  (not used)
I2C2_Write                          -303  0xfffffed1 (PmmC func) args[1] r=1  (not used)
I2C3                               63522  0x0000f822 (const dword)  (not used)
I2C3_Ack                            -307  0xfffffecd (PmmC func) args[0] r=0  (not used)
I2C3_AckPoll                        -316  0xfffffec4 (PmmC func) args[1] r=1  (not used)
I2C3_AckStatus                      -313  0xfffffec7 (PmmC func) args[0] r=1  (not used)
I2C3_Close                          -289  0xfffffedf (PmmC func) args[0] r=0  (not used)
I2C3_Getn                           -325  0xfffffebb (PmmC func) args[2] r=1  (not used)
I2C3_Gets                           -322  0xfffffebe (PmmC func) args[2] r=1  (not used)
I2C3_Idle                           -319  0xfffffec1 (PmmC func) args[0] r=1  (not used)
I2C3_Nack                           -310  0xfffffeca (PmmC func) args[0] r=0  (not used)
I2C3_Open                           -286  0xfffffee2 (PmmC func) args[3] r=1  (not used)
I2C3_Putn                           -331  0xfffffeb5 (PmmC func) args[2] r=1  (not used)
I2C3_Puts                           -328  0xfffffeb8 (PmmC func) args[1] r=1  (not used)
I2C3_Read                           -301  0xfffffed3 (PmmC func) args[0] r=1  (not used)
I2C3_Restart                        -298  0xfffffed6 (PmmC func) args[0] r=1  (not used)
I2C3_Start                          -292  0xfffffedc (PmmC func) args[0] r=1  (not used)
I2C3_Stop                           -295  0xfffffed9 (PmmC func) args[0] r=1  (not used)
I2C3_Write                          -304  0xfffffed0 (PmmC func) args[1] r=1  (not used)
I2C_10KHZ                              3  0x00000003 (const dword)  (not used)
I2C_20KHZ                              4  0x00000004 (const dword)  (not used)
I2C_250KHZ                             6  0x00000006 (const dword)  (not used)
I2C_50KHZ                              5  0x00000005 (const dword)  (not used)
I2C_FAST                               2  0x00000002 (const dword)  (not used)
I2C_MED                                1  0x00000001 (const dword)  (not used)
I2C_SLOW                               0  0x00000000 (const dword)  (not used)
I_COLOUR16                            16  0x00000010 (const dword)  (not used)
I_DARKEN                           16384  0x00004000 (const dword)  (not used)
I_ENABLED                          32768  0x00008000 (const dword)  (not used)
I_LIGHTEN                           8192  0x00002000 (const dword)  (not used)
I_MOVIE                              128  0x00000080 (const dword)  (not used)
I_NOGROUP                             64  0x00000040 (const dword)  (not used)
I_STAYONTOP                          256  0x00000100 (const dword)  (not used)
I_TOPMOST                            512  0x00000200 (const dword)  (not used)
I_TOUCH_DISABLE                       32  0x00000020 (const dword)  (not used)
I_TOUCHED                           4096  0x00001000 (const dword)  (not used)
I_X_LOCK                            1024  0x00000400 (const dword)  (not used)
I_Y_LOCK                            2048  0x00000800 (const dword)  (not used)
IMAGE_CLUSTER                         10  0x0000000a (const dword)  (not used)
IMAGE_DELAY                            7  0x00000007 (const dword)  (not used)
IMAGE_FLAGS                            6  0x00000006 (const dword)  (not used)
IMAGE_FRAMES                           8  0x00000008 (const dword)  (not used)
IMAGE_HEIGHT                           5  0x00000005 (const dword)  (not used)
IMAGE_HIWORD                           1  0x00000001 (const dword)  (not used)
IMAGE_INDEX                            9  0x00000009 (const dword)  (not used)
IMAGE_LOWORD                           0  0x00000000 (const dword)  (not used)
IMAGE_SECTOR                          11  0x0000000b (const dword)  (not used)
IMAGE_TAG                             12  0x0000000c (const dword)  (not used)
IMAGE_TAG2                            13  0x0000000d (const dword)  (not used)
IMAGE_WIDTH                            4  0x00000004 (const dword)  (not used)
IMAGE_XPOS                             2  0x00000002 (const dword)  (not used)
IMAGE_YPOS                             3  0x00000003 (const dword)  (not used)
img_ClearAttributes                 -383  0xfffffe81 (PmmC func) args[3] r=1  (not used)
IMG_COUNT                              0  0x00000000 (const dword)  (not used)
IMG_CURRENT_FRAME                     89  0x00000059 (const dword)  (not used)
img_Darken                          -377  0xfffffe87 (PmmC func) args[2] r=1  (not used)
IMG_DAT_FILENAME                       4  0x00000004 (const dword)  (not used)
img_Disable                         -376  0xfffffe88 (PmmC func) args[2] r=1  (not used)
img_Enable                          -375  0xfffffe89 (PmmC func) args[2] r=1  (not used)
IMG_ENTRYLEN                           1  0x00000001 (const dword)  (not used)
IMG_FLAGS                             85  0x00000055 (const dword)  (not used)
IMG_FRAME_COUNT                       86  0x00000056 (const dword)  (not used)
IMG_FRAME_DELAY                       84  0x00000054 (const dword)  (not used)
IMG_GCI_FILENAME                       3  0x00000003 (const dword)  (not used)
IMG_GCIFILE_HANDLE                     5  0x00000005 (const dword)  (not used)
img_GetWord                         -380  0xfffffe84 (PmmC func) args[3] r=1  (not used)
IMG_HEIGHT                            83  0x00000053 (const dword)  (not used)
img_Lighten                         -378  0xfffffe86 (PmmC func) args[2] r=1  (not used)
IMG_MODE                               2  0x00000002 (const dword)  (not used)
IMG_PIXEL_COUNT_HI                    88  0x00000058 (const dword)  (not used)
IMG_PIXEL_COUNT_LO                    87  0x00000057 (const dword)  (not used)
img_SelectReadPosition              -385  0xfffffe7f (PmmC func) args[5] r=1  (not used)
img_SequentialRead                  -386  0xfffffe7e (PmmC func) args[2] r=1  (not used)
img_SetAttributes                   -382  0xfffffe82 (PmmC func) args[3] r=1  (not used)
img_SetPosition                     -374  0xfffffe8a (PmmC func) args[4] r=1  (not used)
img_SetWord                         -379  0xfffffe85 (PmmC func) args[4] r=1  (not used)
img_Show                            -381  0xfffffe83 (PmmC func) args[2] r=1  (not used)
img_Touched                         -384  0xfffffe80 (PmmC func) args[2] r=1  (not used)
IMG_WIDTH                             82  0x00000052 (const dword)  (not used)
INDIANRED                          51947  0x0000caeb (const dword)  (usage 2)
INDIGO                             18448  0x00004810 (const dword)  (usage 2)
interrupt                         UNRESOLVED (User func) args[0] r=0  (not used)
INVERSE                               64  0x00000040 (const dword)  (not used)
isalnum                              -41  0xffffffd7 (PmmC func) args[1] r=1  (not used)
isalpha                              -40  0xffffffd8 (PmmC func) args[1] r=1  (not used)
isdigit                              -36  0xffffffdc (PmmC func) args[1] r=1  (not used)
islower                              -39  0xffffffd9 (PmmC func) args[1] r=1  (not used)
isprint                              -42  0xffffffd6 (PmmC func) args[1] r=1  (not used)
isspace                              -43  0xffffffd5 (PmmC func) args[1] r=1  (not used)
isupper                              -38  0xffffffda (PmmC func) args[1] r=1  (not used)
iswhite                              -44  0xffffffd4 (PmmC func) args[1] r=1  (not used)
isxdigit                             -37  0xffffffdb (PmmC func) args[1] r=1  (not used)
ITALIC                                32  0x00000020 (const dword)  (not used)
iterator                            -404  0xfffffe6c (PmmC func) args[1] r=0  (not used)
IVORY                              65534  0x0000fffe (const dword)  (usage 2)
KHAKI                              63281  0x0000f731 (const dword)  (usage 2)
LANDSCAPE                              0  0x00000000 (const dword)  (usage 3)
LANDSCAPE_R                            1  0x00000001 (const dword)  (not used)
LAVENDER                           59199  0x0000e73f (const dword)  (usage 2)
LAVENDERBLUSH                      65438  0x0000ff9e (const dword)  (usage 2)
LAWNGREEN                          32736  0x00007fe0 (const dword)  (usage 2)
LEFT_POS                               2  0x00000002 (const dword)  (not used)
LEMONCHIFFON                       65497  0x0000ffd9 (const dword)  (usage 2)
LIGHTBLUE                          44764  0x0000aedc (const dword)  (usage 2)
LIGHTCORAL                         62480  0x0000f410 (const dword)  (usage 2)
LIGHTCYAN                          59391  0x0000e7ff (const dword)  (usage 2)
LIGHTGOLD                          65498  0x0000ffda (const dword)  (usage 2)
LIGHTGREEN                         38770  0x00009772 (const dword)  (usage 2)
LIGHTGREY                          54938  0x0000d69a (const dword)  (usage 80)
LIGHTPINK                          64952  0x0000fdb8 (const dword)  (usage 2)
LIGHTSALMON                        64783  0x0000fd0f (const dword)  (usage 2)
LIGHTSEAGREEN                       9621  0x00002595 (const dword)  (usage 2)
LIGHTSKYBLUE                       34431  0x0000867f (const dword)  (usage 2)
LIGHTSLATEGRAY                     29779  0x00007453 (const dword)  (usage 2)
LIGHTSTEELBLUE                     46651  0x0000b63b (const dword)  (usage 2)
LIGHTYELLOW                        65532  0x0000fffc (const dword)  (usage 2)
LIME                                2016  0x000007e0 (const dword)  (usage 32)
LIMEGREEN                          13926  0x00003666 (const dword)  (usage 2)
line                                   1  0x00000001 (const dword)  (usage 18)
LINE_PATTERN                          26  0x0000001a (const dword)  (not used)
LINEN                              65436  0x0000ff9c (const dword)  (usage 2)
lineParam                           8328  0x00002088 (User func) args[0] r=0  (usage 3)
list                                  14  0x0000000e (mem) word[30] (global)  (usage 81)
LO                                     0  0x00000000 (const dword)  (not used)
LObyte                               -47  0xffffffd1 (PmmC func) args[1] r=1  (usage 6)
LOCAL                             7693288  0x007563e8(macro) //   (not used)
LPCOARSE                           61680  0x0000f0f0 (const dword)  (not used)
LPDASHDOT                            975  0x000003cf (const dword)  (not used)
LPDASHDOTDOT                         819  0x00000333 (const dword)  (not used)
LPFINE                             43690  0x0000aaaa (const dword)  (not used)
LPMEDIUM                           13107  0x00003333 (const dword)  (not used)
LPSOLID                                0  0x00000000 (const dword)  (not used)
M_PA0                                  1  0x00000001 (const dword)  (not used)
M_PA1                                  2  0x00000002 (const dword)  (not used)
M_PA10                              1024  0x00000400 (const dword)  (not used)
M_PA11                              2048  0x00000800 (const dword)  (not used)
M_PA12                              4096  0x00001000 (const dword)  (not used)
M_PA13                              8192  0x00002000 (const dword)  (not used)
M_PA14                             16384  0x00004000 (const dword)  (not used)
M_PA15                             32768  0x00008000 (const dword)  (not used)
M_PA2                                  4  0x00000004 (const dword)  (not used)
M_PA3                                  8  0x00000008 (const dword)  (not used)
M_PA4                                 16  0x00000010 (const dword)  (not used)
M_PA5                                 32  0x00000020 (const dword)  (not used)
M_PA6                                 64  0x00000040 (const dword)  (not used)
M_PA7                                128  0x00000080 (const dword)  (not used)
M_PA8                                256  0x00000100 (const dword)  (not used)
M_PA9                                512  0x00000200 (const dword)  (not used)
MAGENTA                            63519  0x0000f81f (const dword)  (usage 2)
main                                 842  0x0000034a (User func) args[0] r=0  (not used)
mainMenu                            1342  0x0000053e (User func) args[0] r=0  (usage 17)
MAROON                             32768  0x00008000 (const dword)  (usage 2)
max                                   30  0x0000001e (const dword)  (usage 6)
MAX                                  -55  0xffffffc9 (PmmC func) args[2] r=1  (not used)
maxBuff                               50  0x00000032 (const dword)  (usage 12)
MDA                                63552  0x0000f840 (const dword)  (not used)
MEDIA_ADDRESS_HI                      91  0x0000005b (const dword)  (not used)
MEDIA_ADDRESS_LO                      90  0x0000005a (const dword)  (not used)
media_Flush                         -218  0xffffff26 (PmmC func) args[0] r=1  (not used)
media_Image                         -217  0xffffff27 (PmmC func) args[2] r=0  (not used)
media_Init                          -219  0xffffff25 (PmmC func) args[0] r=1  (not used)
media_RdSector                      -211  0xffffff2d (PmmC func) args[1] r=1  (not used)
media_ReadByte                      -213  0xffffff2b (PmmC func) args[0] r=1  (not used)
media_ReadWord                      -214  0xffffff2a (PmmC func) args[0] r=1  (not used)
MEDIA_SECTOR_COUNT                    94  0x0000005e (const dword)  (not used)
MEDIA_SECTOR_HI                       93  0x0000005d (const dword)  (not used)
MEDIA_SECTOR_LO                       92  0x0000005c (const dword)  (not used)
media_SetAdd                        -209  0xffffff2f (PmmC func) args[2] r=0  (not used)
media_SetSector                     -210  0xffffff2e (PmmC func) args[2] r=0  (not used)
media_Video                         -207  0xffffff31 (PmmC func) args[2] r=0  (not used)
media_VideoFrame                    -208  0xffffff30 (PmmC func) args[3] r=0  (not used)
media_WriteByte                     -215  0xffffff29 (PmmC func) args[1] r=1  (not used)
media_WriteWord                     -216  0xffffff28 (PmmC func) args[1] r=1  (not used)
media_WrSector                      -212  0xffffff2c (PmmC func) args[1] r=1  (not used)
MEDIUMAQUAMARINE                   26229  0x00006675 (const dword)  (usage 2)
MEDIUMBLUE                            25  0x00000019 (const dword)  (usage 8)
MEDIUMORCHID                       47802  0x0000baba (const dword)  (usage 2)
MEDIUMPURPLE                       37787  0x0000939b (const dword)  (usage 2)
MEDIUMSEAGREEN                     15758  0x00003d8e (const dword)  (usage 2)
MEDIUMSLATEBLUE                    31581  0x00007b5d (const dword)  (usage 2)
MEDIUMSPRINGGREEN                   2003  0x000007d3 (const dword)  (usage 2)
MEDIUMTURQUOISE                    20121  0x00004e99 (const dword)  (usage 2)
MEDIUMVIOLETRED                    49328  0x0000c0b0 (const dword)  (usage 2)
mem_Alloc                           -413  0xfffffe63 (PmmC func) args[1] r=1  (not used)
mem_AllocV                          -414  0xfffffe62 (PmmC func) args[1] r=1  (not used)
mem_AllocZ                          -415  0xfffffe61 (PmmC func) args[1] r=1  (usage 12)
mem_ArrayOp1                         -67  0xffffffbd (PmmC func) args[4] r=0  (not used)
mem_ArrayOp2                         -68  0xffffffbc (PmmC func) args[5] r=0  (not used)
mem_Compare                         -421  0xfffffe5b (PmmC func) args[3] r=1  (not used)
mem_Copy                            -420  0xfffffe5c (PmmC func) args[3] r=1  (not used)
mem_Free                            -417  0xfffffe5f (PmmC func) args[1] r=1  (usage 3)
mem_Heap                            -418  0xfffffe5e (PmmC func) args[0] r=1  (not used)
mem_Realloc                         -416  0xfffffe60 (PmmC func) args[2] r=1  (not used)
mem_Set                             -419  0xfffffe5d (PmmC func) args[3] r=1  (not used)
MIDI                                   9  0x00000009 (const dword)  (not used)
MIDNIGHTBLUE                        6350  0x000018ce (const dword)  (usage 2)
MIN                                  -54  0xffffffca (PmmC func) args[2] r=1  (not used)
MINTCREAM                          63487  0x0000f7ff (const dword)  (usage 2)
MISTYROSE                          65340  0x0000ff3c (const dword)  (usage 2)
MOCCASIN                           65334  0x0000ff36 (const dword)  (usage 2)
NAVAJOWHITE                        65269  0x0000fef5 (const dword)  (usage 2)
NAVY                                  16  0x00000010 (const dword)  (usage 32)
NOTOUCH                                0  0x00000000 (const dword)  (not used)
NULL                                   0  0x00000000 (const dword)  (usage 15)
numPadInput                        10056  0x00002748 (User func) args[0] r=0  (usage 12)
NybleSwap                            -50  0xffffffce (PmmC func) args[1] r=1  (not used)
OBJECT_COLOUR                         18  0x00000012 (const dword)  (not used)
OFF                                    0  0x00000000 (const dword)  (not used)
OLDLACE                            65468  0x0000ffbc (const dword)  (usage 2)
OLIVE                              33792  0x00008400 (const dword)  (usage 2)
OLIVEDRAB                          27748  0x00006c64 (const dword)  (usage 2)
ON                                     1  0x00000001 (const dword)  (not used)
OP1_ADD                                5  0x00000005 (const dword)  (not used)
OP1_AND                                2  0x00000002 (const dword)  (not used)
OP1_BLACKEN                           16  0x00000010 (const dword)  (not used)
OP1_DARKEN                            18  0x00000012 (const dword)  (not used)
OP1_DIV                                8  0x00000008 (const dword)  (not used)
OP1_GRAY                              14  0x0000000e (const dword)  (not used)
OP1_IOR                                3  0x00000003 (const dword)  (not used)
OP1_LIGHTEN                           17  0x00000011 (const dword)  (not used)
OP1_MUL                                7  0x00000007 (const dword)  (not used)
OP1_NOP                                0  0x00000000 (const dword)  (not used)
OP1_REV                                9  0x00000009 (const dword)  (not used)
OP1_ROL                               12  0x0000000c (const dword)  (not used)
OP1_ROR                               13  0x0000000d (const dword)  (not used)
OP1_SET                                1  0x00000001 (const dword)  (not used)
OP1_SHL                               10  0x0000000a (const dword)  (not used)
OP1_SHR                               11  0x0000000b (const dword)  (not used)
OP1_SUB                                6  0x00000006 (const dword)  (not used)
OP1_WHITEN                            15  0x0000000f (const dword)  (not used)
OP1_XOR                                4  0x00000004 (const dword)  (not used)
OP2_ADD                                4  0x00000004 (const dword)  (not used)
OP2_AND                                1  0x00000001 (const dword)  (not used)
OP2_BLEND                              9  0x00000009 (const dword)  (not used)
OP2_COPY                               8  0x00000008 (const dword)  (not used)
OP2_DIV                                7  0x00000007 (const dword)  (not used)
OP2_IOR                                2  0x00000002 (const dword)  (not used)
OP2_MUL                                6  0x00000006 (const dword)  (not used)
OP2_SUB                                5  0x00000005 (const dword)  (not used)
OP2_XOR                                3  0x00000003 (const dword)  (not used)
OPAQUE                                 1  0x00000001 (const dword)  (usage 3)
ORANGE                             64800  0x0000fd20 (const dword)  (usage 2)
ORANGERED                          64032  0x0000fa20 (const dword)  (usage 2)
ORCHID                             56218  0x0000db9a (const dword)  (usage 2)
OUTLINE                                1  0x00000001 (const dword)  (not used)
OUTLINE_COLOUR                        24  0x00000018 (const dword)  (not used)
OVF                                  -63  0xffffffc1 (PmmC func) args[0] r=1  (not used)
PA0                                    1  0x00000001 (const dword)  (usage 3)
PA1                                    2  0x00000002 (const dword)  (usage 3)
PA10                                  11  0x0000000b (const dword)  (not used)
PA11                                  12  0x0000000c (const dword)  (not used)
PA12                                  13  0x0000000d (const dword)  (not used)
PA13                                  14  0x0000000e (const dword)  (usage 2)
PA14                                  15  0x0000000f (const dword)  (not used)
PA15                                  16  0x00000010 (const dword)  (not used)
PA2                                    3  0x00000003 (const dword)  (not used)
PA3                                    4  0x00000004 (const dword)  (not used)
PA4                                    5  0x00000005 (const dword)  (not used)
PA5                                    6  0x00000006 (const dword)  (not used)
PA6                                    7  0x00000007 (const dword)  (not used)
PA7                                    8  0x00000008 (const dword)  (not used)
PA8                                    9  0x00000009 (const dword)  (not used)
PA9                                   10  0x0000000a (const dword)  (not used)
PALEGOLDENROD                      61269  0x0000ef55 (const dword)  (usage 2)
PALEGREEN                          40915  0x00009fd3 (const dword)  (usage 2)
PALETURQUOISE                      44925  0x0000af7d (const dword)  (usage 2)
PALEVIOLETRED                      56210  0x0000db92 (const dword)  (usage 2)
PANEL_FRAME                            3  0x00000003 (const dword)  (not used)
PANEL_HIDE                             2  0x00000002 (const dword)  (not used)
PANEL_RAISED                           1  0x00000001 (const dword)  (not used)
PANEL_SUNKEN                           0  0x00000000 (const dword)  (not used)
PAPAYAWHIP                         65402  0x0000ff7a (const dword)  (usage 2)
pause                                 -6  0xfffffffa (PmmC func) args[1] r=0  (usage 6)
PEACHPUFF                          65239  0x0000fed7 (const dword)  (usage 2)
peekW                                -34  0xffffffde (PmmC func) args[1] r=1  (not used)
PEN_SIZE                              16  0x00000010 (const dword)  (not used)
PERU                               52263  0x0000cc27 (const dword)  (usage 2)
PIN_AN                                 5  0x00000005 (const dword)  (not used)
PIN_ANAVG                              6  0x00000006 (const dword)  (not used)
pin_Counter                         -514  0xfffffdfe (PmmC func) args[3] r=1  (not used)
PIN_COUNTER_PA4                      123  0x0000007b (const dword)  (not used)
PIN_COUNTER_PA5                      124  0x0000007c (const dword)  (not used)
PIN_COUNTER_PA6                      125  0x0000007d (const dword)  (not used)
PIN_COUNTER_PA7                      126  0x0000007e (const dword)  (not used)
PIN_COUNTER_PA8                      127  0x0000007f (const dword)  (not used)
PIN_COUNTER_PA9                      128  0x00000080 (const dword)  (not used)
PIN_EVENT_PA4                        129  0x00000081 (const dword)  (not used)
PIN_EVENT_PA5                        130  0x00000082 (const dword)  (not used)
PIN_EVENT_PA6                        131  0x00000083 (const dword)  (not used)
PIN_EVENT_PA7                        132  0x00000084 (const dword)  (not used)
PIN_EVENT_PA8                        133  0x00000085 (const dword)  (not used)
PIN_EVENT_PA9                        134  0x00000086 (const dword)  (not used)
pin_HI                              -113  0xffffff8f (PmmC func) args[1] r=1  (not used)
PIN_INP                                0  0x00000000 (const dword)  (not used)
PIN_INP_HI                             1  0x00000001 (const dword)  (not used)
PIN_INP_LO                             2  0x00000002 (const dword)  (not used)
pin_LO                              -114  0xffffff8e (PmmC func) args[1] r=1  (not used)
PIN_OUT                                3  0x00000003 (const dword)  (not used)
PIN_OUT_OD                             4  0x00000004 (const dword)  (not used)
pin_Pulseout                        -512  0xfffffe00 (PmmC func) args[2] r=1  (not used)
pin_PulseoutB                       -513  0xfffffdff (PmmC func) args[2] r=1  (not used)
pin_Read                            -116  0xffffff8c (PmmC func) args[1] r=1  (not used)
pin_Set                             -112  0xffffff90 (PmmC func) args[2] r=1  (not used)
pin_Val                             -115  0xffffff8d (PmmC func) args[2] r=0  (not used)
PINK                               65049  0x0000fe19 (const dword)  (usage 2)
PLUM                               56603  0x0000dd1b (const dword)  (usage 2)
pokeW                                -35  0xffffffdd (PmmC func) args[2] r=0  (not used)
PORTRAIT                               2  0x00000002 (const dword)  (not used)
PORTRAIT_R                             3  0x00000003 (const dword)  (not used)
POWDERBLUE                         46876  0x0000b71c (const dword)  (usage 2)
printNumber                        12146  0x00002f72 (User func) args[1] r=0  (usage 48)
PROGRESSBAR_HIDE                       2  0x00000002 (const dword)  (not used)
PROGRESSBAR_RAISED                 65535  0x0000ffff (const dword)  (not used)
PROGRESSBAR_SUNKEN                 65534  0x0000fffe (const dword)  (not used)
PTN_BDIAGONAL                      65518  0x0000ffee (const ??? 0)  (not used)
PTN_BRICKS                         65521  0x0000fff1 (const ??? 0)  (not used)
PTN_BS_HORIZONTAL                  65510  0x0000ffe6 (const ??? 0)  (not used)
PTN_BS_VERTICAL                    65509  0x0000ffe5 (const ??? 0)  (not used)
PTN_BSHORIZONTAL                   65516  0x0000ffec (const ??? 0)  (not used)
PTN_BSVERTICAL                     65515  0x0000ffeb (const ??? 0)  (not used)
PTN_CARGONET                       65522  0x0000fff2 (const ??? 0)  (not used)
PTN_CIRCUITS                       65523  0x0000fff3 (const ??? 0)  (not used)
PTN_COBBLESTONES                   65524  0x0000fff4 (const ??? 0)  (not used)
PTN_COURSE_B_DIAGONAL              65512  0x0000ffe8 (const ??? 0)  (not used)
PTN_COURSE_CROSS                   65513  0x0000ffe9 (const ??? 0)  (not used)
PTN_COURSE_DIAGONALCROSS           65514  0x0000ffea (const ??? 0)  (not used)
PTN_COURSE_DOTS                    65508  0x0000ffe4 (const ??? 0)  (not used)
PTN_COURSE_F_DIAGONAL              65511  0x0000ffe7 (const ??? 0)  (not used)
PTN_CROSSES                        65535  0x0000ffff (const ??? 0)  (not used)
PTN_DAISIES                        65525  0x0000fff5 (const ??? 0)  (not used)
PTN_DIZZY                          65526  0x0000fff6 (const ??? 0)  (not used)
PTN_EMPTY                          65504  0x0000ffe0 (const dword)  (not used)
PTN_FDIAGONAL                      65517  0x0000ffed (const ??? 0)  (not used)
PTN_FIELDEFFECT                    65527  0x0000fff7 (const ??? 0)  (not used)
PTN_FINE_CROSS                     65519  0x0000ffef (const ??? 0)  (not used)
PTN_FINE_DIAGONAL_CROSS            65520  0x0000fff0 (const ??? 0)  (not used)
PTN_FINE_DOTS                      65506  0x0000ffe2 (const ??? 0)  (not used)
PTN_KEY                            65528  0x0000fff8 (const ??? 0)  (not used)
PTN_MEDIUM_DOTS                    65507  0x0000ffe3 (const ??? 0)  (not used)
PTN_ROUNDER                        65529  0x0000fff9 (const ??? 0)  (not used)
PTN_SCALES                         65530  0x0000fffa (const ??? 0)  (not used)
PTN_SOLID                          65505  0x0000ffe1 (const ??? 0)  (not used)
PTN_STONE                          65531  0x0000fffb (const ??? 0)  (not used)
PTN_THATCHES                       65532  0x0000fffc (const ??? 0)  (not used)
PTN_TILE                           65533  0x0000fffd (const ??? 0)  (not used)
PTN_WAFFLESREVENGE                 65534  0x0000fffe (const ??? 0)  (not used)
PURPLE                             32784  0x00008010 (const dword)  (usage 2)
putch                                 -2  0xfffffffe (PmmC func) args[1] r=0  (not used)
putchXY                               -3  0xfffffffd (PmmC func) args[3] r=0  (not used)
putnum                                -7  0xfffffff9 (PmmC func) args[2] r=1  (not used)
putstr                                -9  0xfffffff7 (PmmC func) args[1] r=1  (usage 6)
putstrCentred                         -5  0xfffffffb (PmmC func) args[3] r=0  (usage 12)
putstrXY                              -4  0xfffffffc (PmmC func) args[3] r=0  (not used)
PWM_BINARY                             3  0x00000003 (const dword)  (not used)
pwm_Init                            -521  0xfffffdf7 (PmmC func) args[3] r=1  (not used)
PWM_OFF                                0  0x00000000 (const dword)  (not used)
PWM_PLAIN                              1  0x00000001 (const dword)  (not used)
PWM_SERVO                              2  0x00000002 (const dword)  (not used)
QEN1_COUNTER_HI                      136  0x00000088 (const dword)  (not used)
QEN1_COUNTER_LO                      135  0x00000087 (const dword)  (not used)
QEN1_DELTA                           137  0x00000089 (const dword)  (not used)
QEN2_COUNTER_HI                      139  0x0000008b (const dword)  (not used)
QEN2_COUNTER_LO                      138  0x0000008a (const dword)  (not used)
QEN2_DELTA                           140  0x0000008c (const dword)  (not used)
Qencoder1                           -515  0xfffffdfd (PmmC func) args[3] r=1  (not used)
Qencoder1Reset                      -517  0xfffffdfb (PmmC func) args[0] r=0  (not used)
Qencoder2                           -516  0xfffffdfc (PmmC func) args[3] r=1  (not used)
Qencoder2Reset                      -518  0xfffffdfa (PmmC func) args[0] r=0  (not used)
RAND                                 -59  0xffffffc5 (PmmC func) args[0] r=1  (not used)
RANDOM_HI                             33  0x00000021 (const dword)  (not used)
RANDOM_LO                             32  0x00000020 (const dword)  (not used)
RANDVAL                              -60  0xffffffc4 (PmmC func) args[2] r=1  (not used)
rectangle                              2  0x00000002 (const dword)  (usage 18)
rectParam                           6583  0x000019b7 (User func) args[0] r=0  (usage 3)
RED                                63488  0x0000f800 (const dword)  (usage 86)
RIGHT_POS                              4  0x00000004 (const dword)  (not used)
ROSYBROWN                          48241  0x0000bc71 (const dword)  (usage 2)
ROYALBLUE                          17244  0x0000435c (const dword)  (usage 2)
RUNFLASH                             128  0x00000080 (const dword)  (not used)
SADDLEBROWN                        35362  0x00008a22 (const dword)  (usage 2)
SALMON                             64526  0x0000fc0e (const dword)  (usage 2)
SANDYBROWN                         62764  0x0000f52c (const dword)  (usage 2)
SAVE_TO_DISK                           7  0x00000007 (const dword)  (not used)
SCREEN_MODE                           23  0x00000017 (const dword)  (not used)
SEAGREEN                           11338  0x00002c4a (const dword)  (usage 2)
SEASHELL                           65469  0x0000ffbd (const dword)  (usage 2)
SEED                                 -61  0xffffffc3 (PmmC func) args[1] r=0  (not used)
serin                               -236  0xffffff14 (PmmC func) args[0] r=1  (not used)
serin1                              -237  0xffffff13 (PmmC func) args[0] r=1  (not used)
serin2                              -238  0xffffff12 (PmmC func) args[0] r=1  (not used)
serin3                              -239  0xffffff11 (PmmC func) args[0] r=1  (not used)
serout                              -240  0xffffff10 (PmmC func) args[1] r=0  (usage 9)
serout1                             -241  0xffffff0f (PmmC func) args[1] r=0  (usage 24)
serout2                             -242  0xffffff0e (PmmC func) args[1] r=0  (not used)
serout3                             -243  0xffffff0d (PmmC func) args[1] r=0  (not used)
setbaud                             -224  0xffffff20 (PmmC func) args[1] r=0  (usage 3)
shapeInputTemplate                 10486  0x000028f6 (User func) args[0] r=0  (usage 12)
shapeLoop                          11036  0x00002b1c (User func) args[0] r=0  (usage 3)
shapeMenu                          11417  0x00002c99 (User func) args[0] r=0  (usage 15)
shapeParam                           334  0x0000014e (mem) word[5] (global)  (usage 54)
SIENNA                             41605  0x0000a285 (const dword)  (usage 2)
SILVER                             50712  0x0000c618 (const dword)  (usage 2)
SIN                                  -57  0xffffffc7 (PmmC func) args[1] r=1  (not used)
SKYBLUE                            34429  0x0000867d (const dword)  (usage 2)
SLATEBLUE                          27353  0x00006ad9 (const dword)  (usage 2)
SLATEGRAY                          29714  0x00007412 (const dword)  (usage 2)
SLIDER_HIDE                            2  0x00000002 (const dword)  (not used)
SLIDER_RAISED                          1  0x00000001 (const dword)  (not used)
SLIDER_SUNKEN                          0  0x00000000 (const dword)  (not used)
snd_BufSize                         -461  0xfffffe33 (PmmC func) args[1] r=0  (not used)
snd_Continue                        -464  0xfffffe30 (PmmC func) args[0] r=0  (not used)
snd_Pause                           -463  0xfffffe31 (PmmC func) args[0] r=0  (not used)
snd_Pitch                           -460  0xfffffe34 (PmmC func) args[1] r=1  (not used)
snd_Playing                         -465  0xfffffe2f (PmmC func) args[0] r=1  (not used)
snd_Stop                            -462  0xfffffe32 (PmmC func) args[0] r=0  (not used)
snd_Volume                          -459  0xfffffe35 (PmmC func) args[1] r=0  (not used)
SNOW                               65503  0x0000ffdf (const dword)  (usage 2)
SOLID                                  0  0x00000000 (const dword)  (not used)
SPI1                                   1  0x00000001 (const dword)  (not used)
SPI16_MODE_0                           8  0x00000008 (const dword)  (not used)
SPI16_MODE_1                           9  0x00000009 (const dword)  (not used)
SPI16_MODE_2                          10  0x0000000a (const dword)  (not used)
SPI16_MODE_3                          11  0x0000000b (const dword)  (not used)
SPI16_MODE_4                          12  0x0000000c (const dword)  (not used)
SPI16_MODE_5                          13  0x0000000d (const dword)  (not used)
SPI16_MODE_6                          14  0x0000000e (const dword)  (not used)
SPI16_MODE_7                          15  0x0000000f (const dword)  (not used)
SPI1_Init                           -349  0xfffffea3 (PmmC func) args[2] r=1  (not used)
SPI1_Read                           -352  0xfffffea0 (PmmC func) args[0] r=1  (not used)
spi1_ReadBlock                      -333  0xfffffeb3 (PmmC func) args[2] r=0  (not used)
SPI1_SCK_pin                        -346  0xfffffea6 (PmmC func) args[1] r=1  (not used)
SPI1_SDI_pin                        -343  0xfffffea9 (PmmC func) args[1] r=1  (not used)
SPI1_SDO_pin                        -340  0xfffffeac (PmmC func) args[1] r=1  (not used)
SPI1_Write                          -355  0xfffffe9d (PmmC func) args[1] r=1  (not used)
spi1_WriteBlock                     -359  0xfffffe99 (PmmC func) args[2] r=0  (not used)
SPI2                                   2  0x00000002 (const dword)  (not used)
SPI2_Init                           -350  0xfffffea2 (PmmC func) args[2] r=1  (not used)
SPI2_Read                           -353  0xfffffe9f (PmmC func) args[0] r=1  (not used)
spi2_ReadBlock                      -334  0xfffffeb2 (PmmC func) args[2] r=0  (not used)
SPI2_SCK_pin                        -347  0xfffffea5 (PmmC func) args[1] r=1  (not used)
SPI2_SDI_pin                        -344  0xfffffea8 (PmmC func) args[1] r=1  (not used)
SPI2_SDO_pin                        -341  0xfffffeab (PmmC func) args[1] r=1  (not used)
SPI2_Write                          -356  0xfffffe9c (PmmC func) args[1] r=1  (not used)
spi2_WriteBlock                     -360  0xfffffe98 (PmmC func) args[2] r=0  (not used)
SPI3                                   3  0x00000003 (const dword)  (not used)
SPI3_Init                           -351  0xfffffea1 (PmmC func) args[2] r=1  (not used)
SPI3_Read                           -354  0xfffffe9e (PmmC func) args[0] r=1  (not used)
spi3_ReadBlock                      -335  0xfffffeb1 (PmmC func) args[2] r=0  (not used)
SPI3_SCK_pin                        -348  0xfffffea4 (PmmC func) args[1] r=1  (not used)
SPI3_SDI_pin                        -345  0xfffffea7 (PmmC func) args[1] r=1  (not used)
SPI3_SDO_pin                        -342  0xfffffeaa (PmmC func) args[1] r=1  (not used)
SPI3_Write                          -357  0xfffffe9b (PmmC func) args[1] r=1  (not used)
spi3_WriteBlock                     -361  0xfffffe97 (PmmC func) args[2] r=0  (not used)
SPI8_MODE_0                            0  0x00000000 (const dword)  (not used)
SPI8_MODE_1                            1  0x00000001 (const dword)  (not used)
SPI8_MODE_2                            2  0x00000002 (const dword)  (not used)
SPI8_MODE_3                            3  0x00000003 (const dword)  (not used)
SPI8_MODE_4                            4  0x00000004 (const dword)  (not used)
SPI8_MODE_5                            5  0x00000005 (const dword)  (not used)
SPI8_MODE_6                            6  0x00000006 (const dword)  (not used)
SPI8_MODE_7                            7  0x00000007 (const dword)  (not used)
spi_Disable                         -339  0xfffffead (PmmC func) args[0] r=0  (not used)
spi_Init                            -336  0xfffffeb0 (PmmC func) args[3] r=0  (not used)
spi_Read                            -337  0xfffffeaf (PmmC func) args[0] r=1  (not used)
spi_ReadBlock                       -332  0xfffffeb4 (PmmC func) args[2] r=0  (not used)
SPI_SPEED0                             0  0x00000000 (const dword)  (not used)
SPI_SPEED1                             1  0x00000001 (const dword)  (not used)
SPI_SPEED10                           10  0x0000000a (const dword)  (not used)
SPI_SPEED11                           11  0x0000000b (const dword)  (not used)
SPI_SPEED12                           12  0x0000000c (const dword)  (not used)
SPI_SPEED13                           13  0x0000000d (const dword)  (not used)
SPI_SPEED14                           14  0x0000000e (const dword)  (not used)
SPI_SPEED15                           15  0x0000000f (const dword)  (not used)
SPI_SPEED2                             2  0x00000002 (const dword)  (not used)
SPI_SPEED3                             3  0x00000003 (const dword)  (not used)
SPI_SPEED4                             4  0x00000004 (const dword)  (not used)
SPI_SPEED5                             5  0x00000005 (const dword)  (not used)
SPI_SPEED6                             6  0x00000006 (const dword)  (not used)
SPI_SPEED7                             7  0x00000007 (const dword)  (not used)
SPI_SPEED8                             8  0x00000008 (const dword)  (not used)
SPI_SPEED9                             9  0x00000009 (const dword)  (not used)
spi_Write                           -338  0xfffffeae (PmmC func) args[1] r=0  (not used)
spi_WriteBlock                      -358  0xfffffe9a (PmmC func) args[2] r=0  (not used)
spiflash_BlockErase                 -541  0xfffffde3 (PmmC func) args[3] r=0  (not used)
spiflash_BulkErase                  -540  0xfffffde4 (PmmC func) args[2] r=0  (not used)
spiflash_Exec                       -554  0xfffffdd6 (PmmC func) args[3] r=1  (not used)
spiflash_GetC                       -547  0xfffffddd (PmmC func) args[2] r=1  (not used)
spiflash_GetS                       -551  0xfffffdd9 (PmmC func) args[4] r=1  (not used)
spiflash_GetW                       -549  0xfffffddb (PmmC func) args[2] r=1  (not used)
spiflash_ID                         -539  0xfffffde5 (PmmC func) args[2] r=1  (not used)
spiflash_Image                      -545  0xfffffddf (PmmC func) args[4] r=1  (not used)
spiflash_LoadFunction               -552  0xfffffdd8 (PmmC func) args[2] r=1  (not used)
spiflash_LoadImageControl           -555  0xfffffdd5 (PmmC func) args[2] r=1  (not used)
spiflash_PlayWAV                    -556  0xfffffdd4 (PmmC func) args[2] r=1  (not used)
spiflash_PutC                       -546  0xfffffdde (PmmC func) args[3] r=0  (not used)
spiflash_PutS                       -550  0xfffffdda (PmmC func) args[3] r=1  (not used)
spiflash_PutW                       -548  0xfffffddc (PmmC func) args[3] r=0  (not used)
spiflash_Read                       -543  0xfffffde1 (PmmC func) args[4] r=1  (not used)
spiflash_Run                        -553  0xfffffdd7 (PmmC func) args[3] r=1  (not used)
spiflash_SetAdd                     -542  0xfffffde2 (PmmC func) args[3] r=0  (not used)
spiflash_SIG                        -538  0xfffffde6 (PmmC func) args[2] r=1  (not used)
spiflash_Write                      -544  0xfffffde0 (PmmC func) args[4] r=1  (not used)
SPRINGGREEN                         2031  0x000007ef (const dword)  (usage 2)
SQRT                                 -62  0xffffffc2 (PmmC func) args[1] r=1  (not used)
state                                  4  0x00000004 (mem) word (global)  (usage 35)
STEELBLUE                          17430  0x00004416 (const dword)  (usage 2)
STR                                  128  0x00000080 (const dword)  (not used)
str_ByteMove                        -487  0xfffffe19 (PmmC func) args[3] r=1  (not used)
str_Cat                             -485  0xfffffe1b (PmmC func) args[2] r=1  (not used)
str_CatN                            -486  0xfffffe1a (PmmC func) args[3] r=1  (not used)
str_Copy                            -488  0xfffffe18 (PmmC func) args[2] r=1  (not used)
str_CopyN                           -489  0xfffffe17 (PmmC func) args[3] r=1  (not used)
str_Find                            -481  0xfffffe1f (PmmC func) args[2] r=1  (not used)
str_FindI                           -482  0xfffffe1e (PmmC func) args[2] r=1  (not used)
str_GetByte                         -475  0xfffffe25 (PmmC func) args[1] r=1  (not used)
str_GetC                            -474  0xfffffe26 (PmmC func) args[2] r=1  (not used)
str_GetD                            -471  0xfffffe29 (PmmC func) args[2] r=1  (not used)
str_GetHexW                         -473  0xfffffe27 (PmmC func) args[2] r=1  (not used)
str_GetW                            -472  0xfffffe28 (PmmC func) args[2] r=1  (not used)
str_GetWord                         -476  0xfffffe24 (PmmC func) args[1] r=1  (not used)
str_Length                          -483  0xfffffe1d (PmmC func) args[1] r=1  (not used)
str_Match                           -479  0xfffffe21 (PmmC func) args[2] r=1  (not used)
str_MatchI                          -480  0xfffffe20 (PmmC func) args[2] r=1  (not used)
str_Printf                          -484  0xfffffe1c (PmmC func) args[2] r=1  (not used)
str_Ptr                             -470  0xfffffe2a (PmmC func) args[1] r=1  (not used)
str_PutByte                         -477  0xfffffe23 (PmmC func) args[2] r=0  (not used)
str_PutWord                         -478  0xfffffe22 (PmmC func) args[2] r=0  (not used)
strheight                            -14  0xfffffff2 (PmmC func) args[0] r=1  (not used)
strlen                               -10  0xfffffff6 (PmmC func) args[1] r=1  (not used)
strwidth                             -13  0xfffffff3 (PmmC func) args[1] r=1  (not used)
STYLE1                                 2  0x00000002 (const dword)  (not used)
STYLE2                                 3  0x00000003 (const dword)  (not used)
SWAP                                 -56  0xffffffc8 (PmmC func) args[2] r=0  (not used)
sys_DeepSleep                       -405  0xfffffe6b (PmmC func) args[1] r=1  (not used)
sys_Driver                          -531  0xfffffded (PmmC func) args[0] r=0  (not used)
sys_ErrorMessage                    -534  0xfffffdea (PmmC func) args[1] r=1  (not used)
sys_EventQueue                      -396  0xfffffe74 (PmmC func) args[0] r=1  (not used)
sys_EventsPostpone                  -397  0xfffffe73 (PmmC func) args[0] r=0  (not used)
sys_EventsResume                    -398  0xfffffe72 (PmmC func) args[0] r=0  (not used)
sys_GetDate                         -401  0xfffffe6f (PmmC func) args[0] r=0  (not used)
sys_GetTime                         -399  0xfffffe71 (PmmC func) args[0] r=0  (not used)
sys_GetTimer                        -394  0xfffffe76 (PmmC func) args[1] r=1  (not used)
sys_PmmC                            -530  0xfffffdee (PmmC func) args[0] r=0  (not used)
sys_SetDate                         -402  0xfffffe6e (PmmC func) args[3] r=1  (not used)
sys_SetTime                         -400  0xfffffe70 (PmmC func) args[3] r=1  (not used)
sys_SetTimer                        -393  0xfffffe77 (PmmC func) args[2] r=0  (not used)
sys_SetTimerEvent                   -395  0xfffffe75 (PmmC func) args[2] r=1  (not used)
sys_Sleep                           -403  0xfffffe6d (PmmC func) args[1] r=1  (not used)
sys_StoreTouchCalibration           -368  0xfffffe90 (PmmC func) args[0] r=1  (not used)
sys_T                               -391  0xfffffe79 (PmmC func) args[0] r=1  (not used)
sys_T_HI                            -392  0xfffffe78 (PmmC func) args[0] r=1  (not used)
SYS_X_MAX                             44  0x0000002c (const dword)  (not used)
SYS_Y_MAX                             45  0x0000002d (const dword)  (not used)
SYSTEM_TIMER_HI                       35  0x00000023 (const dword)  (not used)
SYSTEM_TIMER_LO                       34  0x00000022 (const dword)  (not used)
TAN                                54705  0x0000d5b1 (const dword)  (usage 2)
TB1                                  100  0x00000064 (const dword)  (not used)
TB2                                  101  0x00000065 (const dword)  (not used)
TB3                                  102  0x00000066 (const dword)  (not used)
TB4                                  103  0x00000067 (const dword)  (not used)
TEAL                                1040  0x00000410 (const dword)  (usage 8)
TEXT                               63489  0x0000f801 (const dword)  (not used)
TEXT_ANGLE                            15  0x0000000f (const dword)  (not used)
TEXT_ATTRIBUTES                       13  0x0000000d (const dword)  (not used)
TEXT_BACKGROUND                        1  0x00000001 (const dword)  (not used)
TEXT_BOLD                              9  0x00000009 (const dword)  (not used)
TEXT_COLOUR                            0  0x00000000 (const dword)  (not used)
TEXT_HEIGHT                            4  0x00000004 (const dword)  (not used)
TEXT_HIGHLIGHT                         1  0x00000001 (const dword)  (not used)
TEXT_INVERSE                          11  0x0000000b (const dword)  (not used)
TEXT_ITALIC                           10  0x0000000a (const dword)  (not used)
TEXT_MARGIN                           97  0x00000061 (const dword)  (not used)
TEXT_OPACITY                           8  0x00000008 (const dword)  (not used)
TEXT_PRINTDELAY                        7  0x00000007 (const dword)  (not used)
TEXT_UNDERLINED                       12  0x0000000c (const dword)  (not used)
TEXT_WIDTH                             3  0x00000003 (const dword)  (not used)
TEXT_WRAP                             14  0x0000000e (const dword)  (not used)
TEXT_XGAP                              5  0x00000005 (const dword)  (not used)
TEXT_XPOS                             95  0x0000005f (const dword)  (not used)
TEXT_YGAP                              6  0x00000006 (const dword)  (not used)
TEXT_YPOS                             96  0x00000060 (const dword)  (not used)
thicknessInput                      1874  0x00000752 (User func) args[0] r=0  (usage 3)
THISTLE                            56827  0x0000ddfb (const dword)  (usage 2)
TIMER0                                 0  0x00000000 (const dword)  (not used)
TIMER1                                 1  0x00000001 (const dword)  (not used)
TIMER2                                 2  0x00000002 (const dword)  (not used)
TIMER3                                 3  0x00000003 (const dword)  (not used)
TIMER4                                 4  0x00000004 (const dword)  (not used)
TIMER5                                 5  0x00000005 (const dword)  (not used)
TIMER6                                 6  0x00000006 (const dword)  (not used)
TIMER7                                 7  0x00000007 (const dword)  (not used)
TMR0                                  36  0x00000024 (const dword)  (not used)
TMR1                                  37  0x00000025 (const dword)  (not used)
TMR2                                  38  0x00000026 (const dword)  (not used)
TMR3                                  39  0x00000027 (const dword)  (not used)
TMR4                                  40  0x00000028 (const dword)  (not used)
TMR5                                  41  0x00000029 (const dword)  (not used)
TMR6                                  42  0x0000002a (const dword)  (not used)
TMR7                                  43  0x0000002b (const dword)  (not used)
to                                    -1  0xffffffff (PmmC func) args[1] r=0  (not used)
tolower                              -46  0xffffffd2 (PmmC func) args[1] r=1  (not used)
TOMATO                             64264  0x0000fb08 (const dword)  (usage 2)
TOP_POS                                3  0x00000003 (const dword)  (not used)
touch_DetectRegion                  -406  0xfffffe6a (PmmC func) args[4] r=0  (not used)
TOUCH_DISABLE                          1  0x00000001 (const dword)  (not used)
TOUCH_ENABLE                           0  0x00000000 (const dword)  (usage 3)
touch_Get                           -408  0xfffffe68 (PmmC func) args[1] r=1  (usage 12)
TOUCH_GETX                             1  0x00000001 (const dword)  (usage 3)
TOUCH_GETY                             2  0x00000002 (const dword)  (usage 3)
TOUCH_MOVING                           3  0x00000003 (const dword)  (usage 3)
TOUCH_PRESSED                          1  0x00000001 (const dword)  (usage 29)
TOUCH_RAW_X                          117  0x00000075 (const dword)  (not used)
TOUCH_RAW_Y                          118  0x00000076 (const dword)  (not used)
TOUCH_REGIONDEFAULT                    2  0x00000002 (const dword)  (not used)
TOUCH_RELEASED                         2  0x00000002 (const dword)  (not used)
touch_Set                           -407  0xfffffe69 (PmmC func) args[1] r=0  (usage 3)
TOUCH_STATUS                           0  0x00000000 (const dword)  (usage 6)
touch_TestArea                      -410  0xfffffe66 (PmmC func) args[1] r=1  (not used)
touch_TestBox                       -409  0xfffffe67 (PmmC func) args[1] r=1  (not used)
TOUCH_XMAXCAL                         80  0x00000050 (const dword)  (not used)
TOUCH_XMINCAL                         78  0x0000004e (const dword)  (not used)
TOUCH_YMAXCAL                         81  0x00000051 (const dword)  (not used)
TOUCH_YMINCAL                         79  0x0000004f (const dword)  (not used)
toupper                              -45  0xffffffd3 (PmmC func) args[1] r=1  (not used)
TRANSPARENCY                          21  0x00000015 (const dword)  (not used)
TRANSPARENT                            0  0x00000000 (const dword)  (usage 3)
TRANSPARENT_COLOUR                    20  0x00000014 (const dword)  (not used)
true                                   1  0x00000001 (const dword)  (usage 24)
TURQUOISE                          18202  0x0000471a (const dword)  (usage 2)
txt_Angle                            -33  0xffffffdf (PmmC func) args[1] r=1  (not used)
txt_Attributes                       -31  0xffffffe1 (PmmC func) args[1] r=1  (not used)
txt_BGcolour                         -19  0xffffffed (PmmC func) args[1] r=1  (usage 39)
txt_Bold                             -27  0xffffffe5 (PmmC func) args[1] r=1  (not used)
txt_Delay                            -25  0xffffffe7 (PmmC func) args[1] r=1  (not used)
txt_FGcolour                         -18  0xffffffee (PmmC func) args[1] r=1  (usage 93)
TXT_FONT_HEIGHT                      102  0x00000066 (const dword)  (not used)
TXT_FONT_ID                           98  0x00000062 (const dword)  (not used)
TXT_FONT_MAX                          99  0x00000063 (const dword)  (not used)
TXT_FONT_OFFSET                      100  0x00000064 (const dword)  (not used)
TXT_FONT_WIDTH                       101  0x00000065 (const dword)  (not used)
txt_FontID                           -20  0xffffffec (PmmC func) args[1] r=1  (not used)
txt_Height                           -22  0xffffffea (PmmC func) args[1] r=1  (usage 6)
txt_Inverse                          -29  0xffffffe3 (PmmC func) args[1] r=1  (not used)
txt_Italic                           -28  0xffffffe4 (PmmC func) args[1] r=1  (not used)
txt_MoveCursor                       -16  0xfffffff0 (PmmC func) args[2] r=0  (not used)
txt_Opacity                          -26  0xffffffe6 (PmmC func) args[1] r=1  (usage 6)
txt_Set                              -17  0xffffffef (PmmC func) args[2] r=0  (not used)
txt_Underline                        -30  0xffffffe2 (PmmC func) args[1] r=1  (not used)
txt_Width                            -21  0xffffffeb (PmmC func) args[1] r=1  (usage 6)
txt_Wrap                             -32  0xffffffe0 (PmmC func) args[1] r=1  (not used)
txt_Xgap                             -23  0xffffffe9 (PmmC func) args[1] r=1  (not used)
txt_Ygap                             -24  0xffffffe8 (PmmC func) args[1] r=1  (not used)
uadd_3232                            -71  0xffffffb9 (PmmC func) args[3] r=1  (not used)
ucmp_3232                            -75  0xffffffb5 (PmmC func) args[2] r=1  (not used)
UDEC                               17674  0x0000450a (const dword)  (not used)
UDEC1                              16650  0x0000410a (const dword)  (not used)
UDEC1Z                             20746  0x0000510a (const dword)  (not used)
UDEC1ZB                            24842  0x0000610a (const dword)  (not used)
UDEC2                              16906  0x0000420a (const dword)  (not used)
UDEC2Z                             21002  0x0000520a (const dword)  (not used)
UDEC2ZB                            25098  0x0000620a (const dword)  (not used)
UDEC3                              17162  0x0000430a (const dword)  (not used)
UDEC3Z                             21258  0x0000530a (const dword)  (not used)
UDEC3ZB                            25354  0x0000630a (const dword)  (not used)
UDEC4                              17418  0x0000440a (const dword)  (not used)
UDEC4Z                             21514  0x0000540a (const dword)  (not used)
UDEC4ZB                            25610  0x0000640a (const dword)  (not used)
UDEC5                              17674  0x0000450a (const dword)  (not used)
UDEC5Z                             21770  0x0000550a (const dword)  (not used)
UDEC5ZB                            25866  0x0000650a (const dword)  (not used)
UDECZ                              21770  0x0000550a (const dword)  (not used)
UDECZB                             25866  0x0000650a (const dword)  (not used)
udiv_3232                            -74  0xffffffb6 (PmmC func) args[3] r=1  (not used)
ULCD_70DT_DIABLO16_GFX                 0  0x00000000 (const ??? 0)  (not used)
umul_1616                            -73  0xffffffb7 (PmmC func) args[3] r=1  (not used)
UNCHECKED                              1  0x00000001 (const dword)  (not used)
UNDERLINED                           128  0x00000080 (const dword)  (not used)
unicode_page                         -15  0xfffffff1 (PmmC func) args[3] r=1  (not used)
UP                                     1  0x00000001 (const dword)  (not used)
updateGlobal                       12235  0x00002fcb (User func) args[0] r=0  (usage 29)
usub_3232                            -72  0xffffffb8 (PmmC func) args[3] r=1  (not used)
VIOLET                             60445  0x0000ec1d (const dword)  (usage 2)
welcomeScreen                      12364  0x0000304c (User func) args[0] r=0  (usage 3)
WHEAT                              63222  0x0000f6f6 (const dword)  (usage 2)
WHITE                              65535  0x0000ffff (const dword)  (usage 80)
WHITESMOKE                         63422  0x0000f7be (const dword)  (usage 2)
x                                      6  0x00000006 (mem) word (global)  (usage 276)
X_MAX                                  0  0x00000000 (const dword)  (not used)
X_ORG                                  6  0x00000006 (const dword)  (not used)
X_ORIGIN                              30  0x0000001e (const dword)  (not used)
y                                      8  0x00000008 (mem) word (global)  (usage 252)
Y_MAX                                  1  0x00000001 (const dword)  (not used)
Y_ORG                                  7  0x00000007 (const dword)  (not used)
Y_ORIGIN                              31  0x0000001f (const dword)  (not used)
YELLOW                             65504  0x0000ffe0 (const dword)  (usage 5)
YELLOWGREEN                        40550  0x00009e66 (const dword)  (usage 2)
